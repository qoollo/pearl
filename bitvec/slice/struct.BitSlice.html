<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Bit-Addressable Memory"><meta name="keywords" content="rust, rustlang, rust-lang, BitSlice"><title>BitSlice in bitvec::slice - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" href="../../normalize.css"><link rel="stylesheet" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" href="../../ayu.css" disabled><link rel="stylesheet" href="../../dark.css" disabled><link rel="stylesheet" href="../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../storage.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../main.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../favicon.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../bitvec/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div></a><h2></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../../bitvec/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div></a><h2 class="location"><a href="#">BitSlice</a></h2><div class="sidebar-elems"><section><h3><a href="#implementations">Associated Constants</a></h3><ul class="block"><li><a href="#associatedconstant.MAX_BITS">MAX_BITS</a></li><li><a href="#associatedconstant.MAX_ELTS">MAX_ELTS</a></li></ul><h3><a href="#implementations">Methods</a></h3><ul class="block"><li><a href="#method.align_to">align_to</a></li><li><a href="#method.align_to_mut">align_to_mut</a></li><li><a href="#method.all">all</a></li><li><a href="#method.any">any</a></li><li><a href="#method.as_bitptr">as_bitptr</a></li><li><a href="#method.as_bitptr_range">as_bitptr_range</a></li><li><a href="#method.as_mut_bitptr">as_mut_bitptr</a></li><li><a href="#method.as_mut_bitptr_range">as_mut_bitptr_range</a></li><li><a href="#method.as_mut_ptr">as_mut_ptr</a></li><li><a href="#method.as_mut_ptr_range">as_mut_ptr_range</a></li><li><a href="#method.as_ptr">as_ptr</a></li><li><a href="#method.as_ptr_range">as_ptr_range</a></li><li><a href="#method.bit_domain">bit_domain</a></li><li><a href="#method.bit_domain_mut">bit_domain_mut</a></li><li><a href="#method.chunks">chunks</a></li><li><a href="#method.chunks_exact">chunks_exact</a></li><li><a href="#method.chunks_exact_mut">chunks_exact_mut</a></li><li><a href="#method.chunks_mut">chunks_mut</a></li><li><a href="#method.clone_from_bitslice">clone_from_bitslice</a></li><li><a href="#method.clone_from_slice">clone_from_slice</a></li><li><a href="#method.contains">contains</a></li><li><a href="#method.copy_from_bitslice">copy_from_bitslice</a></li><li><a href="#method.copy_from_slice">copy_from_slice</a></li><li><a href="#method.copy_within">copy_within</a></li><li><a href="#method.copy_within_unchecked">copy_within_unchecked</a></li><li><a href="#method.count_ones">count_ones</a></li><li><a href="#method.count_zeros">count_zeros</a></li><li><a href="#method.domain">domain</a></li><li><a href="#method.domain_mut">domain_mut</a></li><li><a href="#method.empty">empty</a></li><li><a href="#method.empty_mut">empty_mut</a></li><li><a href="#method.ends_with">ends_with</a></li><li><a href="#method.fill">fill</a></li><li><a href="#method.fill_with">fill_with</a></li><li><a href="#method.first">first</a></li><li><a href="#method.first_mut">first_mut</a></li><li><a href="#method.first_one">first_one</a></li><li><a href="#method.first_zero">first_zero</a></li><li><a href="#method.from_element">from_element</a></li><li><a href="#method.from_element_mut">from_element_mut</a></li><li><a href="#method.from_slice">from_slice</a></li><li><a href="#method.from_slice_mut">from_slice_mut</a></li><li><a href="#method.from_slice_unchecked">from_slice_unchecked</a></li><li><a href="#method.from_slice_unchecked_mut">from_slice_unchecked_mut</a></li><li><a href="#method.get">get</a></li><li><a href="#method.get_mut">get_mut</a></li><li><a href="#method.get_unchecked">get_unchecked</a></li><li><a href="#method.get_unchecked_mut">get_unchecked_mut</a></li><li><a href="#method.is_empty">is_empty</a></li><li><a href="#method.iter">iter</a></li><li><a href="#method.iter_mut">iter_mut</a></li><li><a href="#method.iter_ones">iter_ones</a></li><li><a href="#method.iter_zeros">iter_zeros</a></li><li><a href="#method.last">last</a></li><li><a href="#method.last_mut">last_mut</a></li><li><a href="#method.last_one">last_one</a></li><li><a href="#method.last_zero">last_zero</a></li><li><a href="#method.leading_ones">leading_ones</a></li><li><a href="#method.leading_zeros">leading_zeros</a></li><li><a href="#method.len">len</a></li><li><a href="#method.not_all">not_all</a></li><li><a href="#method.not_any">not_any</a></li><li><a href="#method.rchunks">rchunks</a></li><li><a href="#method.rchunks_exact">rchunks_exact</a></li><li><a href="#method.rchunks_exact_mut">rchunks_exact_mut</a></li><li><a href="#method.rchunks_mut">rchunks_mut</a></li><li><a href="#method.repeat">repeat</a></li><li><a href="#method.replace">replace</a></li><li><a href="#method.replace_unchecked">replace_unchecked</a></li><li><a href="#method.reverse">reverse</a></li><li><a href="#method.rotate_left">rotate_left</a></li><li><a href="#method.rotate_right">rotate_right</a></li><li><a href="#method.rsplit">rsplit</a></li><li><a href="#method.rsplit_mut">rsplit_mut</a></li><li><a href="#method.rsplitn">rsplitn</a></li><li><a href="#method.rsplitn_mut">rsplitn_mut</a></li><li><a href="#method.set">set</a></li><li><a href="#method.set_aliased">set_aliased</a></li><li><a href="#method.set_aliased_unchecked">set_aliased_unchecked</a></li><li><a href="#method.set_unchecked">set_unchecked</a></li><li><a href="#method.shift_left">shift_left</a></li><li><a href="#method.shift_right">shift_right</a></li><li><a href="#method.some">some</a></li><li><a href="#method.split">split</a></li><li><a href="#method.split_at">split_at</a></li><li><a href="#method.split_at_mut">split_at_mut</a></li><li><a href="#method.split_at_unchecked">split_at_unchecked</a></li><li><a href="#method.split_at_unchecked_mut">split_at_unchecked_mut</a></li><li><a href="#method.split_first">split_first</a></li><li><a href="#method.split_first_mut">split_first_mut</a></li><li><a href="#method.split_inclusive">split_inclusive</a></li><li><a href="#method.split_inclusive_mut">split_inclusive_mut</a></li><li><a href="#method.split_last">split_last</a></li><li><a href="#method.split_last_mut">split_last_mut</a></li><li><a href="#method.split_mut">split_mut</a></li><li><a href="#method.splitn">splitn</a></li><li><a href="#method.splitn_mut">splitn_mut</a></li><li><a href="#method.starts_with">starts_with</a></li><li><a href="#method.strip_prefix">strip_prefix</a></li><li><a href="#method.strip_suffix">strip_suffix</a></li><li><a href="#method.swap">swap</a></li><li><a href="#method.swap_unchecked">swap_unchecked</a></li><li><a href="#method.swap_with_bitslice">swap_with_bitslice</a></li><li><a href="#method.swap_with_slice">swap_with_slice</a></li><li><a href="#method.to_bitvec">to_bitvec</a></li><li><a href="#method.to_vec">to_vec</a></li><li><a href="#method.trailing_ones">trailing_ones</a></li><li><a href="#method.trailing_zeros">trailing_zeros</a></li><li><a href="#method.try_from_slice">try_from_slice</a></li><li><a href="#method.try_from_slice_mut">try_from_slice_mut</a></li><li><a href="#method.windows">windows</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block"><li><a href="#impl-AsMut%3CBitSlice%3C%3CA%20as%20BitView%3E%3A%3AStore%2C%20O%3E%3E-for-BitArray%3CA%2C%20O%3E">AsMut&lt;BitSlice&lt;&lt;A as BitView&gt;::Store, O&gt;&gt;</a></li><li><a href="#impl-AsMut%3CBitSlice%3CT%2C%20O%3E%3E-for-BitBox%3CT%2C%20O%3E">AsMut&lt;BitSlice&lt;T, O&gt;&gt;</a></li><li><a href="#impl-AsMut%3CBitSlice%3CT%2C%20O%3E%3E-for-BitSlice%3CT%2C%20O%3E">AsMut&lt;BitSlice&lt;T, O&gt;&gt;</a></li><li><a href="#impl-AsMut%3CBitSlice%3CT%2C%20O%3E%3E-for-BitVec%3CT%2C%20O%3E">AsMut&lt;BitSlice&lt;T, O&gt;&gt;</a></li><li><a href="#impl-AsRef%3CBitSlice%3C%3CA%20as%20BitView%3E%3A%3AStore%2C%20O%3E%3E-for-BitArray%3CA%2C%20O%3E">AsRef&lt;BitSlice&lt;&lt;A as BitView&gt;::Store, O&gt;&gt;</a></li><li><a href="#impl-AsRef%3CBitSlice%3C%3CT%20as%20BitStore%3E%3A%3AAlias%2C%20O%3E%3E-for-IterMut%3C%27_%2C%20T%2C%20O%3E">AsRef&lt;BitSlice&lt;&lt;T as BitStore&gt;::Alias, O&gt;&gt;</a></li><li><a href="#impl-AsRef%3CBitSlice%3CT%2C%20O%3E%3E-for-BitBox%3CT%2C%20O%3E">AsRef&lt;BitSlice&lt;T, O&gt;&gt;</a></li><li><a href="#impl-AsRef%3CBitSlice%3CT%2C%20O%3E%3E-for-BitSlice%3CT%2C%20O%3E">AsRef&lt;BitSlice&lt;T, O&gt;&gt;</a></li><li><a href="#impl-AsRef%3CBitSlice%3CT%2C%20O%3E%3E-for-BitVec%3CT%2C%20O%3E">AsRef&lt;BitSlice&lt;T, O&gt;&gt;</a></li><li><a href="#impl-AsRef%3CBitSlice%3CT%2C%20O%3E%3E-for-Drain%3C%27_%2C%20T%2C%20O%3E">AsRef&lt;BitSlice&lt;T, O&gt;&gt;</a></li><li><a href="#impl-AsRef%3CBitSlice%3CT%2C%20O%3E%3E-for-IntoIter%3CT%2C%20O%3E">AsRef&lt;BitSlice&lt;T, O&gt;&gt;</a></li><li><a href="#impl-AsRef%3CBitSlice%3CT%2C%20O%3E%3E-for-Iter%3C%27_%2C%20T%2C%20O%3E">AsRef&lt;BitSlice&lt;T, O&gt;&gt;</a></li><li><a href="#impl-Binary-for-BitSlice%3CT%2C%20O%3E">Binary</a></li><li><a href="#impl-BitAndAssign%3C%26BitArray%3CA%2C%20O%3E%3E-for-BitSlice%3CA%3A%3AStore%2C%20O%3E">BitAndAssign&lt;&amp;BitArray&lt;A, O&gt;&gt;</a></li><li><a href="#impl-BitAndAssign%3C%26BitBox%3CT%2C%20O%3E%3E-for-BitSlice%3CT%2C%20O%3E">BitAndAssign&lt;&amp;BitBox&lt;T, O&gt;&gt;</a></li><li><a href="#impl-BitAndAssign%3C%26BitSlice%3CT2%2C%20O2%3E%3E-for-BitSlice%3CT1%2C%20O1%3E">BitAndAssign&lt;&amp;BitSlice&lt;T2, O2&gt;&gt;</a></li><li><a href="#impl-BitAndAssign%3C%26BitVec%3CT%2C%20O%3E%3E-for-BitSlice%3CT%2C%20O%3E">BitAndAssign&lt;&amp;BitVec&lt;T, O&gt;&gt;</a></li><li><a href="#impl-BitAndAssign%3CBitArray%3CA%2C%20O%3E%3E-for-BitSlice%3CA%3A%3AStore%2C%20O%3E">BitAndAssign&lt;BitArray&lt;A, O&gt;&gt;</a></li><li><a href="#impl-BitAndAssign%3CBitBox%3CT%2C%20O%3E%3E-for-BitSlice%3CT%2C%20O%3E">BitAndAssign&lt;BitBox&lt;T, O&gt;&gt;</a></li><li><a href="#impl-BitAndAssign%3CBitVec%3CT%2C%20O%3E%3E-for-BitSlice%3CT%2C%20O%3E">BitAndAssign&lt;BitVec&lt;T, O&gt;&gt;</a></li><li><a href="#impl-BitField-for-BitSlice%3CT%2C%20Lsb0%3E">BitField</a></li><li><a href="#impl-BitField-for-BitSlice%3CT%2C%20Msb0%3E">BitField</a></li><li><a href="#impl-BitOrAssign%3C%26BitArray%3CA%2C%20O%3E%3E-for-BitSlice%3CA%3A%3AStore%2C%20O%3E">BitOrAssign&lt;&amp;BitArray&lt;A, O&gt;&gt;</a></li><li><a href="#impl-BitOrAssign%3C%26BitBox%3CT%2C%20O%3E%3E-for-BitSlice%3CT%2C%20O%3E">BitOrAssign&lt;&amp;BitBox&lt;T, O&gt;&gt;</a></li><li><a href="#impl-BitOrAssign%3C%26BitSlice%3CT2%2C%20O2%3E%3E-for-BitSlice%3CT1%2C%20O1%3E">BitOrAssign&lt;&amp;BitSlice&lt;T2, O2&gt;&gt;</a></li><li><a href="#impl-BitOrAssign%3C%26BitVec%3CT%2C%20O%3E%3E-for-BitSlice%3CT%2C%20O%3E">BitOrAssign&lt;&amp;BitVec&lt;T, O&gt;&gt;</a></li><li><a href="#impl-BitOrAssign%3CBitArray%3CA%2C%20O%3E%3E-for-BitSlice%3CA%3A%3AStore%2C%20O%3E">BitOrAssign&lt;BitArray&lt;A, O&gt;&gt;</a></li><li><a href="#impl-BitOrAssign%3CBitBox%3CT%2C%20O%3E%3E-for-BitSlice%3CT%2C%20O%3E">BitOrAssign&lt;BitBox&lt;T, O&gt;&gt;</a></li><li><a href="#impl-BitOrAssign%3CBitVec%3CT%2C%20O%3E%3E-for-BitSlice%3CT%2C%20O%3E">BitOrAssign&lt;BitVec&lt;T, O&gt;&gt;</a></li><li><a href="#impl-BitXorAssign%3C%26BitArray%3CA%2C%20O%3E%3E-for-BitSlice%3CA%3A%3AStore%2C%20O%3E">BitXorAssign&lt;&amp;BitArray&lt;A, O&gt;&gt;</a></li><li><a href="#impl-BitXorAssign%3C%26BitBox%3CT%2C%20O%3E%3E-for-BitSlice%3CT%2C%20O%3E">BitXorAssign&lt;&amp;BitBox&lt;T, O&gt;&gt;</a></li><li><a href="#impl-BitXorAssign%3C%26BitSlice%3CT2%2C%20O2%3E%3E-for-BitSlice%3CT1%2C%20O1%3E">BitXorAssign&lt;&amp;BitSlice&lt;T2, O2&gt;&gt;</a></li><li><a href="#impl-BitXorAssign%3C%26BitVec%3CT%2C%20O%3E%3E-for-BitSlice%3CT%2C%20O%3E">BitXorAssign&lt;&amp;BitVec&lt;T, O&gt;&gt;</a></li><li><a href="#impl-BitXorAssign%3CBitArray%3CA%2C%20O%3E%3E-for-BitSlice%3CA%3A%3AStore%2C%20O%3E">BitXorAssign&lt;BitArray&lt;A, O&gt;&gt;</a></li><li><a href="#impl-BitXorAssign%3CBitBox%3CT%2C%20O%3E%3E-for-BitSlice%3CT%2C%20O%3E">BitXorAssign&lt;BitBox&lt;T, O&gt;&gt;</a></li><li><a href="#impl-BitXorAssign%3CBitVec%3CT%2C%20O%3E%3E-for-BitSlice%3CT%2C%20O%3E">BitXorAssign&lt;BitVec&lt;T, O&gt;&gt;</a></li><li><a href="#impl-Borrow%3CBitSlice%3C%3CA%20as%20BitView%3E%3A%3AStore%2C%20O%3E%3E-for-BitArray%3CA%2C%20O%3E">Borrow&lt;BitSlice&lt;&lt;A as BitView&gt;::Store, O&gt;&gt;</a></li><li><a href="#impl-Borrow%3CBitSlice%3CT%2C%20O%3E%3E-for-BitBox%3CT%2C%20O%3E">Borrow&lt;BitSlice&lt;T, O&gt;&gt;</a></li><li><a href="#impl-Borrow%3CBitSlice%3CT%2C%20O%3E%3E-for-BitVec%3CT%2C%20O%3E">Borrow&lt;BitSlice&lt;T, O&gt;&gt;</a></li><li><a href="#impl-BorrowMut%3CBitSlice%3C%3CA%20as%20BitView%3E%3A%3AStore%2C%20O%3E%3E-for-BitArray%3CA%2C%20O%3E">BorrowMut&lt;BitSlice&lt;&lt;A as BitView&gt;::Store, O&gt;&gt;</a></li><li><a href="#impl-BorrowMut%3CBitSlice%3CT%2C%20O%3E%3E-for-BitBox%3CT%2C%20O%3E">BorrowMut&lt;BitSlice&lt;T, O&gt;&gt;</a></li><li><a href="#impl-BorrowMut%3CBitSlice%3CT%2C%20O%3E%3E-for-BitVec%3CT%2C%20O%3E">BorrowMut&lt;BitSlice&lt;T, O&gt;&gt;</a></li><li><a href="#impl-Debug-for-BitSlice%3CT%2C%20O%3E">Debug</a></li><li><a href="#impl-Default-for-%26BitSlice%3CT%2C%20O%3E">Default</a></li><li><a href="#impl-Default-for-%26mut%20BitSlice%3CT%2C%20O%3E">Default</a></li><li><a href="#impl-Display-for-BitSlice%3CT%2C%20O%3E">Display</a></li><li><a href="#impl-Eq-for-BitSlice%3CT%2C%20O%3E">Eq</a></li><li><a href="#impl-From%3C%26BitSlice%3CT%2C%20O%3E%3E-for-BitBox%3CT%2C%20O%3E">From&lt;&amp;BitSlice&lt;T, O&gt;&gt;</a></li><li><a href="#impl-From%3C%26BitSlice%3CT%2C%20O%3E%3E-for-BitVec%3CT%2C%20O%3E">From&lt;&amp;BitSlice&lt;T, O&gt;&gt;</a></li><li><a href="#impl-From%3C%26mut%20BitSlice%3CT%2C%20O%3E%3E-for-BitVec%3CT%2C%20O%3E">From&lt;&amp;mut BitSlice&lt;T, O&gt;&gt;</a></li><li><a href="#impl-Hash-for-BitSlice%3CT%2C%20O%3E">Hash</a></li><li><a href="#impl-Index%3CRange%3Cusize%3E%3E-for-BitSlice%3CT%2C%20O%3E">Index&lt;Range&lt;usize&gt;&gt;</a></li><li><a href="#impl-Index%3CRangeFrom%3Cusize%3E%3E-for-BitSlice%3CT%2C%20O%3E">Index&lt;RangeFrom&lt;usize&gt;&gt;</a></li><li><a href="#impl-Index%3CRangeFull%3E-for-BitSlice%3CT%2C%20O%3E">Index&lt;RangeFull&gt;</a></li><li><a href="#impl-Index%3CRangeInclusive%3Cusize%3E%3E-for-BitSlice%3CT%2C%20O%3E">Index&lt;RangeInclusive&lt;usize&gt;&gt;</a></li><li><a href="#impl-Index%3CRangeTo%3Cusize%3E%3E-for-BitSlice%3CT%2C%20O%3E">Index&lt;RangeTo&lt;usize&gt;&gt;</a></li><li><a href="#impl-Index%3CRangeToInclusive%3Cusize%3E%3E-for-BitSlice%3CT%2C%20O%3E">Index&lt;RangeToInclusive&lt;usize&gt;&gt;</a></li><li><a href="#impl-Index%3Cusize%3E-for-BitSlice%3CT%2C%20O%3E">Index&lt;usize&gt;</a></li><li><a href="#impl-IndexMut%3CRange%3Cusize%3E%3E-for-BitSlice%3CT%2C%20O%3E">IndexMut&lt;Range&lt;usize&gt;&gt;</a></li><li><a href="#impl-IndexMut%3CRangeFrom%3Cusize%3E%3E-for-BitSlice%3CT%2C%20O%3E">IndexMut&lt;RangeFrom&lt;usize&gt;&gt;</a></li><li><a href="#impl-IndexMut%3CRangeFull%3E-for-BitSlice%3CT%2C%20O%3E">IndexMut&lt;RangeFull&gt;</a></li><li><a href="#impl-IndexMut%3CRangeInclusive%3Cusize%3E%3E-for-BitSlice%3CT%2C%20O%3E">IndexMut&lt;RangeInclusive&lt;usize&gt;&gt;</a></li><li><a href="#impl-IndexMut%3CRangeTo%3Cusize%3E%3E-for-BitSlice%3CT%2C%20O%3E">IndexMut&lt;RangeTo&lt;usize&gt;&gt;</a></li><li><a href="#impl-IndexMut%3CRangeToInclusive%3Cusize%3E%3E-for-BitSlice%3CT%2C%20O%3E">IndexMut&lt;RangeToInclusive&lt;usize&gt;&gt;</a></li><li><a href="#impl-IntoIterator-for-%26%27a%20BitSlice%3CT%2C%20O%3E">IntoIterator</a></li><li><a href="#impl-IntoIterator-for-%26%27a%20mut%20BitSlice%3CT%2C%20O%3E">IntoIterator</a></li><li><a href="#impl-LowerHex-for-BitSlice%3CT%2C%20O%3E">LowerHex</a></li><li><a href="#impl-Not-for-%26%27a%20mut%20BitSlice%3CT%2C%20O%3E">Not</a></li><li><a href="#impl-Octal-for-BitSlice%3CT%2C%20O%3E">Octal</a></li><li><a href="#impl-Ord-for-BitSlice%3CT%2C%20O%3E">Ord</a></li><li><a href="#impl-PartialEq%3C%26BitSlice%3CT2%2C%20O2%3E%3E-for-BitSlice%3CT1%2C%20O1%3E">PartialEq&lt;&amp;BitSlice&lt;T2, O2&gt;&gt;</a></li><li><a href="#impl-PartialEq%3C%26mut%20BitSlice%3CT2%2C%20O2%3E%3E-for-BitSlice%3CT1%2C%20O1%3E">PartialEq&lt;&amp;mut BitSlice&lt;T2, O2&gt;&gt;</a></li><li><a href="#impl-PartialEq%3CBitArray%3CA%2C%20O2%3E%3E-for-BitSlice%3CT%2C%20O1%3E">PartialEq&lt;BitArray&lt;A, O2&gt;&gt;</a></li><li><a href="#impl-PartialEq%3CBitBox%3CT2%2C%20O2%3E%3E-for-%26BitSlice%3CT1%2C%20O1%3E">PartialEq&lt;BitBox&lt;T2, O2&gt;&gt;</a></li><li><a href="#impl-PartialEq%3CBitBox%3CT2%2C%20O2%3E%3E-for-%26mut%20BitSlice%3CT1%2C%20O1%3E">PartialEq&lt;BitBox&lt;T2, O2&gt;&gt;</a></li><li><a href="#impl-PartialEq%3CBitBox%3CT2%2C%20O2%3E%3E-for-BitSlice%3CT1%2C%20O1%3E">PartialEq&lt;BitBox&lt;T2, O2&gt;&gt;</a></li><li><a href="#impl-PartialEq%3CBitSlice%3CT2%2C%20O2%3E%3E-for-%26BitSlice%3CT1%2C%20O1%3E">PartialEq&lt;BitSlice&lt;T2, O2&gt;&gt;</a></li><li><a href="#impl-PartialEq%3CBitSlice%3CT2%2C%20O2%3E%3E-for-%26mut%20BitSlice%3CT1%2C%20O1%3E">PartialEq&lt;BitSlice&lt;T2, O2&gt;&gt;</a></li><li><a href="#impl-PartialEq%3CBitSlice%3CT2%2C%20O2%3E%3E-for-BitSlice%3CT1%2C%20O1%3E">PartialEq&lt;BitSlice&lt;T2, O2&gt;&gt;</a></li><li><a href="#impl-PartialEq%3CBitVec%3CT2%2C%20O2%3E%3E-for-%26BitSlice%3CT1%2C%20O1%3E">PartialEq&lt;BitVec&lt;T2, O2&gt;&gt;</a></li><li><a href="#impl-PartialEq%3CBitVec%3CT2%2C%20O2%3E%3E-for-%26mut%20BitSlice%3CT1%2C%20O1%3E">PartialEq&lt;BitVec&lt;T2, O2&gt;&gt;</a></li><li><a href="#impl-PartialEq%3CBitVec%3CT2%2C%20O2%3E%3E-for-BitSlice%3CT1%2C%20O1%3E">PartialEq&lt;BitVec&lt;T2, O2&gt;&gt;</a></li><li><a href="#impl-PartialOrd%3C%26BitSlice%3CT2%2C%20O2%3E%3E-for-%26mut%20BitSlice%3CT1%2C%20O1%3E">PartialOrd&lt;&amp;BitSlice&lt;T2, O2&gt;&gt;</a></li><li><a href="#impl-PartialOrd%3C%26BitSlice%3CT2%2C%20O2%3E%3E-for-BitSlice%3CT1%2C%20O1%3E">PartialOrd&lt;&amp;BitSlice&lt;T2, O2&gt;&gt;</a></li><li><a href="#impl-PartialOrd%3C%26mut%20BitSlice%3CT2%2C%20O2%3E%3E-for-%26BitSlice%3CT1%2C%20O1%3E">PartialOrd&lt;&amp;mut BitSlice&lt;T2, O2&gt;&gt;</a></li><li><a href="#impl-PartialOrd%3C%26mut%20BitSlice%3CT2%2C%20O2%3E%3E-for-BitSlice%3CT1%2C%20O1%3E">PartialOrd&lt;&amp;mut BitSlice&lt;T2, O2&gt;&gt;</a></li><li><a href="#impl-PartialOrd%3CBitArray%3CA%2C%20O%3E%3E-for-BitSlice%3CT%2C%20O%3E">PartialOrd&lt;BitArray&lt;A, O&gt;&gt;</a></li><li><a href="#impl-PartialOrd%3CBitBox%3CT2%2C%20O2%3E%3E-for-%26%27a%20BitSlice%3CT1%2C%20O1%3E">PartialOrd&lt;BitBox&lt;T2, O2&gt;&gt;</a></li><li><a href="#impl-PartialOrd%3CBitBox%3CT2%2C%20O2%3E%3E-for-%26%27a%20mut%20BitSlice%3CT1%2C%20O1%3E">PartialOrd&lt;BitBox&lt;T2, O2&gt;&gt;</a></li><li><a href="#impl-PartialOrd%3CBitBox%3CT2%2C%20O2%3E%3E-for-BitSlice%3CT1%2C%20O1%3E">PartialOrd&lt;BitBox&lt;T2, O2&gt;&gt;</a></li><li><a href="#impl-PartialOrd%3CBitSlice%3CT2%2C%20O2%3E%3E-for-%26BitSlice%3CT1%2C%20O1%3E">PartialOrd&lt;BitSlice&lt;T2, O2&gt;&gt;</a></li><li><a href="#impl-PartialOrd%3CBitSlice%3CT2%2C%20O2%3E%3E-for-%26mut%20BitSlice%3CT1%2C%20O1%3E">PartialOrd&lt;BitSlice&lt;T2, O2&gt;&gt;</a></li><li><a href="#impl-PartialOrd%3CBitSlice%3CT2%2C%20O2%3E%3E-for-BitSlice%3CT1%2C%20O1%3E">PartialOrd&lt;BitSlice&lt;T2, O2&gt;&gt;</a></li><li><a href="#impl-PartialOrd%3CBitVec%3CT2%2C%20O2%3E%3E-for-%26%27a%20BitSlice%3CT1%2C%20O1%3E">PartialOrd&lt;BitVec&lt;T2, O2&gt;&gt;</a></li><li><a href="#impl-PartialOrd%3CBitVec%3CT2%2C%20O2%3E%3E-for-%26%27a%20mut%20BitSlice%3CT1%2C%20O1%3E">PartialOrd&lt;BitVec&lt;T2, O2&gt;&gt;</a></li><li><a href="#impl-PartialOrd%3CBitVec%3CT2%2C%20O2%3E%3E-for-BitSlice%3CT1%2C%20O1%3E">PartialOrd&lt;BitVec&lt;T2, O2&gt;&gt;</a></li><li><a href="#impl-Pointer-for-BitSlice%3CT%2C%20O%3E">Pointer</a></li><li><a href="#impl-Read-for-%26BitSlice%3CT%2C%20O%3E">Read</a></li><li><a href="#impl-Send-for-BitSlice%3CT%2C%20O%3E">Send</a></li><li><a href="#impl-Sync-for-BitSlice%3CT%2C%20O%3E">Sync</a></li><li><a href="#impl-ToOwned-for-BitSlice%3CT%2C%20O%3E">ToOwned</a></li><li><a href="#impl-TryFrom%3C%26%27a%20%5BT%5D%3E-for-%26%27a%20BitSlice%3CT%2C%20O%3E">TryFrom&lt;&amp;&#39;a [T]&gt;</a></li><li><a href="#impl-TryFrom%3C%26%27a%20mut%20%5BT%5D%3E-for-%26%27a%20mut%20BitSlice%3CT%2C%20O%3E">TryFrom&lt;&amp;&#39;a mut [T]&gt;</a></li><li><a href="#impl-TryFrom%3C%26BitSlice%3C%3CA%20as%20BitView%3E%3A%3AStore%2C%20O%3E%3E-for-%26BitArray%3CA%2C%20O%3E">TryFrom&lt;&amp;BitSlice&lt;&lt;A as BitView&gt;::Store, O&gt;&gt;</a></li><li><a href="#impl-TryFrom%3C%26BitSlice%3C%3CA%20as%20BitView%3E%3A%3AStore%2C%20O%3E%3E-for-BitArray%3CA%2C%20O%3E">TryFrom&lt;&amp;BitSlice&lt;&lt;A as BitView&gt;::Store, O&gt;&gt;</a></li><li><a href="#impl-TryFrom%3C%26mut%20BitSlice%3C%3CA%20as%20BitView%3E%3A%3AStore%2C%20O%3E%3E-for-%26mut%20BitArray%3CA%2C%20O%3E">TryFrom&lt;&amp;mut BitSlice&lt;&lt;A as BitView&gt;::Store, O&gt;&gt;</a></li><li><a href="#impl-Unpin-for-BitSlice%3CT%2C%20O%3E">Unpin</a></li><li><a href="#impl-UpperHex-for-BitSlice%3CT%2C%20O%3E">UpperHex</a></li><li><a href="#impl-Write-for-%26mut%20BitSlice%3CT%2C%20O%3E">Write</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block"><li><a href="#impl-RefUnwindSafe-for-BitSlice%3CT%2C%20O%3E">RefUnwindSafe</a></li><li><a href="#impl-Sized-for-BitSlice%3CT%2C%20O%3E">!Sized</a></li><li><a href="#impl-UnwindSafe-for-BitSlice%3CT%2C%20O%3E">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block"><li><a href="#impl-Any-for-BitSlice%3CT%2C%20O%3E">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-BitSlice%3CT%2C%20O%3E">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-BitSlice%3CT%2C%20O%3E">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-Conv-for-BitSlice%3CT%2C%20O%3E">Conv</a></li><li><a href="#impl-FmtForward-for-BitSlice%3CT%2C%20O%3E">FmtForward</a></li><li><a href="#impl-From%3CT%3E-for-BitSlice%3CT%2C%20O%3E">From&lt;T&gt;</a></li><li><a href="#impl-Into%3CU%3E-for-BitSlice%3CT%2C%20O%3E">Into&lt;U&gt;</a></li><li><a href="#impl-Pipe-for-BitSlice%3CT%2C%20O%3E">Pipe</a></li><li><a href="#impl-Tap-for-BitSlice%3CT%2C%20O%3E">Tap</a></li><li><a href="#impl-ToString-for-BitSlice%3CT%2C%20O%3E">ToString</a></li><li><a href="#impl-TryConv-for-BitSlice%3CT%2C%20O%3E">TryConv</a></li><li><a href="#impl-TryFrom%3CU%3E-for-BitSlice%3CT%2C%20O%3E">TryFrom&lt;U&gt;</a></li><li><a href="#impl-TryInto%3CU%3E-for-BitSlice%3CT%2C%20O%3E">TryInto&lt;U&gt;</a></li></ul></section><h2><a href="index.html">In bitvec::slice</a></h2></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../wheel.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1 class="fqn">Struct <a href="../index.html">bitvec</a>::<wbr><a href="index.html">slice</a>::<wbr><a class="struct" href="#">BitSlice</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../clipboard.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../../src/bitvec/slice.rs.html#60-86">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><div class="item-decl"><pre class="rust struct"><code><div class="code-attribute">#[repr(transparent)]</div>pub struct BitSlice&lt;T&nbsp;=&nbsp;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>, O&nbsp;=&nbsp;<a class="struct" href="../order/struct.Lsb0.html" title="struct bitvec::order::Lsb0">Lsb0</a>&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span>{ /* private fields */ }</code></pre></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="bit-addressable-memory"><a href="#bit-addressable-memory">Bit-Addressable Memory</a></h2>
<p>A slice of individual bits, anywhere in memory.</p>
<p><code>BitSlice&lt;T, O&gt;</code> is an unsized region type; you interact with it through
<code>&amp;BitSlice&lt;T, O&gt;</code> and <code>&amp;mut BitSlice&lt;T, O&gt;</code> references, which work exactly like
all other Rust references. As with the standard slice’s relationship to arrays
and vectors, this is <code>bitvec</code>’s primary working type, but you will probably
hold it through one of the provided <a href="../array/struct.BitArray.html"><code>BitArray</code></a>, <a href="../boxed/struct.BitBox.html"><code>BitBox</code></a>, or <a href="../vec/struct.BitVec.html"><code>BitVec</code></a>
containers.</p>
<p><code>BitSlice</code> is conceptually a <code>[bool]</code> slice, and provides a nearly complete
mirror of <code>[bool]</code>’s API.</p>
<p>Every bit-vector crate can give you an opaque type that hides shift/mask
calculations from you. <code>BitSlice</code> does far more than this: it offers you the
full Rust guarantees about reference behavior, including lifetime tracking,
mutability and aliasing awareness, and explicit memory control, <em>as well as</em> the
full set of tools and APIs available to the standard <code>[bool]</code> slice type.
<code>BitSlice</code> can arbitrarily split and subslice, just like <code>[bool]</code>. You can write
a linear consuming function and keep the patterns you already know.</p>
<p>For example, to trim all the bits off either edge that match a condition, you
could write</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">fn </span>trim&lt;T: BitStore, O: BitOrder&gt;(
  bits: <span class="kw-2">&amp;</span>BitSlice&lt;T, O&gt;,
  to_trim: bool,
) -&gt; <span class="kw-2">&amp;</span>BitSlice&lt;T, O&gt; {
  <span class="kw">let </span>stop = |b: bool| b != to_trim;
  <span class="kw">let </span>front = bits.iter()
    .by_vals()
    .position(stop)
    .unwrap_or(<span class="number">0</span>);
  <span class="kw">let </span>back = bits.iter()
    .by_vals()
    .rposition(stop)
    .map_or(<span class="number">0</span>, |p| p + <span class="number">1</span>);
  <span class="kw-2">&amp;</span>bits[front .. back]
}</code></pre></div>
<p>to get behavior something like
<code>trim(&amp;BitSlice[0, 0, 1, 1, 0, 1, 0], false) == &amp;BitSlice[1, 1, 0, 1]</code>.</p>
<h3 id="documentation"><a href="#documentation">Documentation</a></h3>
<p>All APIs that mirror something in the standard library will have an <code>Original</code>
section linking to the corresponding item. All APIs that have a different
signature or behavior than the original will have an <code>API Differences</code> section
explaining what has changed, and how to adapt your existing code to the change.</p>
<p>These sections look like this:</p>
<h3 id="original"><a href="#original">Original</a></h3>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html"><code>[bool]</code></a></p>
<h3 id="api-differences"><a href="#api-differences">API Differences</a></h3>
<p>The slice type <code>[bool]</code> has no type parameters. <code>BitSlice&lt;T, O&gt;</code> has two: one
for the integer type used as backing storage, and one for the order of bits
within that integer type.</p>
<p><code>&amp;BitSlice&lt;T, O&gt;</code> is capable of producing <code>&amp;bool</code> references to read bits out
of its memory, but is not capable of producing <code>&amp;mut bool</code> references to write
bits <em>into</em> its memory. Any <code>[bool]</code> API that would produce a <code>&amp;mut bool</code> will
instead produce a <a href="../ptr/struct.BitRef.html"><code>BitRef&lt;Mut, T, O&gt;</code></a> proxy reference.</p>
<h3 id="behavior"><a href="#behavior">Behavior</a></h3>
<p><code>BitSlice</code> is a wrapper over <code>[T]</code>. It describes a region of memory, and must be
handled indirectly. This is most commonly done through the reference types
<code>&amp;BitSlice</code> and <code>&amp;mut BitSlice</code>, which borrow memory owned by some other value
in the program. These buffers can be directly owned by the sibling types
<a href="../boxed/struct.BitBox.html"><code>BitBox</code></a>, which behaves like <a href="https://doc.rust-lang.org/1.66.1/alloc/boxed/struct.Box.html"><code>Box&lt;[T]&gt;</code></a>, and <a href="../vec/struct.BitVec.html"><code>BitVec</code></a>,
which behaves like <a href="https://doc.rust-lang.org/1.66.1/alloc/vec/struct.Vec.html"><code>Vec&lt;T&gt;</code></a>. It cannot be used as the type parameter to a
pointer type such as <code>Box</code>, <code>Rc</code>, <code>Arc</code>, or any other indirection.</p>
<p>The <code>BitSlice</code> region provides access to each individual bit in the region, as
if each bit had a memory address that you could use to dereference it. It packs
each logical bit into exactly one bit of storage memory, just like
<a href="https://en.cppreference.com/w/cpp/utility/bitset"><code>std::bitset</code></a> and <a href="https://en.cppreference.com/w/cpp/container/vector_bool"><code>std::vector&lt;bool&gt;</code></a> in C++.</p>
<h3 id="type-parameters"><a href="#type-parameters">Type Parameters</a></h3>
<p><code>BitSlice</code> has two type parameters which propagate through nearly every public
API in the crate. These are very important to its operation, and your choice
of type arguments informs nearly every part of this library’s behavior.</p>
<h4 id="t-bitstore"><a href="#t-bitstore"><code>T: BitStore</code></a></h4>
<p><a href="../store/trait.BitStore.html"><code>BitStore</code></a> is the simpler of the two parameters. It refers to the integer type
used to hold bits. It must be one of the Rust unsigned integer fundamentals:
<code>u8</code>, <code>u16</code>, <code>u32</code>, <code>usize</code>, and on 64-bit systems only, <code>u64</code>. In addition, it
can also be an alias-safe wrapper over them (see the <a href="../access/index.html"><code>access</code></a> module) in
order to permit bit-slices to share underlying memory without interfering with
each other.</p>
<p><code>BitSlice</code> references can only be constructed over the integers, not over their
aliasing wrappers. <code>BitSlice</code> will only use aliasing types in its <code>T</code> slots when
you invoke APIs that produce them, such as <a href="struct.BitSlice.html#method.split_at_mut"><code>.split_at_mut()</code></a>.</p>
<p>The default type argument is <code>usize</code>.</p>
<p>The argument you choose is used as the basis of a <code>[T]</code> slice, over which the
<code>BitSlice</code> view is produced. <code>BitSlice&lt;T, _&gt;</code> is subject to all of the rules
about alignment that <code>[T]</code> is. If you are working with in-memory representation
formats, chances are that you already have a <code>T</code> type with which you’ve been
working, and should use it here.</p>
<p>If you are only using this crate to discard the seven wasted bits per <code>bool</code>
in a collection of <code>bool</code>s, and are not too concerned about the in-memory
representation, then you should use the default type argument of <code>usize</code>. This
is because most processors work best when moving an entire <code>usize</code> between
memory and the processor itself, and using a smaller type may cause it to slow
down. Additionally, processor instructions are typically optimized for the whole
register, and the processor might need to do additional clearing work for
narrower types.</p>
<h4 id="o-bitorder"><a href="#o-bitorder"><code>O: BitOrder</code></a></h4>
<p><a href="../order/trait.BitOrder.html"><code>BitOrder</code></a> is the more complex parameter. It has a default argument which,
like <code>usize</code>, is a good baseline choice when you do not explicitly need to
control the representation of bits in memory.</p>
<p>This parameter determines how <code>bitvec</code> indexes the bits within a single <code>T</code>
memory element. Computers all agree that in a slice of <code>T</code> elements, the element
with the lower index has a lower memory address than the element with the higher
index. But the individual bits within an element do not have addresses, and so
there is no uniform standard of which bit is the zeroth, which is the first,
which is the penultimate, and which is the last.</p>
<p>To make matters even more confusing, there are two predominant ideas of
in-element ordering that often <em>correlate</em> with the in-element <em>byte</em> ordering
of integer types, but are in fact wholly unrelated! <code>bitvec</code> provides these two
main orderings as types for you, and if you need a different one, it also
provides the tools you need to write your own.</p>
<h5 id="least-significant-bit-comes-first"><a href="#least-significant-bit-comes-first">Least Significant Bit Comes First</a></h5>
<p>This ordering, named the <a href="../order/struct.Lsb0.html"><code>Lsb0</code></a> type, indexes bits within an element by
placing the <code>0</code> index at the least significant bit (numeric value <code>1</code>) and the
final index at the most significant bit (numeric value <a href="https://doc.rust-lang.org/stable/std/primitive.usize.html#associatedconstant.MIN"><code>T::MIN</code></a> for
signed integers on most machines).</p>
<p>For example, this is the ordering used by most C compilers to lay out bit-field
struct members on little-endian <strong>byte</strong>-ordered machines.</p>
<h5 id="most-significant-bit-comes-first"><a href="#most-significant-bit-comes-first">Most Significant Bit Comes First</a></h5>
<p>This ordering, named the <a href="../order/struct.Msb0.html"><code>Msb0</code></a> type, indexes bits within an element by
placing the <code>0</code> index at the most significant bit (numeric value
<a href="https://doc.rust-lang.org/stable/std/primitive.usize.html#associatedconstant.MIN"><code>T::MIN</code></a> for most signed integers) and the final index at the least
significant bit (numeric value <code>1</code>).</p>
<p>For example, this is the ordering used by the <a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol#TCP_segment_structure">TCP wire format</a>, and by
most C compilers to lay out bit-field struct members on big-endian
<strong>byte</strong>-ordered machines.</p>
<h5 id="default-ordering"><a href="#default-ordering">Default Ordering</a></h5>
<p>The default ordering is <a href="../order/struct.Lsb0.html"><code>Lsb0</code></a>, as it typically produces shorter object code
than <a href="../order/struct.Msb0.html"><code>Msb0</code></a> does. If you are implementing a collection, then <code>Lsb0</code> will
likely give you better performance; if you are implementing a buffer protocol,
then your choice of ordering is dictated by the protocol definition.</p>
<h3 id="safety"><a href="#safety">Safety</a></h3>
<p><code>BitSlice</code> is designed to never introduce new memory unsafety that you did not
provide yourself, either before or during the use of this crate. However, safety
bugs have been identified before, and you are welcome to submit any discovered
flaws as a defect report.</p>
<p>The <code>&amp;BitSlice</code> reference type uses a private encoding scheme to hold all of the
information needed in its stack value. This encoding is <strong>not</strong> part of the
public API of the library, and is not binary-compatible with <code>&amp;[T]</code>.
Furthermore, in order to satisfy Rust’s requirements about alias conditions,
<code>BitSlice</code> performs type transformations on the <code>T</code> parameter to ensure that it
never creates the potential for undefined behavior or data races.</p>
<p>You must never attempt to type-cast a reference to <code>BitSlice</code> in any way. You
must not use <a href="https://doc.rust-lang.org/1.66.1/core/intrinsics/fn.transmute.html"><code>mem::transmute</code></a> with <code>BitSlice</code> anywhere in its type arguments.
You must not use <code>as</code>-casting to convert between <code>*BitSlice</code> and any other type.
You must not attempt to modify the binary representation of a <code>&amp;BitSlice</code>
reference value. These actions will all lead to runtime memory unsafety, are
(hopefully) likely to induce a program crash, and may possibly cause undefined
behavior at compile-time.</p>
<p>Everything in the <code>BitSlice</code> public API, even the <code>unsafe</code> parts, are guaranteed
to have no more unsafety than their equivalent items in the standard library.
All <code>unsafe</code> APIs will have documentation explicitly detailing what the API
requires you to uphold in order for it to function safely and correctly. All
safe APIs will do so themselves.</p>
<h3 id="performance"><a href="#performance">Performance</a></h3>
<p>Like the standard library’s <code>[T]</code> slice, <code>BitSlice</code> is designed to be very easy
to use safely, while supporting <code>unsafe</code> usage when necessary. Rust has a
powerful optimizing engine, and <code>BitSlice</code> will frequently be compiled to have
zero runtime cost. Where it is slower, it will not be significantly slower than
a manual replacement.</p>
<p>As the machine instructions operate on registers rather than bits, your choice
of <a href="../store/trait.BitStore.html"><code>T: BitStore</code></a> type parameter can influence your bits-slice’s performance.
Using larger register types means that bit-slices can gallop over
completely-used interior elements faster, while narrower register types permit
more graceful handling of subslicing and aliased splits.</p>
<h3 id="construction"><a href="#construction">Construction</a></h3>
<p><code>BitSlice</code> views of memory can be constructed over borrowed data in a number of
ways. As this is a reference-only type, it can only ever be built by borrowing
an existing memory buffer and taking temporary control of your program’s view of
the region.</p>
<h4 id="macro-constructor"><a href="#macro-constructor">Macro Constructor</a></h4>
<p><code>BitSlice</code> buffers can be constructed at compile-time through the <a href="../macro.bits.html"><code>bits!</code></a>
macro. This macro accepts a superset of the <a href="https://doc.rust-lang.org/1.66.1/alloc/macro.vec.html"><code>vec!</code></a> arguments, and creates an
appropriate buffer in the local scope. The macro expands to a borrowed
<a href="../array/struct.BitArray.html"><code>BitArray</code></a> temporary, which will live for the duration of the bound name.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>immut = <span class="macro">bits!</span>[u8, Lsb0; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let </span>mutable: <span class="kw-2">&amp;mut </span>BitSlice&lt;<span class="kw">_</span>, <span class="kw">_</span>&gt; = <span class="macro">bits!</span>[<span class="kw-2">mut </span>u8, Msb0; <span class="number">0</span>; <span class="number">8</span>];

<span class="macro">assert_ne!</span>(immut, mutable);
mutable.clone_from_bitslice(immut);
<span class="macro">assert_eq!</span>(immut, mutable);</code></pre></div>
<h4 id="borrowing-constructors"><a href="#borrowing-constructors">Borrowing Constructors</a></h4>
<p>You may borrow existing elements or slices with the following functions:</p>
<ul>
<li><a href="struct.BitSlice.html#method.from_element"><code>from_element</code></a> and <a href="struct.BitSlice.html#method.from_element_mut"><code>from_element_mut</code></a>,</li>
<li><a href="struct.BitSlice.html#method.from_slice"><code>from_slice</code></a> and <a href="struct.BitSlice.html#method.from_slice_mut"><code>from_slice_mut</code></a>,</li>
<li><a href="struct.BitSlice.html#method.try_from_slice"><code>try_from_slice</code></a> and <a href="struct.BitSlice.html#method.try_from_slice_mut"><code>try_from_slice_mut</code></a></li>
</ul>
<p>These take references to existing memory and construct <code>BitSlice</code> references
from them. These are the most basic ways to borrow memory and view it as bits;
however, you should prefer the <a href="../view/trait.BitView.html"><code>BitView</code></a> trait methods instead.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>data = [<span class="number">0u16</span>; <span class="number">3</span>];
<span class="kw">let </span>local_borrow = BitSlice::&lt;<span class="kw">_</span>, Lsb0&gt;::from_slice(<span class="kw-2">&amp;</span>data);

<span class="kw">let </span><span class="kw-2">mut </span>data = [<span class="number">0u8</span>; <span class="number">5</span>];
<span class="kw">let </span>local_mut = BitSlice::&lt;<span class="kw">_</span>, Lsb0&gt;::from_slice_mut(<span class="kw-2">&amp;mut </span>data);</code></pre></div>
<h4 id="trait-method-constructors"><a href="#trait-method-constructors">Trait Method Constructors</a></h4>
<p>The <a href="../view/trait.BitView.html"><code>BitView</code></a> trait implements <a href="../view/trait.BitView.html#tymethod.view_bits"><code>.view_bits::&lt;O&gt;()</code></a> and
<a href="../view/trait.BitView.html#tymethod.view_bits_mut"><code>.view_bits_mut::&lt;O&gt;()</code></a> methods on elements, arrays, and slices. This trait,
imported in the crate prelude, is <em>probably</em> the easiest way for you to borrow
memory as bits.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>data = [<span class="number">0u32</span>; <span class="number">5</span>];
<span class="kw">let </span>trait_view = data.view_bits::&lt;Lsb0&gt;();

<span class="kw">let </span><span class="kw-2">mut </span>data = <span class="number">0usize</span>;
<span class="kw">let </span>trait_mut = data.view_bits_mut::&lt;Msb0&gt;();</code></pre></div>
<h4 id="owned-bit-slices"><a href="#owned-bit-slices">Owned Bit Slices</a></h4>
<p>If you wish to take ownership of a memory region and enforce that it is always
viewed as a <code>BitSlice</code> by default, you can use one of the <a href="../array/struct.BitArray.html"><code>BitArray</code></a>,
<a href="../boxed/struct.BitBox.html"><code>BitBox</code></a>, or <a href="../vec/struct.BitVec.html"><code>BitVec</code></a> types, rather than pairing ordinary buffer types with
the borrowing constructors.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>slice = <span class="macro">bits!</span>[<span class="number">0</span>; <span class="number">27</span>];
<span class="kw">let </span>array = <span class="macro">bitarr!</span>[u8, LocalBits; <span class="number">0</span>; <span class="number">10</span>];
<span class="kw">let </span>boxed = <span class="macro">bitbox!</span>[<span class="number">0</span>; <span class="number">10</span>];
<span class="kw">let </span>vec = <span class="macro">bitvec!</span>[<span class="number">0</span>; <span class="number">20</span>];

<span class="comment">// arrays always round up
</span><span class="macro">assert_eq!</span>(array.as_bitslice(), slice[.. <span class="number">16</span>]);
<span class="macro">assert_eq!</span>(boxed.as_bitslice(), slice[.. <span class="number">10</span>]);
<span class="macro">assert_eq!</span>(vec.as_bitslice(), slice[.. <span class="number">20</span>]);</code></pre></div>
<h3 id="usage"><a href="#usage">Usage</a></h3>
<p><code>BitSlice</code> implements the full standard-library <code>[bool]</code> API. The documentation
for these API surfaces is intentionally sparse, and forwards to the standard
library rather than try to replicate it.</p>
<p><code>BitSlice</code> also has a great deal of novel API surfaces. These are broken into
separate <code>impl</code> blocks below. A short summary:</p>
<ul>
<li>Since there is no <code>BitSlice</code> literal, the constructor functions <code>::empty()</code>,
<code>::from_element()</code>, <code>::from_slice()</code>, and <code>::try_from_slice()</code>, and their
<code>_mut</code> counterparts, create bit-slices as needed.</li>
<li>Since <code>bits[idx] = value</code> does not exist, you can use <code>.set()</code> or <code>.replace()</code>
(as well as their <code>_unchecked</code> and <code>_aliased</code> counterparts) to write into a
bit-slice.</li>
<li>Raw memory can be inspected with <code>.domain()</code> and <code>.domain_mut()</code>, and a
bit-slice can be split on aliasing lines with <code>.bit_domain()</code> and
<code>.bit_domain_mut()</code>.</li>
<li>The population can be queried for which indices have <code>0</code> or <code>1</code> bits by
iterating across all such indices, counting them, or counting leading or
trailing blocks. Additionally, <code>.any()</code>, <code>.all()</code>, <code>.not_any()</code>, <code>.not_all()</code>,
and <code>.some()</code> test whether bit-slices satisfy aggregate Boolean qualities.</li>
<li>Buffer contents can be relocated internally by shifting or rotating to the
left or right.</li>
</ul>
<h3 id="trait-implementations-1"><a href="#trait-implementations-1">Trait Implementations</a></h3>
<p><code>BitSlice</code> adds trait implementations that <code>[bool]</code> and <code>[T]</code> do not necessarily
have, including numeric formatting and Boolean arithmetic operators.
Additionally, the <a href="../field/trait.BitField.html"><code>BitField</code></a> trait allows bit-slices to act as a buffer for
wide-value storage.</p>
</div></details><h2 id="implementations" class="small-section-header">Implementations<a href="#implementations" class="anchor"></a></h2><div id="implementations-list"><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BitSlice%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#67-2357">source</a><a href="#impl-BitSlice%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="docblock"><p>Port of the <code>[T]</code> inherent API.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.len" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#87-89">source</a><h4 class="code-header">pub fn <a href="#method.len" class="fnname">len</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Gets the number of bits in the bit-slice.</p>
<h6 id="original-1"><a href="#original-1">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.len"><code>slice::len</code></a></p>
<h6 id="examples"><a href="#examples">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[].len(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">0</span>; <span class="number">10</span>].len(), <span class="number">10</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.is_empty" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#106-108">source</a><h4 class="code-header">pub fn <a href="#method.is_empty" class="fnname">is_empty</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Tests if the bit-slice is empty (length zero).</p>
<h6 id="original-2"><a href="#original-2">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.is_empty"><code>slice::is_empty</code></a></p>
<h6 id="examples-1"><a href="#examples-1">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="macro">assert!</span>(<span class="macro">bits!</span>[].is_empty());
<span class="macro">assert!</span>(!<span class="macro">bits!</span>[<span class="number">0</span>; <span class="number">10</span>].is_empty());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.first" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#133-135">source</a><h4 class="code-header">pub fn <a href="#method.first" class="fnname">first</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.66.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../ptr/struct.BitRef.html" title="struct bitvec::ptr::BitRef">BitRef</a>&lt;'_, <a class="struct" href="../ptr/struct.Const.html" title="struct bitvec::ptr::Const">Const</a>, T, O&gt;&gt;</h4></section></summary><div class="docblock"><p>Gets a reference to the first bit of the bit-slice, or <code>None</code> if it is
empty.</p>
<h6 id="original-3"><a href="#original-3">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.first"><code>slice::first</code></a></p>
<h6 id="api-differences-1"><a href="#api-differences-1">API Differences</a></h6>
<p><code>bitvec</code> uses a custom structure for both read-only and mutable
references to <code>bool</code>.</p>
<h6 id="examples-2"><a href="#examples-2">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="macro">assert_eq!</span>(bits.first().as_deref(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="bool-val">true</span>));

<span class="macro">assert!</span>(<span class="macro">bits!</span>[].first().is_none());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.first_mut" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#164-166">source</a><h4 class="code-header">pub fn <a href="#method.first_mut" class="fnname">first_mut</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.66.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../ptr/struct.BitRef.html" title="struct bitvec::ptr::BitRef">BitRef</a>&lt;'_, <a class="struct" href="../ptr/struct.Mut.html" title="struct bitvec::ptr::Mut">Mut</a>, T, O&gt;&gt;</h4></section></summary><div class="docblock"><p>Gets a mutable reference to the first bit of the bit-slice, or <code>None</code> if
it is empty.</p>
<h6 id="original-4"><a href="#original-4">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.first_mut"><code>slice::first_mut</code></a></p>
<h6 id="api-differences-2"><a href="#api-differences-2">API Differences</a></h6>
<p><code>bitvec</code> uses a custom structure for both read-only and mutable
references to <code>bool</code>. This must be bound as <code>mut</code> in order to write
through it.</p>
<h6 id="examples-3"><a href="#examples-3">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>; <span class="number">3</span>];
<span class="kw">if let </span><span class="prelude-val">Some</span>(<span class="kw-2">mut </span>first) = bits.first_mut() {
  <span class="kw-2">*</span>first = <span class="bool-val">true</span>;
}
<span class="macro">assert_eq!</span>(bits, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]);

<span class="macro">assert!</span>(<span class="macro">bits!</span>[<span class="kw-2">mut</span>].first_mut().is_none());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.split_first" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#191-199">source</a><h4 class="code-header">pub fn <a href="#method.split_first" class="fnname">split_first</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.66.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;(<a class="struct" href="../ptr/struct.BitRef.html" title="struct bitvec::ptr::BitRef">BitRef</a>&lt;'_, <a class="struct" href="../ptr/struct.Const.html" title="struct bitvec::ptr::Const">Const</a>, T, O&gt;, <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Self)&gt;</h4></section></summary><div class="docblock"><p>Splits the bit-slice into a reference to its first bit, and the rest of
the bit-slice. Returns <code>None</code> when empty.</p>
<h6 id="original-5"><a href="#original-5">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.split_first"><code>slice::split_first</code></a></p>
<h6 id="api-differences-3"><a href="#api-differences-3">API Differences</a></h6>
<p><code>bitvec</code> uses a custom structure for both read-only and mutable
references to <code>bool</code>.</p>
<h6 id="examples-4"><a href="#examples-4">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="kw">let </span>(first, rest) = bits.split_first().unwrap();
<span class="macro">assert_eq!</span>(first, <span class="kw-2">&amp;</span><span class="bool-val">true</span>);
<span class="macro">assert_eq!</span>(rest, <span class="macro">bits!</span>[<span class="number">0</span>; <span class="number">2</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.split_first_mut" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#227-237">source</a><h4 class="code-header">pub fn <a href="#method.split_first_mut" class="fnname">split_first_mut</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self<br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.66.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;(<a class="struct" href="../ptr/struct.BitRef.html" title="struct bitvec::ptr::BitRef">BitRef</a>&lt;'_, <a class="struct" href="../ptr/struct.Mut.html" title="struct bitvec::ptr::Mut">Mut</a>, T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>, O&gt;, &amp;mut <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>, O&gt;)&gt;</h4></section></summary><div class="docblock"><p>Splits the bit-slice into mutable references of its first bit, and the
rest of the bit-slice. Returns <code>None</code> when empty.</p>
<h6 id="original-6"><a href="#original-6">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.split_first_mut"><code>slice::split_first_mut</code></a></p>
<h6 id="api-differences-4"><a href="#api-differences-4">API Differences</a></h6>
<p><code>bitvec</code> uses a custom structure for both read-only and mutable
references to <code>bool</code>. This must be bound as <code>mut</code> in order to write
through it.</p>
<h6 id="examples-5"><a href="#examples-5">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>; <span class="number">3</span>];
<span class="kw">if let </span><span class="prelude-val">Some</span>((<span class="kw-2">mut </span>first, rest)) = bits.split_first_mut() {
  <span class="kw-2">*</span>first = <span class="bool-val">true</span>;
  <span class="macro">assert_eq!</span>(rest, <span class="macro">bits!</span>[<span class="number">0</span>; <span class="number">2</span>]);
}
<span class="macro">assert_eq!</span>(bits, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.split_last" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#262-270">source</a><h4 class="code-header">pub fn <a href="#method.split_last" class="fnname">split_last</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.66.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;(<a class="struct" href="../ptr/struct.BitRef.html" title="struct bitvec::ptr::BitRef">BitRef</a>&lt;'_, <a class="struct" href="../ptr/struct.Const.html" title="struct bitvec::ptr::Const">Const</a>, T, O&gt;, <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Self)&gt;</h4></section></summary><div class="docblock"><p>Splits the bit-slice into a reference to its last bit, and the rest of
the bit-slice. Returns <code>None</code> when empty.</p>
<h6 id="original-7"><a href="#original-7">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.split_last"><code>slice::split_last</code></a></p>
<h6 id="api-differences-5"><a href="#api-differences-5">API Differences</a></h6>
<p><code>bitvec</code> uses a custom structure for both read-only and mutable
references to <code>bool</code>.</p>
<h6 id="examples-6"><a href="#examples-6">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let </span>(last, rest) = bits.split_last().unwrap();
<span class="macro">assert_eq!</span>(last, <span class="kw-2">&amp;</span><span class="bool-val">true</span>);
<span class="macro">assert_eq!</span>(rest, <span class="macro">bits!</span>[<span class="number">0</span>; <span class="number">2</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.split_last_mut" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#298-308">source</a><h4 class="code-header">pub fn <a href="#method.split_last_mut" class="fnname">split_last_mut</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self<br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.66.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;(<a class="struct" href="../ptr/struct.BitRef.html" title="struct bitvec::ptr::BitRef">BitRef</a>&lt;'_, <a class="struct" href="../ptr/struct.Mut.html" title="struct bitvec::ptr::Mut">Mut</a>, T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>, O&gt;, &amp;mut <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>, O&gt;)&gt;</h4></section></summary><div class="docblock"><p>Splits the bit-slice into mutable references to its last bit, and the
rest of the bit-slice. Returns <code>None</code> when empty.</p>
<h6 id="original-8"><a href="#original-8">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.split_last_mut"><code>slice::split_last_mut</code></a></p>
<h6 id="api-differences-6"><a href="#api-differences-6">API Differences</a></h6>
<p><code>bitvec</code> uses a custom structure for both read-only and mutable
references to <code>bool</code>. This must be bound as <code>mut</code> in order to write
through it.</p>
<h6 id="examples-7"><a href="#examples-7">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>; <span class="number">3</span>];
<span class="kw">if let </span><span class="prelude-val">Some</span>((<span class="kw-2">mut </span>last, rest)) = bits.split_last_mut() {
  <span class="kw-2">*</span>last = <span class="bool-val">true</span>;
  <span class="macro">assert_eq!</span>(rest, <span class="macro">bits!</span>[<span class="number">0</span>; <span class="number">2</span>]);
}
<span class="macro">assert_eq!</span>(bits, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.last" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#333-338">source</a><h4 class="code-header">pub fn <a href="#method.last" class="fnname">last</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.66.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../ptr/struct.BitRef.html" title="struct bitvec::ptr::BitRef">BitRef</a>&lt;'_, <a class="struct" href="../ptr/struct.Const.html" title="struct bitvec::ptr::Const">Const</a>, T, O&gt;&gt;</h4></section></summary><div class="docblock"><p>Gets a reference to the last bit of the bit-slice, or <code>None</code> if it is
empty.</p>
<h6 id="original-9"><a href="#original-9">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.last"><code>slice::last</code></a></p>
<h6 id="api-differences-7"><a href="#api-differences-7">API Differences</a></h6>
<p><code>bitvec</code> uses a custom structure for both read-only and mutable
references to <code>bool</code>.</p>
<h6 id="examples-8"><a href="#examples-8">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="macro">assert_eq!</span>(bits.last().as_deref(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="bool-val">true</span>));

<span class="macro">assert!</span>(<span class="macro">bits!</span>[].last().is_none());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.last_mut" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#367-372">source</a><h4 class="code-header">pub fn <a href="#method.last_mut" class="fnname">last_mut</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.66.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../ptr/struct.BitRef.html" title="struct bitvec::ptr::BitRef">BitRef</a>&lt;'_, <a class="struct" href="../ptr/struct.Mut.html" title="struct bitvec::ptr::Mut">Mut</a>, T, O&gt;&gt;</h4></section></summary><div class="docblock"><p>Gets a mutable reference to the last bit of the bit-slice, or <code>None</code> if
it is empty.</p>
<h6 id="original-10"><a href="#original-10">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.last_mut"><code>slice::last_mut</code></a></p>
<h6 id="api-differences-8"><a href="#api-differences-8">API Differences</a></h6>
<p><code>bitvec</code> uses a custom structure for both read-only and mutable
references to <code>bool</code>. This must be bound as <code>mut</code> in order to write
through it.</p>
<h6 id="examples-9"><a href="#examples-9">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>; <span class="number">3</span>];
<span class="kw">if let </span><span class="prelude-val">Some</span>(<span class="kw-2">mut </span>last) = bits.last_mut() {
  <span class="kw-2">*</span>last = <span class="bool-val">true</span>;
}
<span class="macro">assert_eq!</span>(bits, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]);

<span class="macro">assert!</span>(<span class="macro">bits!</span>[<span class="kw-2">mut</span>].last_mut().is_none());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.get" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#404-407">source</a><h4 class="code-header">pub fn <a href="#method.get" class="fnname">get</a>&lt;'a, I&gt;(&amp;'a self, index: I) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.66.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;I::<a class="associatedtype" href="trait.BitSliceIndex.html#associatedtype.Immut" title="type bitvec::slice::BitSliceIndex::Immut">Immut</a>&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="trait.BitSliceIndex.html" title="trait bitvec::slice::BitSliceIndex">BitSliceIndex</a>&lt;'a, T, O&gt;,</span></h4></section></summary><div class="docblock"><p>Gets a reference to a single bit or a subsection of the bit-slice,
depending on the type of <code>index</code>.</p>
<ul>
<li>If given a <code>usize</code>, this produces a reference structure to the <code>bool</code>
at the position.</li>
<li>If given any form of range, this produces a smaller bit-slice.</li>
</ul>
<p>This returns <code>None</code> if the <code>index</code> departs the bounds of <code>self</code>.</p>
<h6 id="original-11"><a href="#original-11">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.get"><code>slice::get</code></a></p>
<h6 id="api-differences-9"><a href="#api-differences-9">API Differences</a></h6>
<p><code>BitSliceIndex</code> uses discrete types for immutable and mutable
references, rather than a single referent type.</p>
<h6 id="examples-10"><a href="#examples-10">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="macro">assert_eq!</span>(bits.get(<span class="number">1</span>).as_deref(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="bool-val">true</span>));
<span class="macro">assert_eq!</span>(bits.get(<span class="number">0 </span>.. <span class="number">2</span>), <span class="prelude-val">Some</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>]));
<span class="macro">assert!</span>(bits.get(<span class="number">3</span>).is_none());
<span class="macro">assert!</span>(bits.get(<span class="number">0 </span>.. <span class="number">4</span>).is_none());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.get_mut" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#439-442">source</a><h4 class="code-header">pub fn <a href="#method.get_mut" class="fnname">get_mut</a>&lt;'a, I&gt;(&amp;'a mut self, index: I) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.66.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;I::<a class="associatedtype" href="trait.BitSliceIndex.html#associatedtype.Mut" title="type bitvec::slice::BitSliceIndex::Mut">Mut</a>&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="trait.BitSliceIndex.html" title="trait bitvec::slice::BitSliceIndex">BitSliceIndex</a>&lt;'a, T, O&gt;,</span></h4></section></summary><div class="docblock"><p>Gets a mutable reference to a single bit or a subsection of the
bit-slice, depending on the type of <code>index</code>.</p>
<ul>
<li>If given a <code>usize</code>, this produces a reference structure to the <code>bool</code>
at the position.</li>
<li>If given any form of range, this produces a smaller bit-slice.</li>
</ul>
<p>This returns <code>None</code> if the <code>index</code> departs the bounds of <code>self</code>.</p>
<h6 id="original-12"><a href="#original-12">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.get_mut"><code>slice::get_mut</code></a></p>
<h6 id="api-differences-10"><a href="#api-differences-10">API Differences</a></h6>
<p><code>BitSliceIndex</code> uses discrete types for immutable and mutable
references, rather than a single referent type.</p>
<h6 id="examples-11"><a href="#examples-11">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>; <span class="number">3</span>];

<span class="kw-2">*</span>bits.get_mut(<span class="number">0</span>).unwrap() = <span class="bool-val">true</span>;
bits.get_mut(<span class="number">1 </span>..).unwrap().fill(<span class="bool-val">true</span>);
<span class="macro">assert_eq!</span>(bits, <span class="macro">bits!</span>[<span class="number">1</span>; <span class="number">3</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.get_unchecked" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#480-483">source</a><h4 class="code-header">pub unsafe fn <a href="#method.get_unchecked" class="fnname">get_unchecked</a>&lt;'a, I&gt;(&amp;'a self, index: I) -&gt; I::<a class="associatedtype" href="trait.BitSliceIndex.html#associatedtype.Immut" title="type bitvec::slice::BitSliceIndex::Immut">Immut</a><span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="trait.BitSliceIndex.html" title="trait bitvec::slice::BitSliceIndex">BitSliceIndex</a>&lt;'a, T, O&gt;,</span></h4></section></summary><div class="docblock"><p>Gets a reference to a single bit or to a subsection of the bit-slice,
without bounds checking.</p>
<p>This has the same arguments and behavior as <a href="struct.BitSlice.html#method.get"><code>.get()</code></a>, except that it
does not check that <code>index</code> is in bounds.</p>
<h6 id="original-13"><a href="#original-13">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.get_unchecked"><code>slice::get_unchecked</code></a></p>
<h6 id="safety-1"><a href="#safety-1">Safety</a></h6>
<p>You must ensure that <code>index</code> is within bounds (within the range <code>0 .. self.len()</code>), or this method will introduce memory safety and/or
undefined behavior.</p>
<p>It is library-level undefined behavior to index beyond the length of any
bit-slice, even if you <strong>know</strong> that the offset remains within an
allocation as measured by Rust or LLVM.</p>
<h6 id="examples-12"><a href="#examples-12">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>data = <span class="number">0b0001_0010u8</span>;
<span class="kw">let </span>bits = <span class="kw-2">&amp;</span>data.view_bits::&lt;Lsb0&gt;()[.. <span class="number">3</span>];

<span class="kw">unsafe </span>{
  <span class="macro">assert!</span>(bits.get_unchecked(<span class="number">1</span>));
  <span class="macro">assert!</span>(bits.get_unchecked(<span class="number">4</span>));
}</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.get_unchecked_mut" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#522-525">source</a><h4 class="code-header">pub unsafe fn <a href="#method.get_unchecked_mut" class="fnname">get_unchecked_mut</a>&lt;'a, I&gt;(&amp;'a mut self, index: I) -&gt; I::<a class="associatedtype" href="trait.BitSliceIndex.html#associatedtype.Mut" title="type bitvec::slice::BitSliceIndex::Mut">Mut</a><span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="trait.BitSliceIndex.html" title="trait bitvec::slice::BitSliceIndex">BitSliceIndex</a>&lt;'a, T, O&gt;,</span></h4></section></summary><div class="docblock"><p>Gets a mutable reference to a single bit or a subsection of the
bit-slice, depending on the type of <code>index</code>.</p>
<p>This has the same arguments and behavior as <a href="struct.BitSlice.html#method.get_mut"><code>.get_mut()</code></a>, except that
it does not check that <code>index</code> is in bounds.</p>
<h6 id="original-14"><a href="#original-14">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.get_unchecked_mut"><code>slice::get_unchecked_mut</code></a></p>
<h6 id="safety-2"><a href="#safety-2">Safety</a></h6>
<p>You must ensure that <code>index</code> is within bounds (within the range <code>0 .. self.len()</code>), or this method will introduce memory safety and/or
undefined behavior.</p>
<p>It is library-level undefined behavior to index beyond the length of any
bit-slice, even if you <strong>know</strong> that the offset remains within an
allocation as measured by Rust or LLVM.</p>
<h6 id="examples-13"><a href="#examples-13">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>data = <span class="number">0u8</span>;
<span class="kw">let </span>bits = <span class="kw-2">&amp;mut </span>data.view_bits_mut::&lt;Lsb0&gt;()[.. <span class="number">3</span>];

<span class="kw">unsafe </span>{
  bits.get_unchecked_mut(<span class="number">1</span>).commit(<span class="bool-val">true</span>);
  bits.get_unchecked_mut(<span class="number">4 </span>.. <span class="number">6</span>).fill(<span class="bool-val">true</span>);
}
<span class="macro">assert_eq!</span>(data, <span class="number">0b0011_0010</span>);</code></pre></div>
</div></details><section id="method.as_ptr" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#531-533">source</a><h4 class="code-header">pub fn <a href="#method.as_ptr" class="fnname">as_ptr</a>(&amp;self) -&gt; <a class="struct" href="../ptr/struct.BitPtr.html" title="struct bitvec::ptr::BitPtr">BitPtr</a>&lt;<a class="struct" href="../ptr/struct.Const.html" title="struct bitvec::ptr::Const">Const</a>, T, O&gt;</h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated: use <code>.as_bitptr()</code> instead</span></div></span><section id="method.as_mut_ptr" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#539-541">source</a><h4 class="code-header">pub fn <a href="#method.as_mut_ptr" class="fnname">as_mut_ptr</a>(&amp;mut self) -&gt; <a class="struct" href="../ptr/struct.BitPtr.html" title="struct bitvec::ptr::BitPtr">BitPtr</a>&lt;<a class="struct" href="../ptr/struct.Mut.html" title="struct bitvec::ptr::Mut">Mut</a>, T, O&gt;</h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated: use <code>.as_mut_bitptr()</code> instead</span></div></span><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_ptr_range" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#557-559">source</a><h4 class="code-header">pub fn <a href="#method.as_ptr_range" class="fnname">as_ptr_range</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.66.1/core/ops/range/struct.Range.html" title="struct core::ops::range::Range">Range</a>&lt;<a class="struct" href="../ptr/struct.BitPtr.html" title="struct bitvec::ptr::BitPtr">BitPtr</a>&lt;<a class="struct" href="../ptr/struct.Const.html" title="struct bitvec::ptr::Const">Const</a>, T, O&gt;&gt;</h4></section></summary><div class="docblock"><p>Produces a range of bit-pointers to each bit in the bit-slice.</p>
<p>This is a standard-library range, which has no real functionality for
pointer types. You should prefer <a href="struct.BitSlice.html#method.as_bitptr_range"><code>.as_bitptr_range()</code></a> instead, as it
produces a custom structure that provides expected ranging
functionality.</p>
<h6 id="original-15"><a href="#original-15">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.as_ptr_range"><code>slice::as_ptr_range</code></a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_mut_ptr_range" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#575-577">source</a><h4 class="code-header">pub fn <a href="#method.as_mut_ptr_range" class="fnname">as_mut_ptr_range</a>(&amp;mut self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.66.1/core/ops/range/struct.Range.html" title="struct core::ops::range::Range">Range</a>&lt;<a class="struct" href="../ptr/struct.BitPtr.html" title="struct bitvec::ptr::BitPtr">BitPtr</a>&lt;<a class="struct" href="../ptr/struct.Mut.html" title="struct bitvec::ptr::Mut">Mut</a>, T, O&gt;&gt;</h4></section></summary><div class="docblock"><p>Produces a range of mutable bit-pointers to each bit in the bit-slice.</p>
<p>This is a standard-library range, which has no real functionality for
pointer types. You should prefer <a href="struct.BitSlice.html#method.as_mut_bitptr_range"><code>.as_mut_bitptr_range()</code></a> instead, as
it produces a custom structure that provides expected ranging
functionality.</p>
<h6 id="original-16"><a href="#original-16">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.as_mut_ptr_range"><code>slice::as_mut_ptr_range</code></a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.swap" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#599-606">source</a><h4 class="code-header">pub fn <a href="#method.swap" class="fnname">swap</a>(&amp;mut self, a: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>, b: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Exchanges the bit values at two indices.</p>
<h6 id="original-17"><a href="#original-17">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.swap"><code>slice::swap</code></a></p>
<h6 id="panics"><a href="#panics">Panics</a></h6>
<p>This panics if either <code>a</code> or <code>b</code> are out of bounds.</p>
<h6 id="examples-14"><a href="#examples-14">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>, <span class="number">1</span>];
bits.swap(<span class="number">0</span>, <span class="number">1</span>);
<span class="macro">assert_eq!</span>(bits, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.reverse" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#624-631">source</a><h4 class="code-header">pub fn <a href="#method.reverse" class="fnname">reverse</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Reverses the order of bits in a bit-slice.</p>
<h6 id="original-18"><a href="#original-18">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.reverse"><code>slice::reverse</code></a></p>
<h6 id="examples-15"><a href="#examples-15">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
bits.reverse();
<span class="macro">assert_eq!</span>(bits, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.iter" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#666-668">source</a><h4 class="code-header">pub fn <a href="#method.iter" class="fnname">iter</a>(&amp;self) -&gt; <a class="struct" href="struct.Iter.html" title="struct bitvec::slice::Iter">Iter</a>&lt;'_, T, O&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="struct.Iter.html" title="struct bitvec::slice::Iter">Iter</a>&lt;'a, T, O&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="struct.Iter.html" title="struct bitvec::slice::Iter">Iter</a>&lt;'a, T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.66.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &lt;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a> as <a class="trait" href="trait.BitSliceIndex.html" title="trait bitvec::slice::BitSliceIndex">BitSliceIndex</a>&lt;'a, T, O&gt;&gt;::<a class="associatedtype" href="trait.BitSliceIndex.html#associatedtype.Immut" title="type bitvec::slice::BitSliceIndex::Immut">Immut</a>;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Produces an iterator over each bit in the bit-slice.</p>
<h6 id="original-19"><a href="#original-19">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.iter"><code>slice::iter</code></a></p>
<h6 id="api-differences-11"><a href="#api-differences-11">API Differences</a></h6>
<p>This iterator yields proxy-reference structures, not <code>&amp;bool</code>. It can be
adapted to yield <code>&amp;bool</code> with the <a href="struct.Iter.html#method.by_refs"><code>.by_refs()</code></a> method, or <code>bool</code> with
<a href="struct.Iter.html#method.by_vals"><code>.by_vals()</code></a>.</p>
<p>This iterator, and its adapters, are fast. Do not try to be more clever
than them by abusing <code>.as_bitptr_range()</code>.</p>
<h6 id="examples-16"><a href="#examples-16">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let </span><span class="kw-2">mut </span>iter = bits.iter();

<span class="macro">assert!</span>(!iter.next().unwrap());
<span class="macro">assert!</span>( iter.next().unwrap());
<span class="macro">assert!</span>( iter.next_back().unwrap());
<span class="macro">assert!</span>(!iter.next_back().unwrap());
<span class="macro">assert!</span>( iter.next().is_none());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.iter_mut" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#706-708">source</a><h4 class="code-header">pub fn <a href="#method.iter_mut" class="fnname">iter_mut</a>(&amp;mut self) -&gt; <a class="struct" href="struct.IterMut.html" title="struct bitvec::slice::IterMut">IterMut</a>&lt;'_, T, O&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="struct.IterMut.html" title="struct bitvec::slice::IterMut">IterMut</a>&lt;'a, T, O&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="struct.IterMut.html" title="struct bitvec::slice::IterMut">IterMut</a>&lt;'a, T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.66.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &lt;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a> as <a class="trait" href="trait.BitSliceIndex.html" title="trait bitvec::slice::BitSliceIndex">BitSliceIndex</a>&lt;'a, T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>, O&gt;&gt;::<a class="associatedtype" href="trait.BitSliceIndex.html#associatedtype.Mut" title="type bitvec::slice::BitSliceIndex::Mut">Mut</a>;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Produces a mutable iterator over each bit in the bit-slice.</p>
<h6 id="original-20"><a href="#original-20">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.iter_mut"><code>slice::iter_mut</code></a></p>
<h6 id="api-differences-12"><a href="#api-differences-12">API Differences</a></h6>
<p>This iterator yields proxy-reference structures, not <code>&amp;mut bool</code>. In
addition, it marks each proxy as alias-tainted.</p>
<p>If you are using this in an ordinary loop and <strong>not</strong> keeping multiple
yielded proxy-references alive at the same scope, you may use the
<a href="struct.IterMut.html#method.remove_alias"><code>.remove_alias()</code></a> adapter to undo the alias marking.</p>
<p>This iterator is fast. Do not try to be more clever than it by abusing
<code>.as_mut_bitptr_range()</code>.</p>
<h6 id="examples-17"><a href="#examples-17">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>; <span class="number">4</span>];
<span class="kw">let </span><span class="kw-2">mut </span>iter = bits.iter_mut();

iter.nth(<span class="number">1</span>).unwrap().commit(<span class="bool-val">true</span>); <span class="comment">// index 1
</span>iter.next_back().unwrap().commit(<span class="bool-val">true</span>); <span class="comment">// index 3

</span><span class="macro">assert!</span>(iter.next().is_some()); <span class="comment">// index 2
</span><span class="macro">assert!</span>(iter.next().is_none()); <span class="comment">// complete
</span><span class="macro">assert_eq!</span>(bits, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.windows" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#738-740">source</a><h4 class="code-header">pub fn <a href="#method.windows" class="fnname">windows</a>(&amp;self, size: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="struct.Windows.html" title="struct bitvec::slice::Windows">Windows</a>&lt;'_, T, O&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="struct.Windows.html" title="struct bitvec::slice::Windows">Windows</a>&lt;'a, T, O&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="struct.Windows.html" title="struct bitvec::slice::Windows">Windows</a>&lt;'a, T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.66.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Iterates over consecutive windowing subslices in a bit-slice.</p>
<p>Windows are overlapping views of the bit-slice. Each window advances one
bit from the previous, so in a bit-slice <code>[A, B, C, D, E]</code>, calling
<code>.windows(3)</code> will yield <code>[A, B, C]</code>, <code>[B, C, D]</code>, and <code>[C, D, E]</code>.</p>
<h6 id="original-21"><a href="#original-21">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.windows"><code>slice::windows</code></a></p>
<h6 id="panics-1"><a href="#panics-1">Panics</a></h6>
<p>This panics if <code>size</code> is <code>0</code>.</p>
<h6 id="examples-18"><a href="#examples-18">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let </span><span class="kw-2">mut </span>iter = bits.windows(<span class="number">3</span>);

<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]));
<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>(<span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]));
<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]));
<span class="macro">assert!</span>(iter.next().is_none());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.chunks" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#783-785">source</a><h4 class="code-header">pub fn <a href="#method.chunks" class="fnname">chunks</a>(&amp;self, chunk_size: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="struct.Chunks.html" title="struct bitvec::slice::Chunks">Chunks</a>&lt;'_, T, O&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="struct.Chunks.html" title="struct bitvec::slice::Chunks">Chunks</a>&lt;'a, T, O&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="struct.Chunks.html" title="struct bitvec::slice::Chunks">Chunks</a>&lt;'a, T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.66.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Iterates over non-overlapping subslices of a bit-slice.</p>
<p>Unlike <code>.windows()</code>, the subslices this yields do not overlap with each
other. If <code>self.len()</code> is not an even multiple of <code>chunk_size</code>, then the
last chunk yielded will be shorter.</p>
<h6 id="original-22"><a href="#original-22">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.chunks"><code>slice::chunks</code></a></p>
<h6 id="sibling-methods"><a href="#sibling-methods">Sibling Methods</a></h6>
<ul>
<li><a href="struct.BitSlice.html#method.chunks_mut"><code>.chunks_mut()</code></a> has the same division logic, but each yielded
bit-slice is mutable.</li>
<li><a href="struct.BitSlice.html#method.chunks_exact"><code>.chunks_exact()</code></a> does not yield the final chunk if it is shorter
than <code>chunk_size</code>.</li>
<li><a href="struct.BitSlice.html#method.rchunks"><code>.rchunks()</code></a> iterates from the back of the bit-slice to the front,
with the final, possibly-shorter, segment at the front edge.</li>
</ul>
<h6 id="panics-2"><a href="#panics-2">Panics</a></h6>
<p>This panics if <code>chunk_size</code> is <code>0</code>.</p>
<h6 id="examples-19"><a href="#examples-19">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let </span><span class="kw-2">mut </span>iter = bits.chunks(<span class="number">2</span>);

<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>]));
<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>]));
<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>(<span class="macro">bits!</span>[<span class="number">1</span>]));
<span class="macro">assert!</span>(iter.next().is_none());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.chunks_mut" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#834-836">source</a><h4 class="code-header">pub fn <a href="#method.chunks_mut" class="fnname">chunks_mut</a>(&amp;mut self, chunk_size: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="struct.ChunksMut.html" title="struct bitvec::slice::ChunksMut">ChunksMut</a>&lt;'_, T, O&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="struct.ChunksMut.html" title="struct bitvec::slice::ChunksMut">ChunksMut</a>&lt;'a, T, O&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="struct.ChunksMut.html" title="struct bitvec::slice::ChunksMut">ChunksMut</a>&lt;'a, T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.66.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a mut <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>, O&gt;;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Iterates over non-overlapping mutable subslices of a bit-slice.</p>
<p>Iterators do not require that each yielded item is destroyed before the
next is produced. This means that each bit-slice yielded must be marked
as aliased. If you are using this in a loop that does not collect
multiple yielded subslices for the same scope, then you can remove the
alias marking by calling the (<code>unsafe</code>) method <a href="struct.ChunksMut.html#method.remove_alias"><code>.remove_alias()</code></a> on
the iterator.</p>
<h6 id="original-23"><a href="#original-23">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.chunks_mut"><code>slice::chunks_mut</code></a></p>
<h6 id="sibling-methods-1"><a href="#sibling-methods-1">Sibling Methods</a></h6>
<ul>
<li><a href="struct.BitSlice.html#method.chunks"><code>.chunks()</code></a> has the same division logic, but each yielded bit-slice
is immutable.</li>
<li><a href="struct.BitSlice.html#method.chunks_exact_mut"><code>.chunks_exact_mut()</code></a> does not yield the final chunk if it is
shorter than <code>chunk_size</code>.</li>
<li><a href="struct.BitSlice.html#method.rchunks_mut"><code>.rchunks_mut()</code></a> iterates from the back of the bit-slice to the
front, with the final, possibly-shorter, segment at the front edge.</li>
</ul>
<h6 id="panics-3"><a href="#panics-3">Panics</a></h6>
<p>This panics if <code>chunk_size</code> is <code>0</code>.</p>
<h6 id="examples-20"><a href="#examples-20">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span>u8, Msb0; <span class="number">0</span>; <span class="number">5</span>];

<span class="kw">for </span>(idx, chunk) <span class="kw">in unsafe </span>{
  bits.chunks_mut(<span class="number">2</span>).remove_alias()
}.enumerate() {
  chunk.store(idx + <span class="number">1</span>);
}
<span class="macro">assert_eq!</span>(bits, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]);
<span class="comment">//                     ^^^^  ^^^^  ^</span></code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.chunks_exact" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#880-882">source</a><h4 class="code-header">pub fn <a href="#method.chunks_exact" class="fnname">chunks_exact</a>(&amp;self, chunk_size: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="struct.ChunksExact.html" title="struct bitvec::slice::ChunksExact">ChunksExact</a>&lt;'_, T, O&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="struct.ChunksExact.html" title="struct bitvec::slice::ChunksExact">ChunksExact</a>&lt;'a, T, O&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="struct.ChunksExact.html" title="struct bitvec::slice::ChunksExact">ChunksExact</a>&lt;'a, T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.66.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Iterates over non-overlapping subslices of a bit-slice.</p>
<p>If <code>self.len()</code> is not an even multiple of <code>chunk_size</code>, then the last
few bits are not yielded by the iterator at all. They can be accessed
with the <a href="struct.ChunksExact.html#method.remainder"><code>.remainder()</code></a> method if the iterator is bound to a name.</p>
<h6 id="original-24"><a href="#original-24">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.chunks_exact"><code>slice::chunks_exact</code></a></p>
<h6 id="sibling-methods-2"><a href="#sibling-methods-2">Sibling Methods</a></h6>
<ul>
<li><a href="struct.BitSlice.html#method.chunks"><code>.chunks()</code></a> yields any leftover bits at the end as a shorter chunk
during iteration.</li>
<li><a href="struct.BitSlice.html#method.chunks_exact_mut"><code>.chunks_exact_mut()</code></a> has the same division logic, but each yielded
bit-slice is mutable.</li>
<li><a href="struct.BitSlice.html#method.rchunks_exact"><code>.rchunks_exact()</code></a> iterates from the back of the bit-slice to the
front, with the unyielded remainder segment at the front edge.</li>
</ul>
<h6 id="panics-4"><a href="#panics-4">Panics</a></h6>
<p>This panics if <code>chunk_size</code> is <code>0</code>.</p>
<h6 id="examples-21"><a href="#examples-21">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let </span><span class="kw-2">mut </span>iter = bits.chunks_exact(<span class="number">2</span>);

<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>]));
<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>]));
<span class="macro">assert!</span>(iter.next().is_none());
<span class="macro">assert_eq!</span>(iter.remainder(), <span class="macro">bits!</span>[<span class="number">1</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.chunks_exact_mut" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#938-943">source</a><h4 class="code-header">pub fn <a href="#method.chunks_exact_mut" class="fnname">chunks_exact_mut</a>(&amp;mut self, chunk_size: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="struct.ChunksExactMut.html" title="struct bitvec::slice::ChunksExactMut">ChunksExactMut</a>&lt;'_, T, O&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="struct.ChunksExactMut.html" title="struct bitvec::slice::ChunksExactMut">ChunksExactMut</a>&lt;'a, T, O&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="struct.ChunksExactMut.html" title="struct bitvec::slice::ChunksExactMut">ChunksExactMut</a>&lt;'a, T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.66.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a mut <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>, O&gt;;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Iterates over non-overlapping mutable subslices of a bit-slice.</p>
<p>If <code>self.len()</code> is not an even multiple of <code>chunk_size</code>, then the last
few bits are not yielded by the iterator at all. They can be accessed
with the <a href="struct.ChunksExactMut.html#method.into_remainder"><code>.into_remainder()</code></a> method if the iterator is bound to a
name.</p>
<p>Iterators do not require that each yielded item is destroyed before the
next is produced. This means that each bit-slice yielded must be marked
as aliased. If you are using this in a loop that does not collect
multiple yielded subslices for the same scope, then you can remove the
alias marking by calling the (<code>unsafe</code>) method <a href="struct.ChunksExactMut.html#method.remove_alias"><code>.remove_alias()</code></a> on
the iterator.</p>
<h6 id="original-25"><a href="#original-25">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.chunks_exact_mut"><code>slice::chunks_exact_mut</code></a></p>
<h6 id="sibling-methods-3"><a href="#sibling-methods-3">Sibling Methods</a></h6>
<ul>
<li><a href="struct.BitSlice.html#method.chunks_mut"><code>.chunks_mut()</code></a> yields any leftover bits at the end as a shorter
chunk during iteration.</li>
<li><a href="struct.BitSlice.html#method.chunks_exact"><code>.chunks_exact()</code></a> has the same division logic, but each yielded
bit-slice is immutable.</li>
<li><a href="struct.BitSlice.html#method.rchunks_exact_mut"><code>.rchunks_exact_mut()</code></a> iterates from the back of the bit-slice
forwards, with the unyielded remainder segment at the front edge.</li>
</ul>
<h6 id="panics-5"><a href="#panics-5">Panics</a></h6>
<p>This panics if <code>chunk_size</code> is <code>0</code>.</p>
<h6 id="examples-22"><a href="#examples-22">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span>u8, Msb0; <span class="number">0</span>; <span class="number">5</span>];
<span class="kw">let </span><span class="kw-2">mut </span>iter = bits.chunks_exact_mut(<span class="number">2</span>);

<span class="kw">for </span>(idx, chunk) <span class="kw">in </span>iter.by_ref().enumerate() {
  chunk.store(idx + <span class="number">1</span>);
}
iter.into_remainder().store(<span class="number">1u8</span>);

<span class="macro">assert_eq!</span>(bits, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]);
<span class="comment">//                       remainder ^</span></code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.rchunks" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#987-989">source</a><h4 class="code-header">pub fn <a href="#method.rchunks" class="fnname">rchunks</a>(&amp;self, chunk_size: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="struct.RChunks.html" title="struct bitvec::slice::RChunks">RChunks</a>&lt;'_, T, O&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="struct.RChunks.html" title="struct bitvec::slice::RChunks">RChunks</a>&lt;'a, T, O&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="struct.RChunks.html" title="struct bitvec::slice::RChunks">RChunks</a>&lt;'a, T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.66.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Iterates over non-overlapping subslices of a bit-slice, from the back
edge.</p>
<p>Unlike <code>.chunks()</code>, this aligns its chunks to the back edge of <code>self</code>.
If <code>self.len()</code> is not an even multiple of <code>chunk_size</code>, then the
leftover partial chunk is <code>self[0 .. len % chunk_size]</code>.</p>
<h6 id="original-26"><a href="#original-26">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.rchunks"><code>slice::rchunks</code></a></p>
<h6 id="sibling-methods-4"><a href="#sibling-methods-4">Sibling Methods</a></h6>
<ul>
<li><a href="struct.BitSlice.html#method.rchunks_mut"><code>.rchunks_mut()</code></a> has the same division logic, but each yielded
bit-slice is mutable.</li>
<li><a href="struct.BitSlice.html#method.rchunks_exact"><code>.rchunks_exact()</code></a> does not yield the final chunk if it is shorter
than <code>chunk_size</code>.</li>
<li><a href="struct.BitSlice.html#method.chunks"><code>.chunks()</code></a> iterates from the front of the bit-slice to the back,
with the final, possibly-shorter, segment at the back edge.</li>
</ul>
<h6 id="panics-6"><a href="#panics-6">Panics</a></h6>
<p>This panics if <code>chunk_size</code> is <code>0</code>.</p>
<h6 id="examples-23"><a href="#examples-23">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let </span><span class="kw-2">mut </span>iter = bits.rchunks(<span class="number">2</span>);

<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>]));
<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>(<span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>]));
<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>(<span class="macro">bits!</span>[<span class="number">0</span>]));
<span class="macro">assert!</span>(iter.next().is_none());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.rchunks_mut" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#1038-1040">source</a><h4 class="code-header">pub fn <a href="#method.rchunks_mut" class="fnname">rchunks_mut</a>(&amp;mut self, chunk_size: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="struct.RChunksMut.html" title="struct bitvec::slice::RChunksMut">RChunksMut</a>&lt;'_, T, O&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="struct.RChunksMut.html" title="struct bitvec::slice::RChunksMut">RChunksMut</a>&lt;'a, T, O&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="struct.RChunksMut.html" title="struct bitvec::slice::RChunksMut">RChunksMut</a>&lt;'a, T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.66.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a mut <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>, O&gt;;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Iterates over non-overlapping mutable subslices of a bit-slice, from the
back edge.</p>
<p>Unlike <code>.chunks_mut()</code>, this aligns its chunks to the back edge of
<code>self</code>. If <code>self.len()</code> is not an even multiple of <code>chunk_size</code>, then
the leftover partial chunk is <code>self[0 .. len % chunk_size]</code>.</p>
<p>Iterators do not require that each yielded item is destroyed before the
next is produced. This means that each bit-slice yielded must be marked
as aliased. If you are using this in a loop that does not collect
multiple yielded values for the same scope, then you can remove the
alias marking by calling the (<code>unsafe</code>) method <a href="struct.RChunksMut.html#method.remove_alias"><code>.remove_alias()</code></a> on
the iterator.</p>
<h6 id="original-27"><a href="#original-27">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.rchunks_mut"><code>slice::rchunks_mut</code></a></p>
<h6 id="sibling-methods-5"><a href="#sibling-methods-5">Sibling Methods</a></h6>
<ul>
<li><a href="struct.BitSlice.html#method.rchunks"><code>.rchunks()</code></a> has the same division logic, but each yielded bit-slice
is immutable.</li>
<li><a href="struct.BitSlice.html#method.rchunks_exact_mut"><code>.rchunks_exact_mut()</code></a> does not yield the final chunk if it is
shorter than <code>chunk_size</code>.</li>
<li><a href="struct.BitSlice.html#method.chunks_mut"><code>.chunks_mut()</code></a> iterates from the front of the bit-slice to the
back, with the final, possibly-shorter, segment at the back edge.</li>
</ul>
<h6 id="examples-24"><a href="#examples-24">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span>u8, Msb0; <span class="number">0</span>; <span class="number">5</span>];
<span class="kw">for </span>(idx, chunk) <span class="kw">in unsafe </span>{
  bits.rchunks_mut(<span class="number">2</span>).remove_alias()
}.enumerate() {
  chunk.store(idx + <span class="number">1</span>);
}
<span class="macro">assert_eq!</span>(bits, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]);
<span class="comment">//           remainder ^  ^^^^  ^^^^</span></code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.rchunks_exact" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#1085-1087">source</a><h4 class="code-header">pub fn <a href="#method.rchunks_exact" class="fnname">rchunks_exact</a>(&amp;self, chunk_size: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="struct.RChunksExact.html" title="struct bitvec::slice::RChunksExact">RChunksExact</a>&lt;'_, T, O&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="struct.RChunksExact.html" title="struct bitvec::slice::RChunksExact">RChunksExact</a>&lt;'a, T, O&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="struct.RChunksExact.html" title="struct bitvec::slice::RChunksExact">RChunksExact</a>&lt;'a, T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.66.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Iterates over non-overlapping subslices of a bit-slice, from the back
edge.</p>
<p>If <code>self.len()</code> is not an even multiple of <code>chunk_size</code>, then the first
few bits are not yielded by the iterator at all. They can be accessed
with the <a href="struct.RChunksExact.html#method.remainder"><code>.remainder()</code></a> method if the iterator is bound to a name.</p>
<h6 id="original-28"><a href="#original-28">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.rchunks_exact"><code>slice::rchunks_exact</code></a></p>
<h6 id="sibling-methods-6"><a href="#sibling-methods-6">Sibling Methods</a></h6>
<ul>
<li><a href="struct.BitSlice.html#method.rchunks"><code>.rchunks()</code></a> yields any leftover bits at the front as a shorter
chunk during iteration.</li>
<li><a href="struct.BitSlice.html#method.rchunks_exact_mut"><code>.rchunks_exact_mut()</code></a> has the same division logic, but each yielded
bit-slice is mutable.</li>
<li><a href="struct.BitSlice.html#method.chunks_exact"><code>.chunks_exact()</code></a> iterates from the front of the bit-slice to the
back, with the unyielded remainder segment at the back edge.</li>
</ul>
<h6 id="panics-7"><a href="#panics-7">Panics</a></h6>
<p>This panics if <code>chunk_size</code> is <code>0</code>.</p>
<h6 id="examples-25"><a href="#examples-25">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let </span><span class="kw-2">mut </span>iter = bits.rchunks_exact(<span class="number">2</span>);

<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>]));
<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>(<span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>]));
<span class="macro">assert!</span>(iter.next().is_none());
<span class="macro">assert_eq!</span>(iter.remainder(), <span class="macro">bits!</span>[<span class="number">0</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.rchunks_exact_mut" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#1140-1145">source</a><h4 class="code-header">pub fn <a href="#method.rchunks_exact_mut" class="fnname">rchunks_exact_mut</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self,<br>&nbsp;&nbsp;&nbsp;&nbsp;chunk_size: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a><br>) -&gt; <a class="struct" href="struct.RChunksExactMut.html" title="struct bitvec::slice::RChunksExactMut">RChunksExactMut</a>&lt;'_, T, O&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="struct.RChunksExactMut.html" title="struct bitvec::slice::RChunksExactMut">RChunksExactMut</a>&lt;'a, T, O&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="struct.RChunksExactMut.html" title="struct bitvec::slice::RChunksExactMut">RChunksExactMut</a>&lt;'a, T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.66.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a mut <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>, O&gt;;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Iterates over non-overlapping mutable subslices of a bit-slice, from the
back edge.</p>
<p>If <code>self.len()</code> is not an even multiple of <code>chunk_size</code>, then the first
few bits are not yielded by the iterator at all. They can be accessed
with the <a href="struct.RChunksExactMut.html#method.into_remainder"><code>.into_remainder()</code></a> method if the iterator is bound to a
name.</p>
<p>Iterators do not require that each yielded item is destroyed before the
next is produced. This means that each bit-slice yielded must be marked
as aliased. If you are using this in a loop that does not collect
multiple yielded subslices for the same scope, then you can remove the
alias marking by calling the (<code>unsafe</code>) method <a href="struct.RChunksExactMut.html#method.remove_alias"><code>.remove_alias()</code></a> on
the iterator.</p>
<h6 id="sibling-methods-7"><a href="#sibling-methods-7">Sibling Methods</a></h6>
<ul>
<li><a href="struct.BitSlice.html#method.rchunks_mut"><code>.rchunks_mut()</code></a> yields any leftover bits at the front as a shorter
chunk during iteration.</li>
<li><a href="struct.BitSlice.html#method.rchunks_exact"><code>.rchunks_exact()</code></a> has the same division logic, but each yielded
bit-slice is immutable.</li>
<li><a href="struct.BitSlice.html#method.chunks_exact_mut"><code>.chunks_exact_mut()</code></a> iterates from the front of the bit-slice
backwards, with the unyielded remainder segment at the back edge.</li>
</ul>
<h6 id="panics-8"><a href="#panics-8">Panics</a></h6>
<p>This panics if <code>chunk_size</code> is <code>0</code>.</p>
<h6 id="examples-26"><a href="#examples-26">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span>u8, Msb0; <span class="number">0</span>; <span class="number">5</span>];
<span class="kw">let </span><span class="kw-2">mut </span>iter = bits.rchunks_exact_mut(<span class="number">2</span>);

<span class="kw">for </span>(idx, chunk) <span class="kw">in </span>iter.by_ref().enumerate() {
  chunk.store(idx + <span class="number">1</span>);
}
iter.into_remainder().store(<span class="number">1u8</span>);

<span class="macro">assert_eq!</span>(bits, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]);
<span class="comment">//           remainder ^</span></code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.split_at" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#1188-1191">source</a><h4 class="code-header">pub fn <a href="#method.split_at" class="fnname">split_at</a>(&amp;self, mid: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>) -&gt; (<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Self, <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Self)</h4></section></summary><div class="docblock"><p>Splits a bit-slice in two parts at an index.</p>
<p>The returned bit-slices are <code>self[.. mid]</code> and <code>self[mid ..]</code>. <code>mid</code> is
included in the right bit-slice, not the left.</p>
<p>If <code>mid</code> is <code>0</code> then the left bit-slice is empty; if it is <code>self.len()</code>
then the right bit-slice is empty.</p>
<p>This method guarantees that even when either partition is empty, the
encoded bit-pointer values of the bit-slice references is <code>&amp;self[0]</code> and
<code>&amp;self[mid]</code>.</p>
<h6 id="original-29"><a href="#original-29">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.split_at"><code>slice::split_at</code></a></p>
<h6 id="panics-9"><a href="#panics-9">Panics</a></h6>
<p>This panics if <code>mid</code> is greater than <code>self.len()</code>. It is allowed to be
equal to the length, in which case the right bit-slice is simply empty.</p>
<h6 id="examples-27"><a href="#examples-27">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="kw">let </span>base = bits.as_bitptr();

<span class="kw">let </span>(a, b) = bits.split_at(<span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="kw">unsafe </span>{ a.as_bitptr().offset_from(base) }, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="kw">unsafe </span>{ b.as_bitptr().offset_from(base) }, <span class="number">0</span>);

<span class="kw">let </span>(a, b) = bits.split_at(<span class="number">6</span>);
<span class="macro">assert_eq!</span>(<span class="kw">unsafe </span>{ b.as_bitptr().offset_from(base) }, <span class="number">6</span>);

<span class="kw">let </span>(a, b) = bits.split_at(<span class="number">3</span>);
<span class="macro">assert_eq!</span>(a, <span class="macro">bits!</span>[<span class="number">0</span>; <span class="number">3</span>]);
<span class="macro">assert_eq!</span>(b, <span class="macro">bits!</span>[<span class="number">1</span>; <span class="number">3</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.split_at_mut" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#1244-1250">source</a><h4 class="code-header">pub fn <a href="#method.split_at_mut" class="fnname">split_at_mut</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self,<br>&nbsp;&nbsp;&nbsp;&nbsp;mid: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a><br>) -&gt; (&amp;mut <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>, O&gt;, &amp;mut <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>, O&gt;)</h4></section></summary><div class="docblock"><p>Splits a mutable bit-slice in two parts at an index.</p>
<p>The returned bit-slices are <code>self[.. mid]</code> and <code>self[mid ..]</code>. <code>mid</code> is
included in the right bit-slice, not the left.</p>
<p>If <code>mid</code> is <code>0</code> then the left bit-slice is empty; if it is <code>self.len()</code>
then the right bit-slice is empty.</p>
<p>This method guarantees that even when either partition is empty, the
encoded bit-pointer values of the bit-slice references is <code>&amp;self[0]</code> and
<code>&amp;self[mid]</code>.</p>
<h6 id="original-30"><a href="#original-30">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.split_at_mut"><code>slice::split_at_mut</code></a></p>
<h6 id="api-differences-13"><a href="#api-differences-13">API Differences</a></h6>
<p>The end bits of the left half and the start bits of the right half might
be stored in the same memory element. In order to avoid breaking
<code>bitvec</code>’s memory-safety guarantees, both bit-slices are marked as
<code>T::Alias</code>. This marking allows them to be used without interfering with
each other when they interact with memory.</p>
<h6 id="panics-10"><a href="#panics-10">Panics</a></h6>
<p>This panics if <code>mid</code> is greater than <code>self.len()</code>. It is allowed to be
equal to the length, in which case the right bit-slice is simply empty.</p>
<h6 id="examples-28"><a href="#examples-28">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span>u8, Msb0; <span class="number">0</span>; <span class="number">6</span>];
<span class="kw">let </span>base = bits.as_mut_bitptr();

<span class="kw">let </span>(a, b) = bits.split_at_mut(<span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="kw">unsafe </span>{ a.as_mut_bitptr().offset_from(base) }, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="kw">unsafe </span>{ b.as_mut_bitptr().offset_from(base) }, <span class="number">0</span>);

<span class="kw">let </span>(a, b) = bits.split_at_mut(<span class="number">6</span>);
<span class="macro">assert_eq!</span>(<span class="kw">unsafe </span>{ b.as_mut_bitptr().offset_from(base) }, <span class="number">6</span>);

<span class="kw">let </span>(a, b) = bits.split_at_mut(<span class="number">3</span>);
a.store(<span class="number">3</span>);
b.store(<span class="number">5</span>);

<span class="macro">assert_eq!</span>(bits, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.split" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#1327-1330">source</a><h4 class="code-header">pub fn <a href="#method.split" class="fnname">split</a>&lt;F&gt;(&amp;self, pred: F) -&gt; <a class="struct" href="struct.Split.html" title="struct bitvec::slice::Split">Split</a>&lt;'_, T, O, F&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="struct.Split.html" title="struct bitvec::slice::Split">Split</a>&lt;'a, T, O, P&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, T, O, P&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="struct.Split.html" title="struct bitvec::slice::Split">Split</a>&lt;'a, T, O, P&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a>,</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.66.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;;</span></code></span></span></span></span><span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a>,</span></h4></section></summary><div class="docblock"><p>Iterates over subslices separated by bits that match a predicate. The
matched bit is <em>not</em> contained in the yielded bit-slices.</p>
<h6 id="original-31"><a href="#original-31">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.split"><code>slice::split</code></a></p>
<h6 id="api-differences-14"><a href="#api-differences-14">API Differences</a></h6>
<p>The predicate function receives the index being tested as well as the
bit value at that index. This allows the predicate to have more than one
bit of information about the bit-slice being traversed.</p>
<h6 id="sibling-methods-8"><a href="#sibling-methods-8">Sibling Methods</a></h6>
<ul>
<li><a href="struct.BitSlice.html#method.split_mut"><code>.split_mut()</code></a> has the same splitting logic, but each yielded
bit-slice is mutable.</li>
<li><a href="struct.BitSlice.html#method.split_inclusive"><code>.split_inclusive()</code></a> includes the matched bit in the yielded
bit-slice.</li>
<li><a href="struct.BitSlice.html#method.rsplit"><code>.rsplit()</code></a> iterates from the back of the bit-slice instead of the
front.</li>
<li><a href="struct.BitSlice.html#method.splitn"><code>.splitn()</code></a> times out after <code>n</code> yields.</li>
</ul>
<h6 id="examples-29"><a href="#examples-29">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="comment">//                     ^
</span><span class="kw">let </span><span class="kw-2">mut </span>iter = bits.split(|pos, _bit| pos % <span class="number">3 </span>== <span class="number">2</span>);

<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>]);
<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[<span class="number">0</span>]);
<span class="macro">assert!</span>(iter.next().is_none());</code></pre></div>
<p>If the first bit is matched, then an empty bit-slice will be the first
item yielded by the iterator. Similarly, if the last bit in the
bit-slice matches, then an empty bit-slice will be the last item
yielded.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="comment">//                     ^
</span><span class="kw">let </span><span class="kw-2">mut </span>iter = bits.split(|_pos, bit| <span class="kw-2">*</span>bit);

<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[<span class="number">0</span>; <span class="number">2</span>]);
<span class="macro">assert!</span>(iter.next().unwrap().is_empty());
<span class="macro">assert!</span>(iter.next().is_none());</code></pre></div>
<p>If two matched bits are directly adjacent, then an empty bit-slice will
be yielded between them:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="comment">//                  ^  ^
</span><span class="kw">let </span><span class="kw-2">mut </span>iter = bits.split(|_pos, bit| !<span class="kw-2">*</span>bit);

<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[<span class="number">1</span>]);
<span class="macro">assert!</span>(iter.next().unwrap().is_empty());
<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[<span class="number">1</span>]);
<span class="macro">assert!</span>(iter.next().is_none());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.split_mut" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#1381-1384">source</a><h4 class="code-header">pub fn <a href="#method.split_mut" class="fnname">split_mut</a>&lt;F&gt;(&amp;mut self, pred: F) -&gt; <a class="struct" href="struct.SplitMut.html" title="struct bitvec::slice::SplitMut">SplitMut</a>&lt;'_, T, O, F&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="struct.SplitMut.html" title="struct bitvec::slice::SplitMut">SplitMut</a>&lt;'a, T, O, P&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, T, O, P&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="struct.SplitMut.html" title="struct bitvec::slice::SplitMut">SplitMut</a>&lt;'a, T, O, P&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a>,</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.66.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a mut <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>, O&gt;;</span></code></span></span></span></span><span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a>,</span></h4></section></summary><div class="docblock"><p>Iterates over mutable subslices separated by bits that match a
predicate. The matched bit is <em>not</em> contained in the yielded bit-slices.</p>
<p>Iterators do not require that each yielded item is destroyed before the
next is produced. This means that each bit-slice yielded must be marked
as aliased. If you are using this in a loop that does not collect
multiple yielded subslices for the same scope, then you can remove the
alias marking by calling the (<code>unsafe</code>) method <a href="struct.SplitMut.html#method.remove_alias"><code>.remove_alias()</code></a> on
the iterator.</p>
<h6 id="original-32"><a href="#original-32">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.split_mut"><code>slice::split_mut</code></a></p>
<h6 id="api-differences-15"><a href="#api-differences-15">API Differences</a></h6>
<p>The predicate function receives the index being tested as well as the
bit value at that index. This allows the predicate to have more than one
bit of information about the bit-slice being traversed.</p>
<h6 id="sibling-methods-9"><a href="#sibling-methods-9">Sibling Methods</a></h6>
<ul>
<li><a href="struct.BitSlice.html#method.split"><code>.split()</code></a> has the same splitting logic, but each yielded bit-slice
is immutable.</li>
<li><a href="struct.BitSlice.html#method.split_inclusive_mut"><code>.split_inclusive_mut()</code></a> includes the matched bit in the yielded
bit-slice.</li>
<li><a href="struct.BitSlice.html#method.rsplit_mut"><code>.rsplit_mut()</code></a> iterates from the back of the bit-slice instead of
the front.</li>
<li><a href="struct.BitSlice.html#method.splitn_mut"><code>.splitn_mut()</code></a> times out after <code>n</code> yields.</li>
</ul>
<h6 id="examples-30"><a href="#examples-30">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="comment">//                         ^     ^
</span><span class="kw">for </span>group <span class="kw">in </span>bits.split_mut(|_pos, bit| <span class="kw-2">*</span>bit) {
  group.set(<span class="number">0</span>, <span class="bool-val">true</span>);
}
<span class="macro">assert_eq!</span>(bits, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.split_inclusive" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#1424-1427">source</a><h4 class="code-header">pub fn <a href="#method.split_inclusive" class="fnname">split_inclusive</a>&lt;F&gt;(&amp;self, pred: F) -&gt; <a class="struct" href="struct.SplitInclusive.html" title="struct bitvec::slice::SplitInclusive">SplitInclusive</a>&lt;'_, T, O, F&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="struct.SplitInclusive.html" title="struct bitvec::slice::SplitInclusive">SplitInclusive</a>&lt;'a, T, O, P&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, T, O, P&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="struct.SplitInclusive.html" title="struct bitvec::slice::SplitInclusive">SplitInclusive</a>&lt;'a, T, O, P&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a>,</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.66.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;;</span></code></span></span></span></span><span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a>,</span></h4></section></summary><div class="docblock"><p>Iterates over subslices separated by bits that match a predicate. Unlike
<code>.split()</code>, this <em>does</em> include the matching bit as the last bit in the
yielded bit-slice.</p>
<h6 id="original-33"><a href="#original-33">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.split_inclusive"><code>slice::split_inclusive</code></a></p>
<h6 id="api-differences-16"><a href="#api-differences-16">API Differences</a></h6>
<p>The predicate function receives the index being tested as well as the
bit value at that index. This allows the predicate to have more than one
bit of information about the bit-slice being traversed.</p>
<h6 id="sibling-methods-10"><a href="#sibling-methods-10">Sibling Methods</a></h6>
<ul>
<li><a href="struct.BitSlice.html#method.split_inclusive_mut"><code>.split_inclusive_mut()</code></a> has the same splitting logic, but each
yielded bit-slice is mutable.</li>
<li><a href="struct.BitSlice.html#method.split"><code>.split()</code></a> does not include the matched bit in the yielded
bit-slice.</li>
</ul>
<h6 id="examples-31"><a href="#examples-31">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="comment">//                     ^     ^
</span><span class="kw">let </span><span class="kw-2">mut </span>iter = bits.split_inclusive(|_pos, bit| <span class="kw-2">*</span>bit);

<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]);
<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>]);
<span class="macro">assert!</span>(iter.next().is_none());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.split_inclusive_mut" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#1474-1482">source</a><h4 class="code-header">pub fn <a href="#method.split_inclusive_mut" class="fnname">split_inclusive_mut</a>&lt;F&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self,<br>&nbsp;&nbsp;&nbsp;&nbsp;pred: F<br>) -&gt; <a class="struct" href="struct.SplitInclusiveMut.html" title="struct bitvec::slice::SplitInclusiveMut">SplitInclusiveMut</a>&lt;'_, T, O, F&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="struct.SplitInclusiveMut.html" title="struct bitvec::slice::SplitInclusiveMut">SplitInclusiveMut</a>&lt;'a, T, O, P&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, T, O, P&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="struct.SplitInclusiveMut.html" title="struct bitvec::slice::SplitInclusiveMut">SplitInclusiveMut</a>&lt;'a, T, O, P&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a>,</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.66.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a mut <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>, O&gt;;</span></code></span></span></span></span><span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a>,</span></h4></section></summary><div class="docblock"><p>Iterates over mutable subslices separated by bits that match a
predicate. Unlike <code>.split_mut()</code>, this <em>does</em> include the matching bit
as the last bit in the bit-slice.</p>
<p>Iterators do not require that each yielded item is destroyed before the
next is produced. This means that each bit-slice yielded must be marked
as aliased. If you are using this in a loop that does not collect
multiple yielded subslices for the same scope, then you can remove the
alias marking by calling the (<code>unsafe</code>) method <a href="struct.SplitInclusiveMut.html#method.remove_alias"><code>.remove_alias()</code></a> on
the iterator.</p>
<h6 id="original-34"><a href="#original-34">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.split_inclusive_mut"><code>slice::split_inclusive_mut</code></a></p>
<h6 id="api-differences-17"><a href="#api-differences-17">API Differences</a></h6>
<p>The predicate function receives the index being tested as well as the
bit value at that index. This allows the predicate to have more than one
bit of information about the bit-slice being traversed.</p>
<h6 id="sibling-methods-11"><a href="#sibling-methods-11">Sibling Methods</a></h6>
<ul>
<li><a href="struct.BitSlice.html#method.split_inclusive"><code>.split_inclusive()</code></a> has the same splitting logic, but each yielded
bit-slice is immutable.</li>
<li><a href="struct.BitSlice.html#method.split_mut"><code>.split_mut()</code></a> does not include the matched bit in the yielded
bit-slice.</li>
</ul>
<h6 id="examples-32"><a href="#examples-32">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="comment">//                         ^
</span><span class="kw">for </span>group <span class="kw">in </span>bits.split_inclusive_mut(|pos, _bit| pos % <span class="number">3 </span>== <span class="number">2</span>) {
  group.set(<span class="number">0</span>, <span class="bool-val">true</span>);
}
<span class="macro">assert_eq!</span>(bits, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.rsplit" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#1557-1560">source</a><h4 class="code-header">pub fn <a href="#method.rsplit" class="fnname">rsplit</a>&lt;F&gt;(&amp;self, pred: F) -&gt; <a class="struct" href="struct.RSplit.html" title="struct bitvec::slice::RSplit">RSplit</a>&lt;'_, T, O, F&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="struct.RSplit.html" title="struct bitvec::slice::RSplit">RSplit</a>&lt;'a, T, O, P&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, T, O, P&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="struct.RSplit.html" title="struct bitvec::slice::RSplit">RSplit</a>&lt;'a, T, O, P&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a>,</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.66.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;;</span></code></span></span></span></span><span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a>,</span></h4></section></summary><div class="docblock"><p>Iterates over subslices separated by bits that match a predicate, from
the back edge. The matched bit is <em>not</em> contained in the yielded
bit-slices.</p>
<h6 id="original-35"><a href="#original-35">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.rsplit"><code>slice::rsplit</code></a></p>
<h6 id="api-differences-18"><a href="#api-differences-18">API Differences</a></h6>
<p>The predicate function receives the index being tested as well as the
bit value at that index. This allows the predicate to have more than one
bit of information about the bit-slice being traversed.</p>
<h6 id="sibling-methods-12"><a href="#sibling-methods-12">Sibling Methods</a></h6>
<ul>
<li><a href="struct.BitSlice.html#method.rsplit_mut"><code>.rsplit_mut()</code></a> has the same splitting logic, but each yielded
bit-slice is mutable.</li>
<li><a href="struct.BitSlice.html#method.split"><code>.split()</code></a> iterates from the front of the bit-slice instead of the
back.</li>
<li><a href="struct.BitSlice.html#method.rsplitn"><code>.rsplitn()</code></a> times out after <code>n</code> yields.</li>
</ul>
<h6 id="examples-33"><a href="#examples-33">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="comment">//                     ^
</span><span class="kw">let </span><span class="kw-2">mut </span>iter = bits.rsplit(|pos, _bit| pos % <span class="number">3 </span>== <span class="number">2</span>);

<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[<span class="number">0</span>]);
<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>]);
<span class="macro">assert!</span>(iter.next().is_none());</code></pre></div>
<p>If the last bit is matched, then an empty bit-slice will be the first
item yielded by the iterator. Similarly, if the first bit in the
bit-slice matches, then an empty bit-slice will be the last item
yielded.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="comment">//                     ^
</span><span class="kw">let </span><span class="kw-2">mut </span>iter = bits.rsplit(|_pos, bit| <span class="kw-2">*</span>bit);

<span class="macro">assert!</span>(iter.next().unwrap().is_empty());
<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[<span class="number">0</span>; <span class="number">2</span>]);
<span class="macro">assert!</span>(iter.next().is_none());</code></pre></div>
<p>If two yielded bits are directly adjacent, then an empty bit-slice will
be yielded between them:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="comment">//                  ^  ^
</span><span class="kw">let </span><span class="kw-2">mut </span>iter = bits.split(|_pos, bit| !<span class="kw-2">*</span>bit);

<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[<span class="number">1</span>]);
<span class="macro">assert!</span>(iter.next().unwrap().is_empty());
<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[<span class="number">1</span>]);
<span class="macro">assert!</span>(iter.next().is_none());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.rsplit_mut" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#1609-1612">source</a><h4 class="code-header">pub fn <a href="#method.rsplit_mut" class="fnname">rsplit_mut</a>&lt;F&gt;(&amp;mut self, pred: F) -&gt; <a class="struct" href="struct.RSplitMut.html" title="struct bitvec::slice::RSplitMut">RSplitMut</a>&lt;'_, T, O, F&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="struct.RSplitMut.html" title="struct bitvec::slice::RSplitMut">RSplitMut</a>&lt;'a, T, O, P&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, T, O, P&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="struct.RSplitMut.html" title="struct bitvec::slice::RSplitMut">RSplitMut</a>&lt;'a, T, O, P&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a>,</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.66.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a mut <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>, O&gt;;</span></code></span></span></span></span><span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a>,</span></h4></section></summary><div class="docblock"><p>Iterates over mutable subslices separated by bits that match a
predicate, from the back. The matched bit is <em>not</em> contained in the
yielded bit-slices.</p>
<p>Iterators do not require that each yielded item is destroyed before the
next is produced. This means that each bit-slice yielded must be marked
as aliased. If you are using this in a loop that does not collect
multiple yielded subslices for the same scope, then you can remove the
alias marking by calling the (<code>unsafe</code>) method <a href="struct.RSplitMut.html#method.remove_alias"><code>.remove_alias()</code></a> on
the iterator.</p>
<h6 id="original-36"><a href="#original-36">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.rsplit_mut"><code>slice::rsplit_mut</code></a></p>
<h6 id="api-differences-19"><a href="#api-differences-19">API Differences</a></h6>
<p>The predicate function receives the index being tested as well as the
bit value at that index. This allows the predicate to have more than one
bit of information about the bit-slice being traversed.</p>
<h6 id="sibling-methods-13"><a href="#sibling-methods-13">Sibling Methods</a></h6>
<ul>
<li><a href="struct.BitSlice.html#method.rsplit"><code>.rsplit()</code></a> has the same splitting logic, but each yielded bit-slice
is immutable.</li>
<li><a href="struct.BitSlice.html#method.split_mut"><code>.split_mut()</code></a> iterates from the front of the bit-slice to the back.</li>
<li><a href="struct.BitSlice.html#method.rsplitn_mut"><code>.rsplitn_mut()</code></a> iterates from the front of the bit-slice to the
back.</li>
</ul>
<h6 id="examples-34"><a href="#examples-34">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="comment">//                         ^     ^
</span><span class="kw">for </span>group <span class="kw">in </span>bits.rsplit_mut(|_pos, bit| <span class="kw-2">*</span>bit) {
  group.set(<span class="number">0</span>, <span class="bool-val">true</span>);
}
<span class="macro">assert_eq!</span>(bits, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.splitn" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#1654-1657">source</a><h4 class="code-header">pub fn <a href="#method.splitn" class="fnname">splitn</a>&lt;F&gt;(&amp;self, n: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>, pred: F) -&gt; <a class="struct" href="struct.SplitN.html" title="struct bitvec::slice::SplitN">SplitN</a>&lt;'_, T, O, F&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="struct.SplitN.html" title="struct bitvec::slice::SplitN">SplitN</a>&lt;'a, T, O, P&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, T, O, P&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="struct.SplitN.html" title="struct bitvec::slice::SplitN">SplitN</a>&lt;'a, T, O, P&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a>,</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.66.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &lt;<a class="struct" href="struct.Split.html" title="struct bitvec::slice::Split">Split</a>&lt;'a, T, O, P&gt; as <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.66.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>;</span></code></span></span></span></span><span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a>,</span></h4></section></summary><div class="docblock"><p>Iterates over subslices separated by bits that match a predicate, giving
up after yielding <code>n</code> times. The <code>n</code>th yield contains the rest of the
bit-slice. As with <code>.split()</code>, the yielded bit-slices do not contain the
matched bit.</p>
<h6 id="original-37"><a href="#original-37">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.splitn"><code>slice::splitn</code></a></p>
<h6 id="api-differences-20"><a href="#api-differences-20">API Differences</a></h6>
<p>The predicate function receives the index being tested as well as the
bit value at that index. This allows the predicate to have more than one
bit of information about the bit-slice being traversed.</p>
<h6 id="sibling-methods-14"><a href="#sibling-methods-14">Sibling Methods</a></h6>
<ul>
<li><a href="struct.BitSlice.html#method.splitn_mut"><code>.splitn_mut()</code></a> has the same splitting logic, but each yielded
bit-slice is mutable.</li>
<li><a href="struct.BitSlice.html#method.rsplitn"><code>.rsplitn()</code></a> iterates from the back of the bit-slice instead of the
front.</li>
<li><a href="struct.BitSlice.html#method.split"><code>.split()</code></a> has the same splitting logic, but never times out.</li>
</ul>
<h6 id="examples-35"><a href="#examples-35">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="kw">let </span><span class="kw-2">mut </span>iter = bits.splitn(<span class="number">2</span>, |_pos, bit| <span class="kw-2">*</span>bit);

<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>]);
<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]);
<span class="macro">assert!</span>(iter.next().is_none());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.splitn_mut" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#1706-1709">source</a><h4 class="code-header">pub fn <a href="#method.splitn_mut" class="fnname">splitn_mut</a>&lt;F&gt;(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>, pred: F) -&gt; <a class="struct" href="struct.SplitNMut.html" title="struct bitvec::slice::SplitNMut">SplitNMut</a>&lt;'_, T, O, F&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="struct.SplitNMut.html" title="struct bitvec::slice::SplitNMut">SplitNMut</a>&lt;'a, T, O, P&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, T, O, P&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="struct.SplitNMut.html" title="struct bitvec::slice::SplitNMut">SplitNMut</a>&lt;'a, T, O, P&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a>,</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.66.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &lt;<a class="struct" href="struct.SplitMut.html" title="struct bitvec::slice::SplitMut">SplitMut</a>&lt;'a, T, O, P&gt; as <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.66.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>;</span></code></span></span></span></span><span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a>,</span></h4></section></summary><div class="docblock"><p>Iterates over mutable subslices separated by bits that match a
predicate, giving up after yielding <code>n</code> times. The <code>n</code>th yield contains
the rest of the bit-slice. As with <code>.split_mut()</code>, the yielded
bit-slices do not contain the matched bit.</p>
<p>Iterators do not require that each yielded item is destroyed before the
next is produced. This means that each bit-slice yielded must be marked
as aliased. If you are using this in a loop that does not collect
multiple yielded subslices for the same scope, then you can remove the
alias marking by calling the (<code>unsafe</code>) method <a href="struct.SplitNMut.html#method.remove_alias"><code>.remove_alias()</code></a> on
the iterator.</p>
<h6 id="original-38"><a href="#original-38">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.splitn_mut"><code>slice::splitn_mut</code></a></p>
<h6 id="api-differences-21"><a href="#api-differences-21">API Differences</a></h6>
<p>The predicate function receives the index being tested as well as the
bit value at that index. This allows the predicate to have more than one
bit of information about the bit-slice being traversed.</p>
<h6 id="sibling-methods-15"><a href="#sibling-methods-15">Sibling Methods</a></h6>
<ul>
<li><a href="struct.BitSlice.html#method.splitn"><code>.splitn()</code></a> has the same splitting logic, but each yielded bit-slice
is immutable.</li>
<li><a href="struct.BitSlice.html#method.rsplitn_mut"><code>.rsplitn_mut()</code></a> iterates from the back of the bit-slice instead of
the front.</li>
<li><a href="struct.BitSlice.html#method.split_mut"><code>.split_mut()</code></a> has the same splitting logic, but never times out.</li>
</ul>
<h6 id="examples-36"><a href="#examples-36">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="kw">for </span>group <span class="kw">in </span>bits.splitn_mut(<span class="number">2</span>, |_pos, bit| <span class="kw-2">*</span>bit) {
  group.set(<span class="number">0</span>, <span class="bool-val">true</span>);
}
<span class="macro">assert_eq!</span>(bits, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.rsplitn" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#1752-1755">source</a><h4 class="code-header">pub fn <a href="#method.rsplitn" class="fnname">rsplitn</a>&lt;F&gt;(&amp;self, n: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>, pred: F) -&gt; <a class="struct" href="struct.RSplitN.html" title="struct bitvec::slice::RSplitN">RSplitN</a>&lt;'_, T, O, F&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="struct.RSplitN.html" title="struct bitvec::slice::RSplitN">RSplitN</a>&lt;'a, T, O, P&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, T, O, P&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="struct.RSplitN.html" title="struct bitvec::slice::RSplitN">RSplitN</a>&lt;'a, T, O, P&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a>,</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.66.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &lt;<a class="struct" href="struct.RSplit.html" title="struct bitvec::slice::RSplit">RSplit</a>&lt;'a, T, O, P&gt; as <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.66.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>;</span></code></span></span></span></span><span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a>,</span></h4></section></summary><div class="docblock"><p>Iterates over mutable subslices separated by bits that match a
predicate from the back edge, giving up after yielding <code>n</code> times. The
<code>n</code>th yield contains the rest of the bit-slice. As with <code>.split_mut()</code>,
the yielded bit-slices do not contain the matched bit.</p>
<h6 id="original-39"><a href="#original-39">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.rsplitn"><code>slice::rsplitn</code></a></p>
<h6 id="api-differences-22"><a href="#api-differences-22">API Differences</a></h6>
<p>The predicate function receives the index being tested as well as the
bit value at that index. This allows the predicate to have more than one
bit of information about the bit-slice being traversed.</p>
<h6 id="sibling-methods-16"><a href="#sibling-methods-16">Sibling Methods</a></h6>
<ul>
<li><a href="struct.BitSlice.html#method.rsplitn_mut"><code>.rsplitn_mut()</code></a> has the same splitting logic, but each yielded
bit-slice is mutable.</li>
<li><a href="struct.BitSlice.html#method.splitn"><code>.splitn()</code></a>: iterates from the front of the bit-slice instead of the
back.</li>
<li><a href="struct.BitSlice.html#method.rsplit"><code>.rsplit()</code></a> has the same splitting logic, but never times out.</li>
</ul>
<h6 id="examples-37"><a href="#examples-37">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="comment">//                        ^
</span><span class="kw">let </span><span class="kw-2">mut </span>iter = bits.rsplitn(<span class="number">2</span>, |_pos, bit| <span class="kw-2">*</span>bit);

<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[<span class="number">0</span>]);
<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]);
<span class="macro">assert!</span>(iter.next().is_none());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.rsplitn_mut" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#1805-1808">source</a><h4 class="code-header">pub fn <a href="#method.rsplitn_mut" class="fnname">rsplitn_mut</a>&lt;F&gt;(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>, pred: F) -&gt; <a class="struct" href="struct.RSplitNMut.html" title="struct bitvec::slice::RSplitNMut">RSplitNMut</a>&lt;'_, T, O, F&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="struct.RSplitNMut.html" title="struct bitvec::slice::RSplitNMut">RSplitNMut</a>&lt;'a, T, O, P&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, T, O, P&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="struct.RSplitNMut.html" title="struct bitvec::slice::RSplitNMut">RSplitNMut</a>&lt;'a, T, O, P&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a>,</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.66.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &lt;<a class="struct" href="struct.RSplitMut.html" title="struct bitvec::slice::RSplitMut">RSplitMut</a>&lt;'a, T, O, P&gt; as <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.66.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>;</span></code></span></span></span></span><span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a>,</span></h4></section></summary><div class="docblock"><p>Iterates over mutable subslices separated by bits that match a
predicate from the back edge, giving up after yielding <code>n</code> times. The
<code>n</code>th yield contains the rest of the bit-slice. As with <code>.split_mut()</code>,
the yielded bit-slices do not contain the matched bit.</p>
<p>Iterators do not require that each yielded item is destroyed before the
next is produced. This means that each bit-slice yielded must be marked
as aliased. If you are using this in a loop that does not collect
multiple yielded subslices for the same scope, then you can remove the
alias marking by calling the (<code>unsafe</code>) method <a href="struct.RSplitNMut.html#method.remove_alias"><code>.remove_alias()</code></a> on
the iterator.</p>
<h6 id="original-40"><a href="#original-40">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.rsplitn_mut"><code>slice::rsplitn_mut</code></a></p>
<h6 id="api-differences-23"><a href="#api-differences-23">API Differences</a></h6>
<p>The predicate function receives the index being tested as well as the
bit value at that index. This allows the predicate to have more than one
bit of information about the bit-slice being traversed.</p>
<h6 id="sibling-methods-17"><a href="#sibling-methods-17">Sibling Methods</a></h6>
<ul>
<li><a href="struct.BitSlice.html#method.rsplitn"><code>.rsplitn()</code></a> has the same splitting logic, but each yielded
bit-slice is immutable.</li>
<li><a href="struct.BitSlice.html#method.splitn_mut"><code>.splitn_mut()</code></a> iterates from the front of the bit-slice instead of
the back.</li>
<li><a href="struct.BitSlice.html#method.rsplit_mut"><code>.rsplit_mut()</code></a> has the same splitting logic, but never times out.</li>
</ul>
<h6 id="examples-38"><a href="#examples-38">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="kw">for </span>group <span class="kw">in </span>bits.rsplitn_mut(<span class="number">2</span>, |_idx, bit| <span class="kw-2">*</span>bit) {
  group.set(<span class="number">0</span>, <span class="bool-val">true</span>);
}
<span class="macro">assert_eq!</span>(bits, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]);
<span class="comment">//                     ^ group 2         ^ group 1</span></code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.contains" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#1831-1838">source</a><h4 class="code-header">pub fn <a href="#method.contains" class="fnname">contains</a>&lt;T2, O2&gt;(&amp;self, other: &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T2, O2&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a><span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h4></section></summary><div class="docblock"><p>Tests if the bit-slice contains the given sequence anywhere within it.</p>
<p>This scans over <code>self.windows(other.len())</code> until one of the windows
matches. The search key does not need to share type parameters with the
bit-slice being tested, as the comparison is bit-wise. However, sharing
type parameters will accelerate the comparison.</p>
<h6 id="original-41"><a href="#original-41">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.contains"><code>slice::contains</code></a></p>
<h6 id="examples-39"><a href="#examples-39">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="macro">assert!</span>( bits.contains(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]));
<span class="macro">assert!</span>(!bits.contains(<span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]));</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.starts_with" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#1871-1879">source</a><h4 class="code-header">pub fn <a href="#method.starts_with" class="fnname">starts_with</a>&lt;T2, O2&gt;(&amp;self, needle: &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T2, O2&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a><span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h4></section></summary><div class="docblock"><p>Tests if the bit-slice begins with the given sequence.</p>
<p>The search key does not need to share type parameters with the bit-slice
being tested, as the comparison is bit-wise. However, sharing type
parameters will accelerate the comparison.</p>
<h6 id="original-42"><a href="#original-42">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.starts_with"><code>slice::starts_with</code></a></p>
<h6 id="examples-40"><a href="#examples-40">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="macro">assert!</span>( bits.starts_with(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>]));
<span class="macro">assert!</span>(!bits.starts_with(<span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>]));</code></pre></div>
<p>This always returns <code>true</code> if the needle is empty:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="kw">let </span>empty = <span class="macro">bits!</span>[];
<span class="macro">assert!</span>(bits.starts_with(empty));
<span class="macro">assert!</span>(empty.starts_with(empty));</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.ends_with" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#1912-1920">source</a><h4 class="code-header">pub fn <a href="#method.ends_with" class="fnname">ends_with</a>&lt;T2, O2&gt;(&amp;self, needle: &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T2, O2&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a><span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h4></section></summary><div class="docblock"><p>Tests if the bit-slice ends with the given sequence.</p>
<p>The search key does not need to share type parameters with the bit-slice
being tested, as the comparison is bit-wise. However, sharing type
parameters will accelerate the comparison.</p>
<h6 id="original-43"><a href="#original-43">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.ends_with"><code>slice::ends_with</code></a></p>
<h6 id="examples-41"><a href="#examples-41">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="macro">assert!</span>( bits.ends_with(<span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>]));
<span class="macro">assert!</span>(!bits.ends_with(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>]));</code></pre></div>
<p>This always returns <code>true</code> if the needle is empty:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="kw">let </span>empty = <span class="macro">bits!</span>[];
<span class="macro">assert!</span>(bits.ends_with(empty));
<span class="macro">assert!</span>(empty.ends_with(empty));</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.strip_prefix" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#1951-1965">source</a><h4 class="code-header">pub fn <a href="#method.strip_prefix" class="fnname">strip_prefix</a>&lt;T2, O2&gt;(&amp;self, prefix: &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T2, O2&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.66.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Self&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h4></section></summary><div class="docblock"><p>Removes a prefix bit-slice, if present.</p>
<p>Like <a href="struct.BitSlice.html#method.starts_with"><code>.starts_with()</code></a>, the search key does not need to share type
parameters with the bit-slice being stripped. If
<code>self.starts_with(suffix)</code>, then this returns <code>Some(&amp;self[prefix.len() ..])</code>, otherwise it returns <code>None</code>.</p>
<h6 id="original-44"><a href="#original-44">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.strip_prefix"><code>slice::strip_prefix</code></a></p>
<h6 id="api-differences-24"><a href="#api-differences-24">API Differences</a></h6>
<p><code>BitSlice</code> does not support pattern searches; instead, it permits <code>self</code>
and <code>prefix</code> to differ in type parameters.</p>
<h6 id="examples-42"><a href="#examples-42">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="macro">assert_eq!</span>(bits.strip_prefix(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>]).unwrap(), bits[<span class="number">2 </span>..]);
<span class="macro">assert_eq!</span>(bits.strip_prefix(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>,]).unwrap(), bits[<span class="number">4 </span>..]);
<span class="macro">assert!</span>(bits.strip_prefix(<span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>]).is_none());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.strip_suffix" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#1996-2010">source</a><h4 class="code-header">pub fn <a href="#method.strip_suffix" class="fnname">strip_suffix</a>&lt;T2, O2&gt;(&amp;self, suffix: &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T2, O2&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.66.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Self&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h4></section></summary><div class="docblock"><p>Removes a suffix bit-slice, if present.</p>
<p>Like <a href="Self::ends_with."><code>.ends_with()</code></a>, the search key does not need to share type
parameters with the bit-slice being stripped. If
<code>self.ends_with(suffix)</code>, then this returns <code>Some(&amp;self[.. self.len() - suffix.len()])</code>, otherwise it returns <code>None</code>.</p>
<h6 id="original-45"><a href="#original-45">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.strip_suffix"><code>slice::strip_suffix</code></a></p>
<h6 id="api-differences-25"><a href="#api-differences-25">API Differences</a></h6>
<p><code>BitSlice</code> does not support pattern searches; instead, it permits <code>self</code>
and <code>suffix</code> to differ in type parameters.</p>
<h6 id="examples-43"><a href="#examples-43">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="macro">assert_eq!</span>(bits.strip_suffix(<span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>]).unwrap(), bits[.. <span class="number">7</span>]);
<span class="macro">assert_eq!</span>(bits.strip_suffix(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]).unwrap(), bits[.. <span class="number">5</span>]);
<span class="macro">assert!</span>(bits.strip_suffix(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>]).is_none());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.rotate_left" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#2037-2058">source</a><h4 class="code-header">pub fn <a href="#method.rotate_left" class="fnname">rotate_left</a>(&amp;mut self, by: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Rotates the contents of a bit-slice to the left (towards the zero
index).</p>
<p>This essentially splits the bit-slice at <code>by</code>, then exchanges the two
pieces. <code>self[.. by]</code> becomes the first section, and is then followed by
<code>self[.. by]</code>.</p>
<p>The implementation is batch-accelerated where possible. It should have a
runtime complexity much lower than <code>O(by)</code>.</p>
<h6 id="original-46"><a href="#original-46">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.rotate_left"><code>slice::rotate_left</code></a></p>
<h6 id="examples-44"><a href="#examples-44">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="comment">//      split occurs here ^
</span>bits.rotate_left(<span class="number">2</span>);
<span class="macro">assert_eq!</span>(bits, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.rotate_right" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#2085-2107">source</a><h4 class="code-header">pub fn <a href="#method.rotate_right" class="fnname">rotate_right</a>(&amp;mut self, by: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Rotates the contents of a bit-slice to the right (away from the zero
index).</p>
<p>This essentially splits the bit-slice at <code>self.len() - by</code>, then
exchanges the two pieces. <code>self[len - by ..]</code> becomes the first section,
and is then followed by <code>self[.. len - by]</code>.</p>
<p>The implementation is batch-accelerated where possible. It should have a
runtime complexity much lower than <code>O(by)</code>.</p>
<h6 id="original-47"><a href="#original-47">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.rotate_right"><code>slice::rotate_right</code></a></p>
<h6 id="examples-45"><a href="#examples-45">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="comment">//            split occurs here ^
</span>bits.rotate_right(<span class="number">2</span>);
<span class="macro">assert_eq!</span>(bits, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fill" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#2129-2147">source</a><h4 class="code-header">pub fn <a href="#method.fill" class="fnname">fill</a>(&amp;mut self, value: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a>)</h4></section></summary><div class="docblock"><p>Fills the bit-slice with a given bit.</p>
<p>This is a recent stabilization in the standard library. <code>bitvec</code>
previously offered this behavior as the novel API <code>.set_all()</code>. That
method name is now removed in favor of this standard-library analogue.</p>
<h6 id="original-48"><a href="#original-48">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.fill"><code>slice::fill</code></a></p>
<h6 id="examples-46"><a href="#examples-46">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>; <span class="number">5</span>];
bits.fill(<span class="bool-val">true</span>);
<span class="macro">assert_eq!</span>(bits, <span class="macro">bits!</span>[<span class="number">1</span>; <span class="number">5</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fill_with" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#2170-2177">source</a><h4 class="code-header">pub fn <a href="#method.fill_with" class="fnname">fill_with</a>&lt;F&gt;(&amp;mut self, func: F)<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a>,</span></h4></section></summary><div class="docblock"><p>Fills the bit-slice with bits produced by a generator function.</p>
<h6 id="original-49"><a href="#original-49">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.fill_with"><code>slice::fill_with</code></a></p>
<h6 id="api-differences-26"><a href="#api-differences-26">API Differences</a></h6>
<p>The generator function receives the index of the bit being initialized
as an argument.</p>
<h6 id="examples-47"><a href="#examples-47">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>; <span class="number">5</span>];
bits.fill_with(|idx| idx % <span class="number">2 </span>== <span class="number">0</span>);
<span class="macro">assert_eq!</span>(bits, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]);</code></pre></div>
</div></details><section id="method.clone_from_slice" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#2183-2189">source</a><h4 class="code-header">pub fn <a href="#method.clone_from_slice" class="fnname">clone_from_slice</a>&lt;T2, O2&gt;(&amp;mut self, src: &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T2, O2&gt;)<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated: use <code>.clone_from_bitslice()</code> instead</span></div></span><section id="method.copy_from_slice" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#2195-2197">source</a><h4 class="code-header">pub fn <a href="#method.copy_from_slice" class="fnname">copy_from_slice</a>(&amp;mut self, src: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Self)</h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated: use <code>.copy_from_bitslice()</code> instead</span></div></span><details class="rustdoc-toggle method-toggle" open><summary><section id="method.copy_within" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#2228-2239">source</a><h4 class="code-header">pub fn <a href="#method.copy_within" class="fnname">copy_within</a>&lt;R&gt;(&amp;mut self, src: R, dest: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>)<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;R: <a class="trait" href="../../wyz/range/trait.RangeExt.html" title="trait wyz::range::RangeExt">RangeExt</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>&gt;,</span></h4></section></summary><div class="docblock"><p>Copies a span of bits to another location in the bit-slice.</p>
<p><code>src</code> is the range of bit-indices in the bit-slice to copy, and <code>dest is the starting index of the destination range. </code>src<code>and</code>dest .. dest +
src.len()<code>are permitted to overlap; the copy will automatically detect and manage this. However, both</code>src<code>and</code>dest .. dest + src.len()<code>**must** fall within the bounds of</code>self`.</p>
<h6 id="original-50"><a href="#original-50">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.copy_within"><code>slice::copy_within</code></a></p>
<h6 id="panics-11"><a href="#panics-11">Panics</a></h6>
<p>This panics if either the source or destination range exceed
<code>self.len()</code>.</p>
<h6 id="examples-48"><a href="#examples-48">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>];
bits.copy_within(<span class="number">1 </span>.. <span class="number">5</span>, <span class="number">8</span>);
<span class="comment">//                        v  v  v  v
</span><span class="macro">assert_eq!</span>(bits, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]);
<span class="comment">//                                             ^  ^  ^  ^</span></code></pre></div>
</div></details><section id="method.swap_with_slice" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#2244-2250">source</a><h4 class="code-header">pub fn <a href="#method.swap_with_slice" class="fnname">swap_with_slice</a>&lt;T2, O2&gt;(&amp;mut self, other: &amp;mut <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T2, O2&gt;)<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated: use <code>.swap_with_bitslice()</code> instead</span></div></span><details class="rustdoc-toggle method-toggle" open><summary><section id="method.align_to" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#2294-2302">source</a><h4 class="code-header">pub unsafe fn <a href="#method.align_to" class="fnname">align_to</a>&lt;U&gt;(&amp;self) -&gt; (<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Self, &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;U, O&gt;, <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Self)<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h4></section></summary><div class="docblock"><p>Produces bit-slice view(s) with different underlying storage types.</p>
<p>This may have unexpected effects, and you cannot assume that
<code>before[idx] == after[idx]</code>! Consult the <a href="https://bitvecto-rs.github.io/bitvec/memory-layout.html">tables in the manual</a>
for information about memory layouts.</p>
<h6 id="original-51"><a href="#original-51">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.align_to"><code>slice::align_to</code></a></p>
<h6 id="notes"><a href="#notes">Notes</a></h6>
<p>Unlike the standard library documentation, this explicitly guarantees
that the middle bit-slice will have maximal size. You may rely on this
property.</p>
<h6 id="safety-3"><a href="#safety-3">Safety</a></h6>
<p>You may not use this to cast away alias protections. Rust does not have
support for higher-kinded types, so this cannot express the relation
<code>Outer&lt;T&gt; -&gt; Outer&lt;U&gt; where Outer: BitStoreContainer</code>, but memory safety
does require that you respect this rule. Reälign integers to integers,
<code>Cell</code>s to <code>Cell</code>s, and atomics to atomics, but do not cross these
boundaries.</p>
<h6 id="examples-49"><a href="#examples-49">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bytes: [u8; <span class="number">7</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];
<span class="kw">let </span>bits = bytes.view_bits::&lt;Lsb0&gt;();
<span class="kw">let </span>(pfx, mid, sfx) = <span class="kw">unsafe </span>{
  bits.align_to::&lt;u16&gt;()
};
<span class="macro">assert!</span>(pfx.len() &lt;= <span class="number">8</span>);
<span class="macro">assert_eq!</span>(mid.len(), <span class="number">48</span>);
<span class="macro">assert!</span>(sfx.len() &lt;= <span class="number">8</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.align_to_mut" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#2346-2356">source</a><h4 class="code-header">pub unsafe fn <a href="#method.align_to_mut" class="fnname">align_to_mut</a>&lt;U&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self<br>) -&gt; (<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;mut </a>Self, &amp;mut <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;U, O&gt;, <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;mut </a>Self)<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h4></section></summary><div class="docblock"><p>Produces bit-slice view(s) with different underlying storage types.</p>
<p>This may have unexpected effects, and you cannot assume that
<code>before[idx] == after[idx]</code>! Consult the <a href="https://bitvecto-rs.github.io/bitvec/memory-layout.html">tables in the manual</a>
for information about memory layouts.</p>
<h6 id="original-52"><a href="#original-52">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.align_to_mut"><code>slice::align_to_mut</code></a></p>
<h6 id="notes-1"><a href="#notes-1">Notes</a></h6>
<p>Unlike the standard library documentation, this explicitly guarantees
that the middle bit-slice will have maximal size. You may rely on this
property.</p>
<h6 id="safety-4"><a href="#safety-4">Safety</a></h6>
<p>You may not use this to cast away alias protections. Rust does not have
support for higher-kinded types, so this cannot express the relation
<code>Outer&lt;T&gt; -&gt; Outer&lt;U&gt; where Outer: BitStoreContainer</code>, but memory safety
does require that you respect this rule. Reälign integers to integers,
<code>Cell</code>s to <code>Cell</code>s, and atomics to atomics, but do not cross these
boundaries.</p>
<h6 id="examples-50"><a href="#examples-50">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bytes: [u8; <span class="number">7</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];
<span class="kw">let </span>bits = bytes.view_bits_mut::&lt;Lsb0&gt;();
<span class="kw">let </span>(pfx, mid, sfx) = <span class="kw">unsafe </span>{
  bits.align_to_mut::&lt;u16&gt;()
};
<span class="macro">assert!</span>(pfx.len() &lt;= <span class="number">8</span>);
<span class="macro">assert_eq!</span>(mid.len(), <span class="number">48</span>);
<span class="macro">assert!</span>(sfx.len() &lt;= <span class="number">8</span>);</code></pre></div>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BitSlice%3CT%2C%20O%3E-1" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#2360-2417">source</a><a href="#impl-BitSlice%3CT%2C%20O%3E-1" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="impl-items"><section id="method.to_vec" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#2368-2370">source</a><h4 class="code-header">pub fn <a href="#method.to_vec" class="fnname">to_vec</a>(&amp;self) -&gt; <a class="struct" href="../vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Unalias" title="type bitvec::store::BitStore::Unalias">Unalias</a>, O&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;T, O&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/std/io/trait.Read.html" title="trait std::io::Read">Read</a> for <a class="struct" href="../vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,</span></span><span class="where fmt-newline">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/std/io/trait.Write.html" title="trait std::io::Write">Write</a> for <a class="struct" href="../vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,</span></span></code></span></span></span></span></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated: use <code>.to_bitvec()</code> instead</span></div></span><details class="rustdoc-toggle method-toggle" open><summary><section id="method.repeat" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#2398-2410">source</a><h4 class="code-header">pub fn <a href="#method.repeat" class="fnname">repeat</a>(&amp;self, n: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Unalias" title="type bitvec::store::BitStore::Unalias">Unalias</a>, O&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;T, O&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/std/io/trait.Read.html" title="trait std::io::Read">Read</a> for <a class="struct" href="../vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,</span></span><span class="where fmt-newline">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/std/io/trait.Write.html" title="trait std::io::Write">Write</a> for <a class="struct" href="../vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,</span></span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Creates a bit-vector by repeating a bit-slice <code>n</code> times.</p>
<h6 id="original-53"><a href="#original-53">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.repeat"><code>slice::repeat</code></a></p>
<h6 id="panics-12"><a href="#panics-12">Panics</a></h6>
<p>This method panics if <code>self.len() * n</code> exceeds the <code>BitVec</code> capacity.</p>
<h6 id="examples-51"><a href="#examples-51">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>].repeat(<span class="number">3</span>), <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]);</code></pre></div>
<p>This panics by exceeding bit-vector maximum capacity:</p>

<div class="example-wrap should_panic"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>].repeat(BitSlice::&lt;usize, Lsb0&gt;::MAX_BITS);</code></pre></div>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BitSlice%3CT%2C%20O%3E-2" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#89-430">source</a><a href="#impl-BitSlice%3CT%2C%20O%3E-2" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="docblock"><p>Constructors.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.empty" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#109-111">source</a><h4 class="code-header">pub fn <a href="#method.empty" class="fnname">empty</a>&lt;'a&gt;() -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;'a </a>Self</h4></section></summary><div class="docblock"><p>Produces an empty bit-slice with an arbitrary lifetime.</p>
<h6 id="original-54"><a href="#original-54">Original</a></h6>
<p>This is equivalent to the <code>&amp;[]</code> literal.</p>
<h6 id="examples-52"><a href="#examples-52">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="macro">assert!</span>(BitSlice::&lt;u16, LocalBits&gt;::empty().is_empty());
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[], BitSlice::&lt;u8, Msb0&gt;::empty());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.empty_mut" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#128-130">source</a><h4 class="code-header">pub fn <a href="#method.empty_mut" class="fnname">empty_mut</a>&lt;'a&gt;() -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;'a mut </a>Self</h4></section></summary><div class="docblock"><p>Produces an empty bit-slice with an arbitrary lifetime.</p>
<h6 id="original-55"><a href="#original-55">Original</a></h6>
<p>This is equivalent to the <code>&amp;mut []</code> literal.</p>
<h6 id="examples-53"><a href="#examples-53">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="macro">assert!</span>(BitSlice::&lt;u16, LocalBits&gt;::empty_mut().is_empty());
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="kw-2">mut</span>], BitSlice::&lt;u8, Msb0&gt;::empty_mut());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from_element" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#162-168">source</a><h4 class="code-header">pub fn <a href="#method.from_element" class="fnname">from_element</a>(elem: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>T) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Self</h4></section></summary><div class="docblock"><p>Constructs a shared <code>&amp;BitSlice</code> reference over a shared element.</p>
<p>The <a href="../view/trait.BitView.html"><code>BitView</code></a> trait, implemented on all <a href="../store/trait.BitStore.html"><code>BitStore</code></a> implementors,
provides a <a href="../view/trait.BitView.html#tymethod.view_bits"><code>.view_bits::&lt;O&gt;()</code></a> method which delegates to this function
and may be more convenient for you to write.</p>
<h6 id="parameters"><a href="#parameters">Parameters</a></h6>
<ul>
<li><code>elem</code>: A shared reference to a memory element.</li>
</ul>
<h6 id="returns"><a href="#returns">Returns</a></h6>
<p>A shared <code>&amp;BitSlice</code> over <code>elem</code>.</p>
<h6 id="examples-54"><a href="#examples-54">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>elem = <span class="number">0u8</span>;
<span class="kw">let </span>bits = BitSlice::&lt;<span class="kw">_</span>, Lsb0&gt;::from_element(<span class="kw-2">&amp;</span>elem);
<span class="macro">assert_eq!</span>(bits.len(), <span class="number">8</span>);

<span class="kw">let </span>bits = elem.view_bits::&lt;Lsb0&gt;();</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from_element_mut" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#205-211">source</a><h4 class="code-header">pub fn <a href="#method.from_element_mut" class="fnname">from_element_mut</a>(elem: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;mut </a>T) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;mut </a>Self</h4></section></summary><div class="docblock"><p>Constructs an exclusive <code>&amp;mut BitSlice</code> reference over an element.</p>
<p>The <a href="../view/trait.BitView.html"><code>BitView</code></a> trait, implemented on all <a href="../store/trait.BitStore.html"><code>BitStore</code></a> implementors,
provides a <a href="../view/trait.BitView.html#tymethod.view_bits_mut"><code>.view_bits_mut::&lt;O&gt;()</code></a> method which delegates to this
function and may be more convenient for you to write.</p>
<h6 id="parameters-1"><a href="#parameters-1">Parameters</a></h6>
<ul>
<li><code>elem</code>: An exclusive reference to a memory element.</li>
</ul>
<h6 id="returns-1"><a href="#returns-1">Returns</a></h6>
<p>An exclusive <code>&amp;mut BitSlice</code> over <code>elem</code>.</p>
<p>Note that the original <code>elem</code> reference will be inaccessible for the
duration of the returned bit-slice handle’s lifetime.</p>
<h6 id="examples-55"><a href="#examples-55">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>elem = <span class="number">0u8</span>;
<span class="kw">let </span>bits = BitSlice::&lt;<span class="kw">_</span>, Lsb0&gt;::from_element_mut(<span class="kw-2">&amp;mut </span>elem);
bits.set(<span class="number">1</span>, <span class="bool-val">true</span>);
<span class="macro">assert!</span>(bits[<span class="number">1</span>]);
<span class="macro">assert_eq!</span>(elem, <span class="number">2</span>);

<span class="kw">let </span>bits = elem.view_bits_mut::&lt;Lsb0&gt;();</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from_slice" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#246-248">source</a><h4 class="code-header">pub fn <a href="#method.from_slice" class="fnname">from_slice</a>(slice: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.slice.html">[T]</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Self</h4></section></summary><div class="docblock"><p>Constructs a shared <code>&amp;BitSlice</code> reference over a slice of elements.</p>
<p>The <a href="../view/trait.BitView.html"><code>BitView</code></a> trait, implemented on all <code>[T]</code> slices, provides a
<a href="../view/trait.BitView.html#tymethod.view_bits"><code>.view_bits::&lt;O&gt;()</code></a> method which delegates to this function and may be
more convenient for you to write.</p>
<h6 id="parameters-2"><a href="#parameters-2">Parameters</a></h6>
<ul>
<li><code>slice</code>: A shared reference to a slice of memory elements.</li>
</ul>
<h6 id="returns-2"><a href="#returns-2">Returns</a></h6>
<p>A shared <code>BitSlice</code> reference over all of <code>slice</code>.</p>
<h6 id="panics-13"><a href="#panics-13">Panics</a></h6>
<p>This will panic if <code>slice</code> is too long to encode as a bit-slice view.</p>
<h6 id="examples-56"><a href="#examples-56">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>data = [<span class="number">0u16</span>, <span class="number">1</span>];
<span class="kw">let </span>bits = BitSlice::&lt;<span class="kw">_</span>, Lsb0&gt;::from_slice(<span class="kw-2">&amp;</span>data);
<span class="macro">assert!</span>(bits[<span class="number">16</span>]);

<span class="kw">let </span>bits = data.view_bits::&lt;Lsb0&gt;();</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.try_from_slice" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#286-296">source</a><h4 class="code-header">pub fn <a href="#method.try_from_slice" class="fnname">try_from_slice</a>(slice: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.slice.html">[T]</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.66.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Self, <a class="enum" href="../ptr/enum.BitSpanError.html" title="enum bitvec::ptr::BitSpanError">BitSpanError</a>&lt;T&gt;&gt;</h4></section></summary><div class="docblock"><p>Attempts to construct a shared <code>&amp;BitSlice</code> reference over a slice of
elements.</p>
<p>The <a href="../view/trait.BitView.html"><code>BitView</code></a>, implemented on all <code>[T]</code> slices, provides a
<a href="../view/trait.BitView.html#tymethod.try_view_bits"><code>.try_view_bits::&lt;O&gt;()</code></a> method which delegates to this function and
may be more convenient for you to write.</p>
<p>This is <em>very hard</em>, if not impossible, to cause to fail. Rust will not
create excessive arrays on 64-bit architectures.</p>
<h6 id="parameters-3"><a href="#parameters-3">Parameters</a></h6>
<ul>
<li><code>slice</code>: A shared reference to a slice of memory elements.</li>
</ul>
<h6 id="returns-3"><a href="#returns-3">Returns</a></h6>
<p>A shared <code>&amp;BitSlice</code> over <code>slice</code>. If <code>slice</code> is longer than can be
encoded into a <code>&amp;BitSlice</code> (see <a href="struct.BitSlice.html#associatedconstant.MAX_ELTS"><code>MAX_ELTS</code></a>), this will fail and return
the original <code>slice</code> as an error.</p>
<h6 id="examples-57"><a href="#examples-57">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>data = [<span class="number">0u8</span>, <span class="number">1</span>];
<span class="kw">let </span>bits = BitSlice::&lt;<span class="kw">_</span>, Msb0&gt;::try_from_slice(<span class="kw-2">&amp;</span>data).unwrap();
<span class="macro">assert!</span>(bits[<span class="number">15</span>]);

<span class="kw">let </span>bits = data.try_view_bits::&lt;Msb0&gt;().unwrap();</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from_slice_mut" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#334-336">source</a><h4 class="code-header">pub fn <a href="#method.from_slice_mut" class="fnname">from_slice_mut</a>(slice: &amp;mut <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.slice.html">[T]</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;mut </a>Self</h4></section></summary><div class="docblock"><p>Constructs an exclusive <code>&amp;mut BitSlice</code> reference over a slice of
elements.</p>
<p>The <a href="../view/trait.BitView.html"><code>BitView</code></a> trait, implemented on all <code>[T]</code> slices, provides a
<a href="../view/trait.BitView.html#tymethod.view_bits_mut"><code>.view_bits_mut::&lt;O&gt;()</code></a> method which delegates to this function and
may be more convenient for you to write.</p>
<h6 id="parameters-4"><a href="#parameters-4">Parameters</a></h6>
<ul>
<li><code>slice</code>: An exclusive reference to a slice of memory elements.</li>
</ul>
<h6 id="returns-4"><a href="#returns-4">Returns</a></h6>
<p>An exclusive <code>&amp;mut BitSlice</code> over all of <code>slice</code>.</p>
<h6 id="panics-14"><a href="#panics-14">Panics</a></h6>
<p>This panics if <code>slice</code> is too long to encode as a bit-slice view.</p>
<h6 id="examples-58"><a href="#examples-58">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>data = [<span class="number">0u16</span>; <span class="number">2</span>];
<span class="kw">let </span>bits = BitSlice::&lt;<span class="kw">_</span>, Lsb0&gt;::from_slice_mut(<span class="kw-2">&amp;mut </span>data);
bits.set(<span class="number">0</span>, <span class="bool-val">true</span>);
bits.set(<span class="number">17</span>, <span class="bool-val">true</span>);
<span class="macro">assert_eq!</span>(data, [<span class="number">1</span>, <span class="number">2</span>]);

<span class="kw">let </span>bits = data.view_bits_mut::&lt;Lsb0&gt;();</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.try_from_slice_mut" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#373-385">source</a><h4 class="code-header">pub fn <a href="#method.try_from_slice_mut" class="fnname">try_from_slice_mut</a>(slice: &amp;mut <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.slice.html">[T]</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.66.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;mut </a>Self, <a class="enum" href="../ptr/enum.BitSpanError.html" title="enum bitvec::ptr::BitSpanError">BitSpanError</a>&lt;T&gt;&gt;</h4></section></summary><div class="docblock"><p>Attempts to construct an exclusive <code>&amp;mut BitSlice</code> reference over a
slice of elements.</p>
<p>The <a href="../view/trait.BitView.html"><code>BitView</code></a> trait, implemented on all <code>[T]</code> slices, provides a
<a href="../view/trait.BitView.html#tymethod.try_view_bits_mut"><code>.try_view_bits_mut::&lt;O&gt;()</code></a> method which delegates to this function
and may be more convenient for you to write.</p>
<h6 id="parameters-5"><a href="#parameters-5">Parameters</a></h6>
<ul>
<li><code>slice</code>: An exclusive reference to a slice of memory elements.</li>
</ul>
<h6 id="returns-5"><a href="#returns-5">Returns</a></h6>
<p>An exclusive <code>&amp;mut BitSlice</code> over <code>slice</code>. If <code>slice</code> is longer than can
be encoded into a <code>&amp;mut BitSlice</code> (see <a href="struct.BitSlice.html#associatedconstant.MAX_ELTS"><code>MAX_ELTS</code></a>), this will fail and
return the original <code>slice</code> as an error.</p>
<h6 id="examples-59"><a href="#examples-59">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>data = [<span class="number">0u8</span>; <span class="number">2</span>];
<span class="kw">let </span>bits = BitSlice::&lt;<span class="kw">_</span>, Msb0&gt;::try_from_slice_mut(<span class="kw-2">&amp;mut </span>data).unwrap();
bits.set(<span class="number">7</span>, <span class="bool-val">true</span>);
bits.set(<span class="number">15</span>, <span class="bool-val">true</span>);
<span class="macro">assert_eq!</span>(data, [<span class="number">1</span>; <span class="number">2</span>]);

<span class="kw">let </span>bits = data.try_view_bits_mut::&lt;Msb0&gt;().unwrap();</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from_slice_unchecked" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#402-407">source</a><h4 class="code-header">pub unsafe fn <a href="#method.from_slice_unchecked" class="fnname">from_slice_unchecked</a>(slice: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.slice.html">[T]</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Self</h4></section></summary><div class="docblock"><p>Constructs a shared <code>&amp;BitSlice</code> over an element slice, without checking
its length.</p>
<p>If <code>slice</code> is too long to encode into a <code>&amp;BitSlice</code>, then the produced
bit-slice’s length is unspecified.</p>
<h6 id="safety-5"><a href="#safety-5">Safety</a></h6>
<p>You must ensure that <code>slice.len() &lt; BitSlice::MAX_ELTS</code>.</p>
<p>Calling this function with an over-long slice is <strong>library-level</strong>
undefined behavior. You may not assume anything about its implementation
or behavior, and must conservatively assume that over-long slices cause
compiler UB.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from_slice_unchecked_mut" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#424-429">source</a><h4 class="code-header">pub unsafe fn <a href="#method.from_slice_unchecked_mut" class="fnname">from_slice_unchecked_mut</a>(slice: &amp;mut <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.slice.html">[T]</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;mut </a>Self</h4></section></summary><div class="docblock"><p>Constructs an exclusive <code>&amp;mut BitSlice</code> over an element slice, without
checking its length.</p>
<p>If <code>slice</code> is too long to encode into a <code>&amp;mut BitSlice</code>, then the
produced bit-slice’s length is unspecified.</p>
<h6 id="safety-6"><a href="#safety-6">Safety</a></h6>
<p>You must ensure that <code>slice.len() &lt; BitSlice::MAX_ELTS</code>.</p>
<p>Calling this function with an over-long slice is <strong>library-level</strong>
undefined behavior. You may not assume anything about its implementation
or behavior, and must conservatively assume that over-long slices cause
compiler UB.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BitSlice%3CT%2C%20O%3E-3" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#433-718">source</a><a href="#impl-BitSlice%3CT%2C%20O%3E-3" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="docblock"><p>Alternates of standard APIs.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_bitptr" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#449-451">source</a><h4 class="code-header">pub fn <a href="#method.as_bitptr" class="fnname">as_bitptr</a>(&amp;self) -&gt; <a class="struct" href="../ptr/struct.BitPtr.html" title="struct bitvec::ptr::BitPtr">BitPtr</a>&lt;<a class="struct" href="../ptr/struct.Const.html" title="struct bitvec::ptr::Const">Const</a>, T, O&gt;</h4></section></summary><div class="docblock"><p>Gets a raw pointer to the zeroth bit of the bit-slice.</p>
<h6 id="original-56"><a href="#original-56">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.as_ptr"><code>slice::as_ptr</code></a></p>
<h6 id="api-differences-27"><a href="#api-differences-27">API Differences</a></h6>
<p>This is renamed in order to indicate that it is returning a <code>bitvec</code>
structure, not a raw pointer.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_mut_bitptr" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#464-466">source</a><h4 class="code-header">pub fn <a href="#method.as_mut_bitptr" class="fnname">as_mut_bitptr</a>(&amp;mut self) -&gt; <a class="struct" href="../ptr/struct.BitPtr.html" title="struct bitvec::ptr::BitPtr">BitPtr</a>&lt;<a class="struct" href="../ptr/struct.Mut.html" title="struct bitvec::ptr::Mut">Mut</a>, T, O&gt;</h4></section></summary><div class="docblock"><p>Gets a raw, write-capable pointer to the zeroth bit of the bit-slice.</p>
<h6 id="original-57"><a href="#original-57">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.as_mut_ptr"><code>slice::as_mut_ptr</code></a></p>
<h6 id="api-differences-28"><a href="#api-differences-28">API Differences</a></h6>
<p>This is renamed in order to indicate that it is returning a <code>bitvec</code>
structure, not a raw pointer.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_bitptr_range" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#488-490">source</a><h4 class="code-header">pub fn <a href="#method.as_bitptr_range" class="fnname">as_bitptr_range</a>(&amp;self) -&gt; <a class="struct" href="../ptr/struct.BitPtrRange.html" title="struct bitvec::ptr::BitPtrRange">BitPtrRange</a>&lt;<a class="struct" href="../ptr/struct.Const.html" title="struct bitvec::ptr::Const">Const</a>, T, O&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../ptr/struct.BitPtrRange.html" title="struct bitvec::ptr::BitPtrRange">BitPtrRange</a>&lt;M, T, O&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;M, T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../ptr/struct.BitPtrRange.html" title="struct bitvec::ptr::BitPtrRange">BitPtrRange</a>&lt;M, T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M: <a class="trait" href="../ptr/trait.Mutability.html" title="trait bitvec::ptr::Mutability">Mutability</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.66.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = <a class="struct" href="../ptr/struct.BitPtr.html" title="struct bitvec::ptr::BitPtr">BitPtr</a>&lt;M, T, O&gt;;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Views the bit-slice as a half-open range of bit-pointers, to its first
bit <em>in</em> the bit-slice and first bit <em>beyond</em> it.</p>
<h6 id="original-58"><a href="#original-58">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.as_ptr_range"><code>slice::as_ptr_range</code></a></p>
<h6 id="api-differences-29"><a href="#api-differences-29">API Differences</a></h6>
<p>This is renamed to indicate that it returns a <code>bitvec</code> structure, rather
than an ordinary <code>Range</code>.</p>
<h6 id="notes-2"><a href="#notes-2">Notes</a></h6>
<p><code>BitSlice</code> does define a <a href="struct.BitSlice.html#method.as_ptr_range"><code>.as_ptr_range()</code></a>, which returns a
<code>Range&lt;BitPtr&gt;</code>. <code>BitPtrRange</code> has additional capabilities that
<code>Range&lt;*const T&gt;</code> and <code>Range&lt;BitPtr&gt;</code> do not.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_mut_bitptr_range" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#510-512">source</a><h4 class="code-header">pub fn <a href="#method.as_mut_bitptr_range" class="fnname">as_mut_bitptr_range</a>(&amp;mut self) -&gt; <a class="struct" href="../ptr/struct.BitPtrRange.html" title="struct bitvec::ptr::BitPtrRange">BitPtrRange</a>&lt;<a class="struct" href="../ptr/struct.Mut.html" title="struct bitvec::ptr::Mut">Mut</a>, T, O&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../ptr/struct.BitPtrRange.html" title="struct bitvec::ptr::BitPtrRange">BitPtrRange</a>&lt;M, T, O&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;M, T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../ptr/struct.BitPtrRange.html" title="struct bitvec::ptr::BitPtrRange">BitPtrRange</a>&lt;M, T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M: <a class="trait" href="../ptr/trait.Mutability.html" title="trait bitvec::ptr::Mutability">Mutability</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.66.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = <a class="struct" href="../ptr/struct.BitPtr.html" title="struct bitvec::ptr::BitPtr">BitPtr</a>&lt;M, T, O&gt;;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Views the bit-slice as a half-open range of write-capable bit-pointers,
to its first bit <em>in</em> the bit-slice and the first bit <em>beyond</em> it.</p>
<h6 id="original-59"><a href="#original-59">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.as_mut_ptr_range"><code>slice::as_mut_ptr_range</code></a></p>
<h6 id="api-differences-30"><a href="#api-differences-30">API Differences</a></h6>
<p>This is renamed to indicate that it returns a <code>bitvec</code> structure, rather
than an ordinary <code>Range</code>.</p>
<h6 id="notes-3"><a href="#notes-3">Notes</a></h6>
<p><code>BitSlice</code> does define a [<code>.as_mut_ptr_range()</code>], which returns a
<code>Range&lt;BitPtr&gt;</code>. <code>BitPtrRange</code> has additional capabilities that
<code>Range&lt;*mut T&gt;</code> and <code>Range&lt;BitPtr&gt;</code> do not.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.clone_from_bitslice" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#552-576">source</a><h4 class="code-header">pub fn <a href="#method.clone_from_bitslice" class="fnname">clone_from_bitslice</a>&lt;T2, O2&gt;(&amp;mut self, src: &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T2, O2&gt;)<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h4></section></summary><div class="docblock"><p>Copies the bits from <code>src</code> into <code>self</code>.</p>
<p><code>self</code> and <code>src</code> must have the same length.</p>
<h6 id="performance-1"><a href="#performance-1">Performance</a></h6>
<p>If <code>src</code> has the same type arguments as <code>self</code>, it will use the same
implementation as <a href="struct.BitSlice.html#method.copy_from_bitslice"><code>.copy_from_bitslice()</code></a>; if you know that this will
always be the case, you should prefer to use that method directly.</p>
<p>Only <code>.copy_from_bitslice()</code> is <em>able</em> to perform acceleration; this
method is <em>always</em> required to perform a bit-by-bit crawl over both
bit-slices.</p>
<h6 id="original-60"><a href="#original-60">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.clone_from_slice"><code>slice::clone_from_slice</code></a></p>
<h6 id="api-differences-31"><a href="#api-differences-31">API Differences</a></h6>
<p>This is renamed to reflect that it copies from another bit-slice, not
from an element slice.</p>
<p>In order to support general usage, it allows <code>src</code> to have different
type parameters than <code>self</code>, at the cost of performance optimizations.</p>
<h6 id="panics-15"><a href="#panics-15">Panics</a></h6>
<p>This panics if the two bit-slices have different lengths.</p>
<h6 id="examples-60"><a href="#examples-60">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.copy_from_bitslice" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#597-654">source</a><h4 class="code-header">pub fn <a href="#method.copy_from_bitslice" class="fnname">copy_from_bitslice</a>(&amp;mut self, src: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Self)</h4></section></summary><div class="docblock"><p>Copies all bits from <code>src</code> into <code>self</code>, using batched acceleration when
possible.</p>
<p><code>self</code> and <code>src</code> must have the same length.</p>
<h6 id="original-61"><a href="#original-61">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.copy_from_slice"><code>slice::copy_from_slice</code></a></p>
<h6 id="panics-16"><a href="#panics-16">Panics</a></h6>
<p>This panics if the two bit-slices have different lengths.</p>
<h6 id="examples-61"><a href="#examples-61">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.swap_with_bitslice" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#691-717">source</a><h4 class="code-header">pub fn <a href="#method.swap_with_bitslice" class="fnname">swap_with_bitslice</a>&lt;T2, O2&gt;(&amp;mut self, other: &amp;mut <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T2, O2&gt;)<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h4></section></summary><div class="docblock"><p>Swaps the contents of two bit-slices.</p>
<p><code>self</code> and <code>other</code> must have the same length.</p>
<h6 id="original-62"><a href="#original-62">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.swap_with_slice"><code>slice::swap_with_slice</code></a></p>
<h6 id="api-differences-32"><a href="#api-differences-32">API Differences</a></h6>
<p>This method is renamed, as it takes a bit-slice rather than an element
slice.</p>
<h6 id="panics-17"><a href="#panics-17">Panics</a></h6>
<p>This panics if the two bit-slices have different lengths.</p>
<h6 id="examples-62"><a href="#examples-62">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>one = [<span class="number">0xA5u8</span>, <span class="number">0x69</span>];
<span class="kw">let </span><span class="kw-2">mut </span>two = <span class="number">0x1234u16</span>;
<span class="kw">let </span>one_bits = one.view_bits_mut::&lt;Msb0&gt;();
<span class="kw">let </span>two_bits = two.view_bits_mut::&lt;Lsb0&gt;();

one_bits.swap_with_bitslice(two_bits);

<span class="macro">assert_eq!</span>(one, [<span class="number">0x2C</span>, <span class="number">0x48</span>]);
<span class="macro">assert_eq!</span>(two, <span class="number">0x96A5</span>);</code></pre></div>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BitSlice%3CT%2C%20O%3E-4" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#721-983">source</a><a href="#impl-BitSlice%3CT%2C%20O%3E-4" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="docblock"><p>Extensions of standard APIs.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.set" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#753-755">source</a><h4 class="code-header">pub fn <a href="#method.set" class="fnname">set</a>(&amp;mut self, index: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>, value: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a>)</h4></section></summary><div class="docblock"><p>Writes a new value into a single bit.</p>
<p>This is the replacement for <code>*slice[index] = value;</code>, as <code>bitvec</code> is not
able to express that under the current <code>IndexMut</code> API signature.</p>
<h6 id="parameters-6"><a href="#parameters-6">Parameters</a></h6>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>index</code>: The bit-index to set. It must be in <code>0 .. self.len()</code>.</li>
<li><code>value</code>: The new bit-value to write into the bit at <code>index</code>.</li>
</ul>
<h6 id="panics-18"><a href="#panics-18">Panics</a></h6>
<p>This panics if <code>index</code> is out of bounds.</p>
<h6 id="examples-63"><a href="#examples-63">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>, <span class="number">1</span>];
bits.set(<span class="number">0</span>, <span class="bool-val">true</span>);
bits.set(<span class="number">1</span>, <span class="bool-val">false</span>);

<span class="macro">assert_eq!</span>(bits, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.set_unchecked" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#787-789">source</a><h4 class="code-header">pub unsafe fn <a href="#method.set_unchecked" class="fnname">set_unchecked</a>(&amp;mut self, index: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>, value: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a>)</h4></section></summary><div class="docblock"><p>Writes a new value into a single bit, without bounds checking.</p>
<h6 id="parameters-7"><a href="#parameters-7">Parameters</a></h6>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>index</code>: The bit-index to set. It must be in <code>0 .. self.len()</code>.</li>
<li><code>value</code>: The new bit-value to write into the bit at <code>index</code>.</li>
</ul>
<h6 id="safety-7"><a href="#safety-7">Safety</a></h6>
<p>You must ensure that <code>index</code> is in the range <code>0 .. self.len()</code>.</p>
<p>This performs bit-pointer offset arithmetic without doing any bounds
checks. If <code>index</code> is out of bounds, then this will issue an
out-of-bounds access and will trigger memory unsafety.</p>
<h6 id="examples-64"><a href="#examples-64">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>data = <span class="number">0u8</span>;
<span class="kw">let </span>bits = <span class="kw-2">&amp;mut </span>data.view_bits_mut::&lt;Lsb0&gt;()[.. <span class="number">2</span>];
<span class="macro">assert_eq!</span>(bits.len(), <span class="number">2</span>);
<span class="kw">unsafe </span>{
  bits.set_unchecked(<span class="number">3</span>, <span class="bool-val">true</span>);
}
<span class="macro">assert_eq!</span>(data, <span class="number">8</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.replace" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#807-810">source</a><h4 class="code-header">pub fn <a href="#method.replace" class="fnname">replace</a>(&amp;mut self, index: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>, value: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Writes a new value into a bit, and returns its previous value.</p>
<h6 id="panics-19"><a href="#panics-19">Panics</a></h6>
<p>This panics if <code>index</code> is not less than <code>self.len()</code>.</p>
<h6 id="examples-65"><a href="#examples-65">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>];
<span class="macro">assert!</span>(!bits.replace(<span class="number">0</span>, <span class="bool-val">true</span>));
<span class="macro">assert!</span>(bits[<span class="number">0</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.replace_unchecked" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#833-839">source</a><h4 class="code-header">pub unsafe fn <a href="#method.replace_unchecked" class="fnname">replace_unchecked</a>(&amp;mut self, index: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>, value: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Writes a new value into a bit, returning the previous value, without
bounds checking.</p>
<h6 id="safety-8"><a href="#safety-8">Safety</a></h6>
<p><code>index</code> must be less than <code>self.len()</code>.</p>
<h6 id="examples-66"><a href="#examples-66">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>, <span class="number">0</span>];
<span class="kw">let </span>old = <span class="kw">unsafe </span>{
  <span class="kw">let </span>a = <span class="kw-2">&amp;mut </span>bits[.. <span class="number">1</span>];
  a.replace_unchecked(<span class="number">1</span>, <span class="bool-val">true</span>)
};
<span class="macro">assert!</span>(!old);
<span class="macro">assert!</span>(bits[<span class="number">1</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.swap_unchecked" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#856-860">source</a><h4 class="code-header">pub unsafe fn <a href="#method.swap_unchecked" class="fnname">swap_unchecked</a>(&amp;mut self, a: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>, b: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Swaps two bits in a bit-slice, without bounds checking.</p>
<p>See <a href="struct.BitSlice.html#method.swap"><code>.swap()</code></a> for documentation.</p>
<h6 id="safety-9"><a href="#safety-9">Safety</a></h6>
<p>You must ensure that <code>a</code> and <code>b</code> are both in the range <code>0 .. self.len()</code>.</p>
<p>This method performs bit-pointer offset arithmetic without doing any
bounds checks. If <code>a</code> or <code>b</code> are out of bounds, then this will issue an
out-of-bounds access and will trigger memory unsafety.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.split_at_unchecked" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#877-886">source</a><h4 class="code-header">pub unsafe fn <a href="#method.split_at_unchecked" class="fnname">split_at_unchecked</a>(&amp;self, mid: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>) -&gt; (<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Self, <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Self)</h4></section></summary><div class="docblock"><p>Splits a bit-slice at an index, without bounds checking.</p>
<p>See <a href="struct.BitSlice.html#method.split_at"><code>.split_at()</code></a> for documentation.</p>
<h6 id="safety-10"><a href="#safety-10">Safety</a></h6>
<p>You must ensure that <code>mid</code> is in the range <code>0 ..= self.len()</code>.</p>
<p>This method produces new bit-slice references. If <code>mid</code> is out of
bounds, its behavior is <strong>library-level</strong> undefined. You must
conservatively assume that an out-of-bounds split point produces
compiler-level UB.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.split_at_unchecked_mut" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#903-914">source</a><h4 class="code-header">pub unsafe fn <a href="#method.split_at_unchecked_mut" class="fnname">split_at_unchecked_mut</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self,<br>&nbsp;&nbsp;&nbsp;&nbsp;mid: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a><br>) -&gt; (&amp;mut <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>, O&gt;, &amp;mut <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>, O&gt;)</h4></section></summary><div class="docblock"><p>Splits a mutable bit-slice at an index, without bounds checking.</p>
<p>See <a href="struct.BitSlice.html#method.split_at_mut"><code>.split_at_mut()</code></a> for documentation.</p>
<h6 id="safety-11"><a href="#safety-11">Safety</a></h6>
<p>You must ensure that <code>mid</code> is in the range <code>0 ..= self.len()</code>.</p>
<p>This method produces new bit-slice references. If <code>mid</code> is out of
bounds, its behavior is <strong>library-level</strong> undefined. You must
conservatively assume that an out-of-bounds split point produces
compiler-level UB.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.copy_within_unchecked" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#950-970">source</a><h4 class="code-header">pub unsafe fn <a href="#method.copy_within_unchecked" class="fnname">copy_within_unchecked</a>&lt;R&gt;(&amp;mut self, src: R, dest: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>)<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;R: <a class="trait" href="../../wyz/range/trait.RangeExt.html" title="trait wyz::range::RangeExt">RangeExt</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>&gt;,</span></h4></section></summary><div class="docblock"><p>Copies bits from one region of the bit-slice to another region of
itself, without doing bounds checks.</p>
<p>The regions are allowed to overlap.</p>
<h6 id="parameters-8"><a href="#parameters-8">Parameters</a></h6>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>src</code>: The range within <code>self</code> from which to copy.</li>
<li><code>dst</code>: The starting index within <code>self</code> at which to paste.</li>
</ul>
<h6 id="effects"><a href="#effects">Effects</a></h6>
<p><code>self[src]</code> is copied to <code>self[dest .. dest + src.len()]</code>. The bits of
<code>self[src]</code> are in an unspecified, but initialized, state.</p>
<h6 id="safety-12"><a href="#safety-12">Safety</a></h6>
<p><code>src.end()</code> and <code>dest + src.len()</code> must be entirely within bounds.</p>
<h6 id="examples-67"><a href="#examples-67">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>data = <span class="number">0b1011_0000u8</span>;
<span class="kw">let </span>bits = data.view_bits_mut::&lt;Msb0&gt;();

<span class="kw">unsafe </span>{
  bits.copy_within_unchecked(.. <span class="number">4</span>, <span class="number">2</span>);
}
<span class="macro">assert_eq!</span>(data, <span class="number">0b1010_1100</span>);</code></pre></div>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BitSlice%3CT%2C%20O%3E-5" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#986-1041">source</a><a href="#impl-BitSlice%3CT%2C%20O%3E-5" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="docblock"><p>Views of underlying memory.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.bit_domain" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#999-1001">source</a><h4 class="code-header">pub fn <a href="#method.bit_domain" class="fnname">bit_domain</a>(&amp;self) -&gt; <a class="enum" href="../domain/enum.BitDomain.html" title="enum bitvec::domain::BitDomain">BitDomain</a>&lt;'_, <a class="struct" href="../ptr/struct.Const.html" title="struct bitvec::ptr::Const">Const</a>, T, O&gt;</h4></section></summary><div class="docblock"><p>Partitions a bit-slice into maybe-contended and known-uncontended parts.</p>
<p>The documentation of <code>BitDomain</code> goes into this in more detail. In
short, this produces a <code>&amp;BitSlice</code> that is as large as possible without
requiring alias protection, as well as any bits that were not able to be
included in the unaliased bit-slice.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.bit_domain_mut" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#1012-1014">source</a><h4 class="code-header">pub fn <a href="#method.bit_domain_mut" class="fnname">bit_domain_mut</a>(&amp;mut self) -&gt; <a class="enum" href="../domain/enum.BitDomain.html" title="enum bitvec::domain::BitDomain">BitDomain</a>&lt;'_, <a class="struct" href="../ptr/struct.Mut.html" title="struct bitvec::ptr::Mut">Mut</a>, T, O&gt;</h4></section></summary><div class="docblock"><p>Partitions a mutable bit-slice into maybe-contended and
known-uncontended parts.</p>
<p>The documentation of <code>BitDomain</code> goes into this in more detail. In
short, this produces a <code>&amp;mut BitSlice</code> that is as large as possible
without requiring alias protection, as well as any bits that were not
able to be included in the unaliased bit-slice.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.domain" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#1025-1027">source</a><h4 class="code-header">pub fn <a href="#method.domain" class="fnname">domain</a>(&amp;self) -&gt; <a class="enum" href="../domain/enum.Domain.html" title="enum bitvec::domain::Domain">Domain</a>&lt;'_, <a class="struct" href="../ptr/struct.Const.html" title="struct bitvec::ptr::Const">Const</a>, T, O&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="enum" href="../domain/enum.Domain.html" title="enum bitvec::domain::Domain">Domain</a>&lt;'_, <a class="struct" href="../ptr/struct.Const.html" title="struct bitvec::ptr::Const">Const</a>, T, O&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="enum" href="../domain/enum.Domain.html" title="enum bitvec::domain::Domain">Domain</a>&lt;'_, <a class="struct" href="../ptr/struct.Const.html" title="struct bitvec::ptr::Const">Const</a>, T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.66.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Mem" title="type bitvec::store::BitStore::Mem">Mem</a>;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Views the underlying memory of a bit-slice, removing alias protections
where possible.</p>
<p>The documentation of <code>Domain</code> goes into this in more detail. In short,
this produces a <code>&amp;[T]</code> slice with alias protections removed, covering
all elements that <code>self</code> completely fills. Partially-used elements on
either the front or back edge of the slice are returned separately.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.domain_mut" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#1038-1040">source</a><h4 class="code-header">pub fn <a href="#method.domain_mut" class="fnname">domain_mut</a>(&amp;mut self) -&gt; <a class="enum" href="../domain/enum.Domain.html" title="enum bitvec::domain::Domain">Domain</a>&lt;'_, <a class="struct" href="../ptr/struct.Mut.html" title="struct bitvec::ptr::Mut">Mut</a>, T, O&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="enum" href="../domain/enum.Domain.html" title="enum bitvec::domain::Domain">Domain</a>&lt;'_, <a class="struct" href="../ptr/struct.Const.html" title="struct bitvec::ptr::Const">Const</a>, T, O&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="enum" href="../domain/enum.Domain.html" title="enum bitvec::domain::Domain">Domain</a>&lt;'_, <a class="struct" href="../ptr/struct.Const.html" title="struct bitvec::ptr::Const">Const</a>, T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.66.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Mem" title="type bitvec::store::BitStore::Mem">Mem</a>;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Views the underlying memory of a bit-slice, removing alias protections
where possible.</p>
<p>The documentation of <code>Domain</code> goes into this in more detail. In short,
this produces a <code>&amp;mut [T]</code> slice with alias protections removed,
covering all elements that <code>self</code> completely fills. Partially-used
elements on the front or back edge of the slice are returned separately.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BitSlice%3CT%2C%20O%3E-6" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#1044-1430">source</a><a href="#impl-BitSlice%3CT%2C%20O%3E-6" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="docblock"><p>Bit-value queries.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.count_ones" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#1062-1075">source</a><h4 class="code-header">pub fn <a href="#method.count_ones" class="fnname">count_ones</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Counts the number of bits set to <code>1</code> in the bit-slice contents.</p>
<h6 id="examples-68"><a href="#examples-68">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="macro">assert_eq!</span>(bits[.. <span class="number">2</span>].count_ones(), <span class="number">2</span>);
<span class="macro">assert_eq!</span>(bits[<span class="number">2 </span>..].count_ones(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[].count_ones(), <span class="number">0</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.count_zeros" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#1090-1109">source</a><h4 class="code-header">pub fn <a href="#method.count_zeros" class="fnname">count_zeros</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Counts the number of bits cleared to <code>0</code> in the bit-slice contents.</p>
<h6 id="examples-69"><a href="#examples-69">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="macro">assert_eq!</span>(bits[.. <span class="number">2</span>].count_zeros(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(bits[<span class="number">2 </span>..].count_zeros(), <span class="number">2</span>);
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[].count_zeros(), <span class="number">0</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.iter_ones" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#1146-1148">source</a><h4 class="code-header">pub fn <a href="#method.iter_ones" class="fnname">iter_ones</a>(&amp;self) -&gt; <a class="struct" href="struct.IterOnes.html" title="struct bitvec::slice::IterOnes">IterOnes</a>&lt;'_, T, O&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="struct.IterOnes.html" title="struct bitvec::slice::IterOnes">IterOnes</a>&lt;'_, T, O&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="struct.IterOnes.html" title="struct bitvec::slice::IterOnes">IterOnes</a>&lt;'_, T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.66.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Enumerates the index of each bit in a bit-slice set to <code>1</code>.</p>
<p>This is a shorthand for a <code>.enumerate().filter_map()</code> iterator that
selects the index of each <code>true</code> bit; however, its implementation is
eligible for optimizations that the individual-bit iterator is not.</p>
<p>Specializations for the <code>Lsb0</code> and <code>Msb0</code> orderings allow processors
with instructions that seek particular bits within an element to operate
on whole elements, rather than on each bit individually.</p>
<h6 id="examples-70"><a href="#examples-70">Examples</a></h6>
<p>This example uses <code>.iter_ones()</code>, a <code>.filter_map()</code> that finds the index
of each set bit, and the known indices, in order to show that they have
equivalent behavior.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];

<span class="kw">let </span>iter_ones = bits.iter_ones();
<span class="kw">let </span>known_indices = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">8</span>].iter().copied();
<span class="kw">let </span>filter = bits.iter()
  .by_vals()
  .enumerate()
  .filter_map(|(idx, bit)| <span class="kw">if </span>bit { <span class="prelude-val">Some</span>(idx) } <span class="kw">else </span>{ <span class="prelude-val">None </span>});
<span class="kw">let </span>all = iter_ones.zip(known_indices).zip(filter);

<span class="kw">for </span>((iter_one, known), filtered) <span class="kw">in </span>all {
  <span class="macro">assert_eq!</span>(iter_one, known);
  <span class="macro">assert_eq!</span>(known, filtered);
}</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.iter_zeros" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#1185-1187">source</a><h4 class="code-header">pub fn <a href="#method.iter_zeros" class="fnname">iter_zeros</a>(&amp;self) -&gt; <a class="struct" href="struct.IterZeros.html" title="struct bitvec::slice::IterZeros">IterZeros</a>&lt;'_, T, O&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="struct.IterZeros.html" title="struct bitvec::slice::IterZeros">IterZeros</a>&lt;'_, T, O&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="struct.IterZeros.html" title="struct bitvec::slice::IterZeros">IterZeros</a>&lt;'_, T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.66.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Enumerates the index of each bit in a bit-slice cleared to <code>0</code>.</p>
<p>This is a shorthand for a <code>.enumerate().filter_map()</code> iterator that
selects the index of each <code>false</code> bit; however, its implementation is
eligible for optimizations that the individual-bit iterator is not.</p>
<p>Specializations for the <code>Lsb0</code> and <code>Msb0</code> orderings allow processors
with instructions that seek particular bits within an element to operate
on whole elements, rather than on each bit individually.</p>
<h6 id="examples-71"><a href="#examples-71">Examples</a></h6>
<p>This example uses <code>.iter_zeros()</code>, a <code>.filter_map()</code> that finds the
index of each cleared bit, and the known indices, in order to show that
they have equivalent behavior.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>];

<span class="kw">let </span>iter_zeros = bits.iter_zeros();
<span class="kw">let </span>known_indices = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">8</span>].iter().copied();
<span class="kw">let </span>filter = bits.iter()
  .by_vals()
  .enumerate()
  .filter_map(|(idx, bit)| <span class="kw">if </span>!bit { <span class="prelude-val">Some</span>(idx) } <span class="kw">else </span>{ <span class="prelude-val">None </span>});
<span class="kw">let </span>all = iter_zeros.zip(known_indices).zip(filter);

<span class="kw">for </span>((iter_zero, known), filtered) <span class="kw">in </span>all {
  <span class="macro">assert_eq!</span>(iter_zero, known);
  <span class="macro">assert_eq!</span>(known, filtered);
}</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.first_one" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#1203-1205">source</a><h4 class="code-header">pub fn <a href="#method.first_one" class="fnname">first_one</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.66.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Finds the index of the first bit in the bit-slice set to <code>1</code>.</p>
<p>Returns <code>None</code> if there is no <code>true</code> bit in the bit-slice.</p>
<h6 id="examples-72"><a href="#examples-72">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="macro">assert!</span>(<span class="macro">bits!</span>[].first_one().is_none());
<span class="macro">assert!</span>(<span class="macro">bits!</span>[<span class="number">0</span>].first_one().is_none());
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>].first_one(), <span class="prelude-val">Some</span>(<span class="number">1</span>));</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.first_zero" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#1221-1223">source</a><h4 class="code-header">pub fn <a href="#method.first_zero" class="fnname">first_zero</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.66.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Finds the index of the first bit in the bit-slice cleared to <code>0</code>.</p>
<p>Returns <code>None</code> if there is no <code>false</code> bit in the bit-slice.</p>
<h6 id="examples-73"><a href="#examples-73">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="macro">assert!</span>(<span class="macro">bits!</span>[].first_zero().is_none());
<span class="macro">assert!</span>(<span class="macro">bits!</span>[<span class="number">1</span>].first_zero().is_none());
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>].first_zero(), <span class="prelude-val">Some</span>(<span class="number">1</span>));</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.last_one" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#1239-1241">source</a><h4 class="code-header">pub fn <a href="#method.last_one" class="fnname">last_one</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.66.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Finds the index of the last bit in the bit-slice set to <code>1</code>.</p>
<p>Returns <code>None</code> if there is no <code>true</code> bit in the bit-slice.</p>
<h6 id="examples-74"><a href="#examples-74">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="macro">assert!</span>(<span class="macro">bits!</span>[].last_one().is_none());
<span class="macro">assert!</span>(<span class="macro">bits!</span>[<span class="number">0</span>].last_one().is_none());
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>].last_one(), <span class="prelude-val">Some</span>(<span class="number">0</span>));</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.last_zero" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#1257-1259">source</a><h4 class="code-header">pub fn <a href="#method.last_zero" class="fnname">last_zero</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.66.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Finds the index of the last bit in the bit-slice cleared to <code>0</code>.</p>
<p>Returns <code>None</code> if there is no <code>false</code> bit in the bit-slice.</p>
<h6 id="examples-75"><a href="#examples-75">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="macro">assert!</span>(<span class="macro">bits!</span>[].last_zero().is_none());
<span class="macro">assert!</span>(<span class="macro">bits!</span>[<span class="number">1</span>].last_zero().is_none());
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>].last_zero(), <span class="prelude-val">Some</span>(<span class="number">0</span>));</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.leading_ones" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#1276-1278">source</a><h4 class="code-header">pub fn <a href="#method.leading_ones" class="fnname">leading_ones</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Counts the number of bits from the start of the bit-slice to the first
bit set to <code>0</code>.</p>
<p>This returns <code>0</code> if the bit-slice is empty.</p>
<h6 id="examples-76"><a href="#examples-76">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[].leading_ones(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">0</span>].leading_ones(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>].leading_ones(), <span class="number">1</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.leading_zeros" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#1295-1297">source</a><h4 class="code-header">pub fn <a href="#method.leading_zeros" class="fnname">leading_zeros</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Counts the number of bits from the start of the bit-slice to the first
bit set to <code>1</code>.</p>
<p>This returns <code>0</code> if the bit-slice is empty.</p>
<h6 id="examples-77"><a href="#examples-77">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[].leading_zeros(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">1</span>].leading_zeros(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>].leading_zeros(), <span class="number">1</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.trailing_ones" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#1314-1317">source</a><h4 class="code-header">pub fn <a href="#method.trailing_ones" class="fnname">trailing_ones</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Counts the number of bits from the end of the bit-slice to the last bit
set to <code>0</code>.</p>
<p>This returns <code>0</code> if the bit-slice is empty.</p>
<h6 id="examples-78"><a href="#examples-78">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[].trailing_ones(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">0</span>].trailing_ones(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>].trailing_ones(), <span class="number">1</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.trailing_zeros" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#1334-1337">source</a><h4 class="code-header">pub fn <a href="#method.trailing_zeros" class="fnname">trailing_zeros</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Counts the number of bits from the end of the bit-slice to the last bit
set to <code>1</code>.</p>
<p>This returns <code>0</code> if the bit-slice is empty.</p>
<h6 id="examples-79"><a href="#examples-79">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[].trailing_zeros(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">1</span>].trailing_zeros(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>].trailing_zeros(), <span class="number">1</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.any" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#1353-1355">source</a><h4 class="code-header">pub fn <a href="#method.any" class="fnname">any</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Tests if there is at least one bit set to <code>1</code> in the bit-slice.</p>
<p>Returns <code>false</code> when <code>self</code> is empty.</p>
<h6 id="examples-80"><a href="#examples-80">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="macro">assert!</span>(!<span class="macro">bits!</span>[].any());
<span class="macro">assert!</span>(!<span class="macro">bits!</span>[<span class="number">0</span>].any());
<span class="macro">assert!</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>].any());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.all" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#1371-1373">source</a><h4 class="code-header">pub fn <a href="#method.all" class="fnname">all</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Tests if every bit is set to <code>1</code> in the bit-slice.</p>
<p>Returns <code>true</code> when <code>self</code> is empty.</p>
<h6 id="examples-81"><a href="#examples-81">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="macro">assert!</span>( <span class="macro">bits!</span>[].all());
<span class="macro">assert!</span>(!<span class="macro">bits!</span>[<span class="number">0</span>].all());
<span class="macro">assert!</span>( <span class="macro">bits!</span>[<span class="number">1</span>].all());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.not_any" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#1389-1391">source</a><h4 class="code-header">pub fn <a href="#method.not_any" class="fnname">not_any</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Tests if every bit is cleared to <code>0</code> in the bit-slice.</p>
<p>Returns <code>true</code> when <code>self</code> is empty.</p>
<h6 id="examples-82"><a href="#examples-82">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="macro">assert!</span>( <span class="macro">bits!</span>[].not_any());
<span class="macro">assert!</span>(!<span class="macro">bits!</span>[<span class="number">1</span>].not_any());
<span class="macro">assert!</span>( <span class="macro">bits!</span>[<span class="number">0</span>].not_any());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.not_all" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#1407-1409">source</a><h4 class="code-header">pub fn <a href="#method.not_all" class="fnname">not_all</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Tests if at least one bit is cleared to <code>0</code> in the bit-slice.</p>
<p>Returns <code>false</code> when <code>self</code> is empty.</p>
<h6 id="examples-83"><a href="#examples-83">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="macro">assert!</span>(!<span class="macro">bits!</span>[].not_all());
<span class="macro">assert!</span>(!<span class="macro">bits!</span>[<span class="number">1</span>].not_all());
<span class="macro">assert!</span>( <span class="macro">bits!</span>[<span class="number">0</span>].not_all());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.some" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#1427-1429">source</a><h4 class="code-header">pub fn <a href="#method.some" class="fnname">some</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Tests if at least one bit is set to <code>1</code>, and at least one bit is cleared
to <code>0</code>, in the bit-slice.</p>
<p>Returns <code>false</code> when <code>self</code> is empty.</p>
<h6 id="examples-84"><a href="#examples-84">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="macro">assert!</span>(!<span class="macro">bits!</span>[].some());
<span class="macro">assert!</span>(!<span class="macro">bits!</span>[<span class="number">0</span>].some());
<span class="macro">assert!</span>(!<span class="macro">bits!</span>[<span class="number">1</span>].some());
<span class="macro">assert!</span>( <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>].some());</code></pre></div>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BitSlice%3CT%2C%20O%3E-7" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#1433-1553">source</a><a href="#impl-BitSlice%3CT%2C%20O%3E-7" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="docblock"><p>Buffer manipulation.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.shift_left" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#1474-1494">source</a><h4 class="code-header">pub fn <a href="#method.shift_left" class="fnname">shift_left</a>(&amp;mut self, by: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Shifts the contents of a bit-slice “left” (towards the zero-index),
clearing the “right” bits to <code>0</code>.</p>
<p>This is a strictly-worse analogue to taking <code>bits = &amp;bits[by ..]</code>: it
has to modify the entire memory region that <code>bits</code> governs, and destroys
contained information. Unless the actual memory layout and contents of
your bit-slice matters to your program, you should <em>probably</em> prefer to
munch your way forward through a bit-slice handle.</p>
<p>Note also that the “left” here is semantic only, and <strong>does not</strong>
necessarily correspond to a left-shift instruction applied to the
underlying integer storage.</p>
<p>This has no effect when <code>by</code> is <code>0</code>. When <code>by</code> is <code>self.len()</code>, the
bit-slice is entirely cleared to <code>0</code>.</p>
<h6 id="panics-20"><a href="#panics-20">Panics</a></h6>
<p>This panics if <code>by</code> is not less than <code>self.len()</code>.</p>
<h6 id="examples-85"><a href="#examples-85">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="comment">// these bits are retained ^--------------------------^
</span>bits.shift_left(<span class="number">2</span>);
<span class="macro">assert_eq!</span>(bits, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]);
<span class="comment">// and move here       ^--------------------------^

</span><span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">1</span>; <span class="number">2</span>];
bits.shift_left(<span class="number">2</span>);
<span class="macro">assert_eq!</span>(bits, <span class="macro">bits!</span>[<span class="number">0</span>; <span class="number">2</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.shift_right" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#1532-1552">source</a><h4 class="code-header">pub fn <a href="#method.shift_right" class="fnname">shift_right</a>(&amp;mut self, by: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Shifts the contents of a bit-slice “right” (away from the zero-index),
clearing the “left” bits to <code>0</code>.</p>
<p>This is a strictly-worse analogue to taking `bits = &amp;bits[.. bits.len()</p>
<ul>
<li>by]<code>: it must modify the entire memory region that </code>bits` governs, and
destroys contained information. Unless the actual memory layout and
contents of your bit-slice matters to your program, you should
<em>probably</em> prefer to munch your way backward through a bit-slice handle.</li>
</ul>
<p>Note also that the “right” here is semantic only, and <strong>does not</strong>
necessarily correspond to a right-shift instruction applied to the
underlying integer storage.</p>
<p>This has no effect when <code>by</code> is <code>0</code>. When <code>by</code> is <code>self.len()</code>, the
bit-slice is entirely cleared to <code>0</code>.</p>
<h6 id="panics-21"><a href="#panics-21">Panics</a></h6>
<p>This panics if <code>by</code> is not less than <code>self.len()</code>.</p>
<h6 id="examples-86"><a href="#examples-86">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="comment">// these bits stay   ^--------------------------^
</span>bits.shift_right(<span class="number">2</span>);
<span class="macro">assert_eq!</span>(bits, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]);
<span class="comment">// and move here             ^--------------------------^

</span><span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">1</span>; <span class="number">2</span>];
bits.shift_right(<span class="number">2</span>);
<span class="macro">assert_eq!</span>(bits, <span class="macro">bits!</span>[<span class="number">0</span>; <span class="number">2</span>]);</code></pre></div>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BitSlice%3CT%2C%20O%3E-8" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#1637-1718">source</a><a href="#impl-BitSlice%3CT%2C%20O%3E-8" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a> + <a class="trait" href="../../radium/trait.Radium.html" title="trait radium::Radium">Radium</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="docblock"><p>Methods available only when <code>T</code> allows shared mutability.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.set_aliased" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#1674-1679">source</a><h4 class="code-header">pub fn <a href="#method.set_aliased" class="fnname">set_aliased</a>(&amp;self, index: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>, value: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a>)</h4></section></summary><div class="docblock"><p>Writes a new value into a single bit, using alias-safe operations.</p>
<p>This is equivalent to <a href="struct.BitSlice.html#method.set"><code>.set()</code></a>, except that it does not require an
<code>&amp;mut</code> reference, and allows bit-slices with alias-safe storage to share
write permissions.</p>
<h6 id="parameters-9"><a href="#parameters-9">Parameters</a></h6>
<ul>
<li><code>&amp;self</code>: This method only exists on bit-slices with alias-safe
storage, and so does not require exclusive access.</li>
<li><code>index</code>: The bit index to set. It must be in <code>0 .. self.len()</code>.</li>
<li><code>value</code>: The new bit-value to write into the bit at <code>index</code>.</li>
</ul>
<h6 id="panics-22"><a href="#panics-22">Panics</a></h6>
<p>This panics if <code>index</code> is out of bounds.</p>
<h6 id="examples-87"><a href="#examples-87">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;
<span class="kw">use </span>core::cell::Cell;

<span class="kw">let </span>bits: <span class="kw-2">&amp;</span>BitSlice&lt;<span class="kw">_</span>, <span class="kw">_</span>&gt; = <span class="macro">bits!</span>[Cell&lt;usize&gt;, Lsb0; <span class="number">0</span>, <span class="number">1</span>];
bits.set_aliased(<span class="number">0</span>, <span class="bool-val">true</span>);
bits.set_aliased(<span class="number">1</span>, <span class="bool-val">false</span>);

<span class="macro">assert_eq!</span>(bits, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.set_aliased_unchecked" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#1715-1717">source</a><h4 class="code-header">pub unsafe fn <a href="#method.set_aliased_unchecked" class="fnname">set_aliased_unchecked</a>(&amp;self, index: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>, value: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a>)</h4></section></summary><div class="docblock"><p>Writes a new value into a single bit, using alias-safe operations and
without bounds checking.</p>
<p>This is equivalent to <a href="struct.BitSlice.html#method.set_unchecked"><code>.set_unchecked()</code></a>, except that it does not
require an <code>&amp;mut</code> reference, and allows bit-slices with alias-safe
storage to share write permissions.</p>
<h6 id="parameters-10"><a href="#parameters-10">Parameters</a></h6>
<ul>
<li><code>&amp;self</code>: This method only exists on bit-slices with alias-safe
storage, and so does not require exclusive access.</li>
<li><code>index</code>: The bit index to set. It must be in <code>0 .. self.len()</code>.</li>
<li><code>value</code>: The new bit-value to write into the bit at <code>index</code>.</li>
</ul>
<h6 id="safety-13"><a href="#safety-13">Safety</a></h6>
<p>The caller must ensure that <code>index</code> is not out of bounds.</p>
<h6 id="examples-88"><a href="#examples-88">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;
<span class="kw">use </span>core::cell::Cell;

<span class="kw">let </span>data = Cell::new(<span class="number">0u8</span>);
<span class="kw">let </span>bits = <span class="kw-2">&amp;</span>data.view_bits::&lt;Lsb0&gt;()[.. <span class="number">2</span>];
<span class="kw">unsafe </span>{
  bits.set_aliased_unchecked(<span class="number">3</span>, <span class="bool-val">true</span>);
}
<span class="macro">assert_eq!</span>(data.get(), <span class="number">8</span>);</code></pre></div>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BitSlice%3CT%2C%20O%3E-9" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#1721-1752">source</a><a href="#impl-BitSlice%3CT%2C%20O%3E-9" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="docblock"><p>Miscellaneous information.</p>
</div><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedconstant.MAX_BITS" class="associatedconstant has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#1735">source</a><h4 class="code-header">pub const <a href="#associatedconstant.MAX_BITS" class="constant">MAX_BITS</a>: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a> = 2_305_843_009_213_693_951usize</h4></section></summary><div class="docblock"><p>The inclusive maximum length of a <code>BitSlice&lt;_, T&gt;</code>.</p>
<p>As <code>BitSlice</code> is zero-indexed, the largest possible <em>index</em> is one less
than this value.</p>
<div><table><thead><tr><th style="text-align: right">CPU word width</th><th style="text-align: right">Value</th></tr></thead><tbody>
<tr><td style="text-align: right">32 bits</td><td style="text-align: right"><code>0x1fff_ffff</code></td></tr>
<tr><td style="text-align: right">64 bits</td><td style="text-align: right"><code>0x1fff_ffff_ffff_ffff</code></td></tr>
</tbody></table>
</div></div></details><details class="rustdoc-toggle" open><summary><section id="associatedconstant.MAX_ELTS" class="associatedconstant has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#1751">source</a><h4 class="code-header">pub const <a href="#associatedconstant.MAX_ELTS" class="constant">MAX_ELTS</a>: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a> = BitSpan&lt;Const, T, O&gt;::REGION_MAX_ELTS</h4></section></summary><div class="docblock"><p>The inclusive maximum length that a <code>[T]</code> slice can be for
<code>BitSlice&lt;_, T&gt;</code> to cover it.</p>
<p>A <code>BitSlice&lt;_, T&gt;</code> that begins in the interior of an element and
contains the maximum number of bits will extend one element past the
cutoff that would occur if the bit-slice began at the zeroth bit. Such a
bit-slice is difficult to manually construct, but would not otherwise
fail.</p>
<div><table><thead><tr><th style="text-align: right">Type Bits</th><th style="text-align: right">Max Elements (32-bit)</th><th style="text-align: right">Max Elements (64-bit)</th></tr></thead><tbody>
<tr><td style="text-align: right">8</td><td style="text-align: right"><code>0x0400_0001</code></td><td style="text-align: right"><code>0x0400_0000_0000_0001</code></td></tr>
<tr><td style="text-align: right">16</td><td style="text-align: right"><code>0x0200_0001</code></td><td style="text-align: right"><code>0x0200_0000_0000_0001</code></td></tr>
<tr><td style="text-align: right">32</td><td style="text-align: right"><code>0x0100_0001</code></td><td style="text-align: right"><code>0x0100_0000_0000_0001</code></td></tr>
<tr><td style="text-align: right">64</td><td style="text-align: right"><code>0x0080_0001</code></td><td style="text-align: right"><code>0x0080_0000_0000_0001</code></td></tr>
</tbody></table>
</div></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BitSlice%3CT%2C%20O%3E-10" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#1755-1793">source</a><a href="#impl-BitSlice%3CT%2C%20O%3E-10" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.to_bitvec" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#1783-1792">source</a><h4 class="code-header">pub fn <a href="#method.to_bitvec" class="fnname">to_bitvec</a>(&amp;self) -&gt; <a class="struct" href="../vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Unalias" title="type bitvec::store::BitStore::Unalias">Unalias</a>, O&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;T, O&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/std/io/trait.Read.html" title="trait std::io::Read">Read</a> for <a class="struct" href="../vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,</span></span><span class="where fmt-newline">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/std/io/trait.Write.html" title="trait std::io::Write">Write</a> for <a class="struct" href="../vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,</span></span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Copies a bit-slice into an owned bit-vector.</p>
<p>Since the new vector is freshly owned, this gets marked as <code>::Unalias</code>
to remove any guards that may have been inserted by the bit-slice’s
history.</p>
<p>It does <em>not</em> use the underlying memory type, so that a <code>BitSlice&lt;_, Cell&lt;_&gt;&gt;</code> will produce a <code>BitVec&lt;_, Cell&lt;_&gt;&gt;</code>.</p>
<h6 id="original-63"><a href="#original-63">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.to_vec"><code>slice::to_vec</code></a></p>
<h6 id="examples-89"><a href="#examples-89">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let </span>bv = bits.to_bitvec();
<span class="macro">assert_eq!</span>(bits, bv);</code></pre></div>
</div></details></div></details></div><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor"></a></h2><div id="trait-implementations-list"><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-AsMut%3CBitSlice%3C%3CA%20as%20BitView%3E%3A%3AStore%2C%20O%3E%3E-for-BitArray%3CA%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/array/traits.rs.html#163-172">source</a><a href="#impl-AsMut%3CBitSlice%3C%3CA%20as%20BitView%3E%3A%3AStore%2C%20O%3E%3E-for-BitArray%3CA%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;A, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/convert/trait.AsMut.html" title="trait core::convert::AsMut">AsMut</a>&lt;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;&lt;A as <a class="trait" href="../view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a>&gt;::<a class="associatedtype" href="../view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>, O&gt;&gt; for <a class="struct" href="../array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;A, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;A: <a class="trait" href="../view/trait.BitViewSized.html" title="trait bitvec::view::BitViewSized">BitViewSized</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_mut" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/array/traits.rs.html#169-171">source</a><a href="#method.as_mut" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/convert/trait.AsMut.html#tymethod.as_mut" class="fnname">as_mut</a>(&amp;mut self) -&gt; &amp;mut <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;A::<a class="associatedtype" href="../view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>, O&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/std/io/trait.Read.html" title="trait std::io::Read">Read</a> for &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,</span></span><span class="where fmt-newline">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/std/io/trait.Write.html" title="trait std::io::Write">Write</a> for &amp;mut <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,</span></span></code></span></span></span></span></h4></section></summary><div class='docblock'>Converts this type into a mutable reference of the (usually inferred) input type.</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-AsMut%3CBitSlice%3CT%2C%20O%3E%3E-for-BitBox%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/boxed/traits.rs.html#218-227">source</a><a href="#impl-AsMut%3CBitSlice%3CT%2C%20O%3E%3E-for-BitBox%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/convert/trait.AsMut.html" title="trait core::convert::AsMut">AsMut</a>&lt;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;&gt; for <a class="struct" href="../boxed/struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_mut-1" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/boxed/traits.rs.html#224-226">source</a><a href="#method.as_mut-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/convert/trait.AsMut.html#tymethod.as_mut" class="fnname">as_mut</a>(&amp;mut self) -&gt; &amp;mut <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/std/io/trait.Read.html" title="trait std::io::Read">Read</a> for &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,</span></span><span class="where fmt-newline">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/std/io/trait.Write.html" title="trait std::io::Write">Write</a> for &amp;mut <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,</span></span></code></span></span></span></span></h4></section></summary><div class='docblock'>Converts this type into a mutable reference of the (usually inferred) input type.</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-AsMut%3CBitSlice%3CT%2C%20O%3E%3E-for-BitSlice%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/traits.rs.html#56-65">source</a><a href="#impl-AsMut%3CBitSlice%3CT%2C%20O%3E%3E-for-BitSlice%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/convert/trait.AsMut.html" title="trait core::convert::AsMut">AsMut</a>&lt;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;&gt; for <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="docblock"><p><a href="https://doc.rust-lang.org/std/primitive.slice.html#impl-AsMut%3C%5BT%5D%3E">Original</a></p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_mut-2" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/traits.rs.html#62-64">source</a><a href="#method.as_mut-2" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/convert/trait.AsMut.html#tymethod.as_mut" class="fnname">as_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;mut </a>Self</h4></section></summary><div class='docblock'>Converts this type into a mutable reference of the (usually inferred) input type.</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-AsMut%3CBitSlice%3CT%2C%20O%3E%3E-for-BitVec%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#218-227">source</a><a href="#impl-AsMut%3CBitSlice%3CT%2C%20O%3E%3E-for-BitVec%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/convert/trait.AsMut.html" title="trait core::convert::AsMut">AsMut</a>&lt;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;&gt; for <a class="struct" href="../vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_mut-3" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#224-226">source</a><a href="#method.as_mut-3" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/convert/trait.AsMut.html#tymethod.as_mut" class="fnname">as_mut</a>(&amp;mut self) -&gt; &amp;mut <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/std/io/trait.Read.html" title="trait std::io::Read">Read</a> for &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,</span></span><span class="where fmt-newline">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/std/io/trait.Write.html" title="trait std::io::Write">Write</a> for &amp;mut <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,</span></span></code></span></span></span></span></h4></section></summary><div class='docblock'>Converts this type into a mutable reference of the (usually inferred) input type.</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-AsRef%3CBitSlice%3C%3CA%20as%20BitView%3E%3A%3AStore%2C%20O%3E%3E-for-BitArray%3CA%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/array/traits.rs.html#151-160">source</a><a href="#impl-AsRef%3CBitSlice%3C%3CA%20as%20BitView%3E%3A%3AStore%2C%20O%3E%3E-for-BitArray%3CA%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;A, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;&lt;A as <a class="trait" href="../view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a>&gt;::<a class="associatedtype" href="../view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>, O&gt;&gt; for <a class="struct" href="../array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;A, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;A: <a class="trait" href="../view/trait.BitViewSized.html" title="trait bitvec::view::BitViewSized">BitViewSized</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_ref" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/array/traits.rs.html#157-159">source</a><a href="#method.as_ref" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/convert/trait.AsRef.html#tymethod.as_ref" class="fnname">as_ref</a>(&amp;self) -&gt; &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;A::<a class="associatedtype" href="../view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>, O&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/std/io/trait.Read.html" title="trait std::io::Read">Read</a> for &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,</span></span><span class="where fmt-newline">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/std/io/trait.Write.html" title="trait std::io::Write">Write</a> for &amp;mut <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,</span></span></code></span></span></span></span></h4></section></summary><div class='docblock'>Converts this type into a shared reference of the (usually inferred) input type.</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-AsRef%3CBitSlice%3C%3CT%20as%20BitStore%3E%3A%3AAlias%2C%20O%3E%3E-for-IterMut%3C%27_%2C%20T%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/iter.rs.html#381-390">source</a><a href="#impl-AsRef%3CBitSlice%3C%3CT%20as%20BitStore%3E%3A%3AAlias%2C%20O%3E%3E-for-IterMut%3C%27_%2C%20T%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;&lt;T as <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>&gt;::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>, O&gt;&gt; for <a class="struct" href="struct.IterMut.html" title="struct bitvec::slice::IterMut">IterMut</a>&lt;'_, T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="docblock"><p><a href="https://doc.rust-lang.org/core/slice/struct.IterMut.html#impl-AsRef%3C%5BT%5D%3E">Original</a></p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_ref-4" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/iter.rs.html#387-389">source</a><a href="#method.as_ref-4" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/convert/trait.AsRef.html#tymethod.as_ref" class="fnname">as_ref</a>(&amp;self) -&gt; &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>, O&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/std/io/trait.Read.html" title="trait std::io::Read">Read</a> for &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,</span></span><span class="where fmt-newline">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/std/io/trait.Write.html" title="trait std::io::Write">Write</a> for &amp;mut <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,</span></span></code></span></span></span></span></h4></section></summary><div class='docblock'>Converts this type into a shared reference of the (usually inferred) input type.</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-AsRef%3CBitSlice%3CT%2C%20O%3E%3E-for-BitBox%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/boxed/traits.rs.html#206-215">source</a><a href="#impl-AsRef%3CBitSlice%3CT%2C%20O%3E%3E-for-BitBox%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;&gt; for <a class="struct" href="../boxed/struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_ref-2" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/boxed/traits.rs.html#212-214">source</a><a href="#method.as_ref-2" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/convert/trait.AsRef.html#tymethod.as_ref" class="fnname">as_ref</a>(&amp;self) -&gt; &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/std/io/trait.Read.html" title="trait std::io::Read">Read</a> for &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,</span></span><span class="where fmt-newline">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/std/io/trait.Write.html" title="trait std::io::Write">Write</a> for &amp;mut <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,</span></span></code></span></span></span></span></h4></section></summary><div class='docblock'>Converts this type into a shared reference of the (usually inferred) input type.</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-AsRef%3CBitSlice%3CT%2C%20O%3E%3E-for-BitSlice%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/traits.rs.html#44-53">source</a><a href="#impl-AsRef%3CBitSlice%3CT%2C%20O%3E%3E-for-BitSlice%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;&gt; for <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="docblock"><p><a href="https://doc.rust-lang.org/std/primitive.slice.html#impl-AsRef%3C%5BT%5D%3E">Original</a></p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_ref-5" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/traits.rs.html#50-52">source</a><a href="#method.as_ref-5" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/convert/trait.AsRef.html#tymethod.as_ref" class="fnname">as_ref</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Self</h4></section></summary><div class='docblock'>Converts this type into a shared reference of the (usually inferred) input type.</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-AsRef%3CBitSlice%3CT%2C%20O%3E%3E-for-BitVec%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#206-215">source</a><a href="#impl-AsRef%3CBitSlice%3CT%2C%20O%3E%3E-for-BitVec%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;&gt; for <a class="struct" href="../vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_ref-7" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#212-214">source</a><a href="#method.as_ref-7" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/convert/trait.AsRef.html#tymethod.as_ref" class="fnname">as_ref</a>(&amp;self) -&gt; &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/std/io/trait.Read.html" title="trait std::io::Read">Read</a> for &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,</span></span><span class="where fmt-newline">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/std/io/trait.Write.html" title="trait std::io::Write">Write</a> for &amp;mut <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,</span></span></code></span></span></span></span></h4></section></summary><div class='docblock'>Converts this type into a shared reference of the (usually inferred) input type.</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-AsRef%3CBitSlice%3CT%2C%20O%3E%3E-for-Drain%3C%27_%2C%20T%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/iter.rs.html#411-420">source</a><a href="#impl-AsRef%3CBitSlice%3CT%2C%20O%3E%3E-for-Drain%3C%27_%2C%20T%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;&gt; for <a class="struct" href="../vec/struct.Drain.html" title="struct bitvec::vec::Drain">Drain</a>&lt;'_, T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="docblock"><p><a href="https://doc.rust-lang.org/alloc/vec/struct.Drain.html#impl-AsRef%3C%5BT%5D%3E">Original</a></p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_ref-6" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/iter.rs.html#417-419">source</a><a href="#method.as_ref-6" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/convert/trait.AsRef.html#tymethod.as_ref" class="fnname">as_ref</a>(&amp;self) -&gt; &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/std/io/trait.Read.html" title="trait std::io::Read">Read</a> for &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,</span></span><span class="where fmt-newline">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/std/io/trait.Write.html" title="trait std::io::Write">Write</a> for &amp;mut <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,</span></span></code></span></span></span></span></h4></section></summary><div class='docblock'>Converts this type into a shared reference of the (usually inferred) input type.</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-AsRef%3CBitSlice%3CT%2C%20O%3E%3E-for-IntoIter%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/boxed/iter.rs.html#123-132">source</a><a href="#impl-AsRef%3CBitSlice%3CT%2C%20O%3E%3E-for-IntoIter%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;&gt; for <a class="struct" href="../boxed/struct.IntoIter.html" title="struct bitvec::boxed::IntoIter">IntoIter</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="docblock"><p><a href="https://doc.rust-lang.org/alloc/vec/struct.IntoIter.html#impl-AsRef%3C%5BT%5D%3E">Original</a></p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_ref-1" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/boxed/iter.rs.html#129-131">source</a><a href="#method.as_ref-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/convert/trait.AsRef.html#tymethod.as_ref" class="fnname">as_ref</a>(&amp;self) -&gt; &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/std/io/trait.Read.html" title="trait std::io::Read">Read</a> for &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,</span></span><span class="where fmt-newline">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/std/io/trait.Write.html" title="trait std::io::Write">Write</a> for &amp;mut <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,</span></span></code></span></span></span></span></h4></section></summary><div class='docblock'>Converts this type into a shared reference of the (usually inferred) input type.</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-AsRef%3CBitSlice%3CT%2C%20O%3E%3E-for-Iter%3C%27_%2C%20T%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/iter.rs.html#247-256">source</a><a href="#impl-AsRef%3CBitSlice%3CT%2C%20O%3E%3E-for-Iter%3C%27_%2C%20T%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;&gt; for <a class="struct" href="struct.Iter.html" title="struct bitvec::slice::Iter">Iter</a>&lt;'_, T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="docblock"><p><a href="https://doc.rust-lang.org/core/slice/struct.Iter.html#impl-AsRef%3C%5BT%5D%3E">Original</a></p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_ref-3" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/iter.rs.html#253-255">source</a><a href="#method.as_ref-3" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/convert/trait.AsRef.html#tymethod.as_ref" class="fnname">as_ref</a>(&amp;self) -&gt; &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/std/io/trait.Read.html" title="trait std::io::Read">Read</a> for &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,</span></span><span class="where fmt-newline">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/std/io/trait.Write.html" title="trait std::io::Write">Write</a> for &amp;mut <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,</span></span></code></span></span></span></span></h4></section></summary><div class='docblock'>Converts this type into a shared reference of the (usually inferred) input type.</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Binary-for-BitSlice%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/traits.rs.html#523-528">source</a><a href="#impl-Binary-for-BitSlice%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/fmt/trait.Binary.html" title="trait core::fmt::Binary">Binary</a> for <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="docblock"><h4 id="bit-slice-rendering"><a href="#bit-slice-rendering">Bit-Slice Rendering</a></h4>
<p>This implementation prints the contents of a <code>&amp;BitSlice</code> in one of binary,
octal, or hexadecimal. It is important to note that this does <em>not</em> render the
raw underlying memory! They render the semantically-ordered contents of the
bit-slice as numerals. This distinction matters if you use type parameters that
differ from those presumed by your debugger (which is usually <code>&lt;u8, Msb0&gt;</code>).</p>
<p>The output separates the <code>T</code> elements as individual list items, and renders each
element as a base- 2, 8, or 16 numeric string. When walking an element, the bits
traversed by the bit-slice are considered to be stored in
most-significant-bit-first ordering. This means that index <code>[0]</code> is the high bit
of the left-most digit, and index <code>[n]</code> is the low bit of the right-most digit,
in a given printed word.</p>
<p>In order to render according to expectations of the Arabic numeral system, an
element being transcribed is chunked into digits from the least-significant end
of its rendered form. This is most noticeable in octal, which will always have a
smaller ceiling on the left-most digit in a printed word, while the right-most
digit in that word is able to use the full <code>0 ..= 7</code> numeral range.</p>
<h5 id="examples-102"><a href="#examples-102">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>data = [
  <span class="number">0b000000_10u8</span>,
<span class="comment">// digits print LTR
  </span><span class="number">0b10_001_101</span>,
<span class="comment">// significance is computed RTL
  </span><span class="number">0b01_000000</span>,
];
<span class="kw">let </span>bits = <span class="kw-2">&amp;</span>data.view_bits::&lt;Msb0&gt;()[<span class="number">6 </span>.. <span class="number">18</span>];

<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">&quot;{:b}&quot;</span>, bits), <span class="string">&quot;[10, 10001101, 01]&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">&quot;{:o}&quot;</span>, bits), <span class="string">&quot;[2, 215, 1]&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">&quot;{:X}&quot;</span>, bits), <span class="string">&quot;[2, 8D, 1]&quot;</span>);</code></pre></div>
<p>The <code>{:#}</code> format modifier causes the standard <code>0b</code>, <code>0o</code>, or <code>0x</code> prefix to be
applied to each printed word. The other format specifiers are not interpreted by
this implementation, and apply to the entire rendered text, not to individual
words.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt-3" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/traits.rs.html#523-528">source</a><a href="#method.fmt-3" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/fmt/trait.Binary.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, fmt: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.66.1/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.66.1/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter.</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BitAndAssign%3C%26BitArray%3CA%2C%20O%3E%3E-for-BitSlice%3CA%3A%3AStore%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/array/ops.rs.html#38-47">source</a><a href="#impl-BitAndAssign%3C%26BitArray%3CA%2C%20O%3E%3E-for-BitSlice%3CA%3A%3AStore%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;A, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/bit/trait.BitAndAssign.html" title="trait core::ops::bit::BitAndAssign">BitAndAssign</a>&lt;&amp;<a class="struct" href="../array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;A, O&gt;&gt; for <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;A::<a class="associatedtype" href="../view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;A: <a class="trait" href="../view/trait.BitViewSized.html" title="trait bitvec::view::BitViewSized">BitViewSized</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.bitand_assign-1" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/array/ops.rs.html#44-46">source</a><a href="#method.bitand_assign-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/ops/bit/trait.BitAndAssign.html#tymethod.bitand_assign" class="fnname">bitand_assign</a>(&amp;mut self, rhs: &amp;<a class="struct" href="../array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;A, O&gt;)</h4></section></summary><div class='docblock'>Performs the <code>&amp;=</code> operation. <a href="https://doc.rust-lang.org/1.66.1/core/ops/bit/trait.BitAndAssign.html#tymethod.bitand_assign">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BitAndAssign%3C%26BitBox%3CT%2C%20O%3E%3E-for-BitSlice%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/boxed/ops.rs.html#40-49">source</a><a href="#impl-BitAndAssign%3C%26BitBox%3CT%2C%20O%3E%3E-for-BitSlice%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/bit/trait.BitAndAssign.html" title="trait core::ops::bit::BitAndAssign">BitAndAssign</a>&lt;&amp;<a class="struct" href="../boxed/struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt;&gt; for <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.bitand_assign-3" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/boxed/ops.rs.html#46-48">source</a><a href="#method.bitand_assign-3" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/ops/bit/trait.BitAndAssign.html#tymethod.bitand_assign" class="fnname">bitand_assign</a>(&amp;mut self, rhs: &amp;<a class="struct" href="../boxed/struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt;)</h4></section></summary><div class='docblock'>Performs the <code>&amp;=</code> operation. <a href="https://doc.rust-lang.org/1.66.1/core/ops/bit/trait.BitAndAssign.html#tymethod.bitand_assign">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BitAndAssign%3C%26BitSlice%3CT2%2C%20O2%3E%3E-for-BitSlice%3CT1%2C%20O1%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/ops.rs.html#35-65">source</a><a href="#impl-BitAndAssign%3C%26BitSlice%3CT2%2C%20O2%3E%3E-for-BitSlice%3CT1%2C%20O1%3E" class="anchor"></a><h3 class="code-header">impl&lt;T1, T2, O1, O2&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/bit/trait.BitAndAssign.html" title="trait core::ops::bit::BitAndAssign">BitAndAssign</a>&lt;&amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T2, O2&gt;&gt; for <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T1, O1&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T1: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O1: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.bitand_assign-4" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/ops.rs.html#44-64">source</a><a href="#method.bitand_assign-4" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/ops/bit/trait.BitAndAssign.html#tymethod.bitand_assign" class="fnname">bitand_assign</a>(&amp;mut self, rhs: &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T2, O2&gt;)</h4></section></summary><div class="docblock"><h5 id="boolean-arithmetic"><a href="#boolean-arithmetic">Boolean Arithmetic</a></h5>
<p>This merges another bit-slice into <code>self</code> with a Boolean arithmetic operation.
If the other bit-slice is shorter than <code>self</code>, it is zero-extended. For <code>BitAnd</code>,
this clears all excess bits of <code>self</code> to <code>0</code>; for <code>BitOr</code> and <code>BitXor</code>, it
leaves them untouched</p>
<h6 id="behavior-1"><a href="#behavior-1">Behavior</a></h6>
<p>The Boolean operation proceeds across each bit-slice in iteration order. This is
<code>3O(n)</code> in the length of the shorter of <code>self</code> and <code>rhs</code>. However, it can be
accelerated if <code>rhs</code> has the same type parameters as <code>self</code>, and both are using
one of the orderings provided by <code>bitvec</code>. In this case, the implementation
specializes to use <code>BitField</code> batch operations to operate on the slices one word
at a time, rather than one bit.</p>
<p>Acceleration is not currently provided for custom bit-orderings that use the
same storage type.</p>
<h6 id="pre-10-behavior"><a href="#pre-10-behavior">Pre-<code>1.0</code> Behavior</a></h6>
<p>In the <code>0.</code> development series, Boolean arithmetic was implemented against all
<code>I: Iterator&lt;Item = bool&gt;</code>. This allowed code such as <code>bits |= [false, true];</code>,
but forbad acceleration in the most common use case (combining two bit-slices)
because <code>BitSlice</code> is not such an iterator.</p>
<p>Usage surveys indicate that it is better for the arithmetic operators to operate
on bit-slices, and to allow the possibility of specialized acceleration, rather
than to allow folding against any iterator of <code>bool</code>s.</p>
<p>If pre-<code>1.0</code> code relies on this behavior specifically, and has non-<code>BitSlice</code>
arguments to the Boolean sigils, then they will need to be replaced with the
equivalent loop.</p>
<h6 id="examples-98"><a href="#examples-98">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>a = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="kw">let </span>b = <span class="macro">bits!</span>[    <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];

<span class="kw-2">*</span>a ^= b;
<span class="macro">assert_eq!</span>(a, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]);

<span class="kw">let </span>c = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="kw">let </span>d = [<span class="bool-val">false</span>, <span class="bool-val">true</span>, <span class="bool-val">false</span>, <span class="bool-val">true</span>];

<span class="comment">// no longer allowed
// c &amp;= d.into_iter().by_vals();
</span><span class="kw">for </span>(<span class="kw-2">mut </span>c, d) <span class="kw">in </span>c.iter_mut().zip(d.into_iter())
{
  <span class="kw-2">*</span>c ^= d;
}
<span class="macro">assert_eq!</span>(c, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]);</code></pre></div>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BitAndAssign%3C%26BitVec%3CT%2C%20O%3E%3E-for-BitSlice%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/ops.rs.html#43-52">source</a><a href="#impl-BitAndAssign%3C%26BitVec%3CT%2C%20O%3E%3E-for-BitSlice%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/bit/trait.BitAndAssign.html" title="trait core::ops::bit::BitAndAssign">BitAndAssign</a>&lt;&amp;<a class="struct" href="../vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;T, O&gt;&gt; for <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.bitand_assign-6" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/ops.rs.html#49-51">source</a><a href="#method.bitand_assign-6" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/ops/bit/trait.BitAndAssign.html#tymethod.bitand_assign" class="fnname">bitand_assign</a>(&amp;mut self, rhs: &amp;<a class="struct" href="../vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;T, O&gt;)</h4></section></summary><div class='docblock'>Performs the <code>&amp;=</code> operation. <a href="https://doc.rust-lang.org/1.66.1/core/ops/bit/trait.BitAndAssign.html#tymethod.bitand_assign">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BitAndAssign%3CBitArray%3CA%2C%20O%3E%3E-for-BitSlice%3CA%3A%3AStore%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/array/ops.rs.html#26-35">source</a><a href="#impl-BitAndAssign%3CBitArray%3CA%2C%20O%3E%3E-for-BitSlice%3CA%3A%3AStore%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;A, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/bit/trait.BitAndAssign.html" title="trait core::ops::bit::BitAndAssign">BitAndAssign</a>&lt;<a class="struct" href="../array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;A, O&gt;&gt; for <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;A::<a class="associatedtype" href="../view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;A: <a class="trait" href="../view/trait.BitViewSized.html" title="trait bitvec::view::BitViewSized">BitViewSized</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.bitand_assign" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/array/ops.rs.html#32-34">source</a><a href="#method.bitand_assign" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/ops/bit/trait.BitAndAssign.html#tymethod.bitand_assign" class="fnname">bitand_assign</a>(&amp;mut self, rhs: <a class="struct" href="../array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;A, O&gt;)</h4></section></summary><div class='docblock'>Performs the <code>&amp;=</code> operation. <a href="https://doc.rust-lang.org/1.66.1/core/ops/bit/trait.BitAndAssign.html#tymethod.bitand_assign">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BitAndAssign%3CBitBox%3CT%2C%20O%3E%3E-for-BitSlice%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/boxed/ops.rs.html#28-37">source</a><a href="#impl-BitAndAssign%3CBitBox%3CT%2C%20O%3E%3E-for-BitSlice%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/bit/trait.BitAndAssign.html" title="trait core::ops::bit::BitAndAssign">BitAndAssign</a>&lt;<a class="struct" href="../boxed/struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt;&gt; for <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.bitand_assign-2" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/boxed/ops.rs.html#34-36">source</a><a href="#method.bitand_assign-2" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/ops/bit/trait.BitAndAssign.html#tymethod.bitand_assign" class="fnname">bitand_assign</a>(&amp;mut self, rhs: <a class="struct" href="../boxed/struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt;)</h4></section></summary><div class='docblock'>Performs the <code>&amp;=</code> operation. <a href="https://doc.rust-lang.org/1.66.1/core/ops/bit/trait.BitAndAssign.html#tymethod.bitand_assign">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BitAndAssign%3CBitVec%3CT%2C%20O%3E%3E-for-BitSlice%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/ops.rs.html#31-40">source</a><a href="#impl-BitAndAssign%3CBitVec%3CT%2C%20O%3E%3E-for-BitSlice%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/bit/trait.BitAndAssign.html" title="trait core::ops::bit::BitAndAssign">BitAndAssign</a>&lt;<a class="struct" href="../vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;T, O&gt;&gt; for <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.bitand_assign-5" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/ops.rs.html#37-39">source</a><a href="#method.bitand_assign-5" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/ops/bit/trait.BitAndAssign.html#tymethod.bitand_assign" class="fnname">bitand_assign</a>(&amp;mut self, rhs: <a class="struct" href="../vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;T, O&gt;)</h4></section></summary><div class='docblock'>Performs the <code>&amp;=</code> operation. <a href="https://doc.rust-lang.org/1.66.1/core/ops/bit/trait.BitAndAssign.html#tymethod.bitand_assign">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BitField-for-BitSlice%3CT%2C%20Lsb0%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/field.rs.html#113-247">source</a><a href="#impl-BitField-for-BitSlice%3CT%2C%20Lsb0%3E" class="anchor"></a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a> for <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, <a class="struct" href="../order/struct.Lsb0.html" title="struct bitvec::order::Lsb0">Lsb0</a>&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section></summary><div class="docblock"><h4 id="lsb0-bit-field-behavior"><a href="#lsb0-bit-field-behavior"><code>Lsb0</code> Bit-Field Behavior</a></h4>
<p><code>BitField</code> has no requirements about the in-memory representation or layout of
stored integers within a bit-slice, only that round-tripping an integer through
a store and a load of the same element suffix on the same bit-slice is
idempotent (with respect to sign truncation).</p>
<p><code>Lsb0</code> provides a contiguous translation from bit-index to real memory: for any
given bit index <code>n</code> and its position <code>P(n)</code>, <code>P(n + 1)</code> is <code>P(n) + 1</code>. This
allows it to provide batched behavior: since the section of contiguous indices
used within an element translates to a section of contiguous bits in real
memory, the transaction is always a single shift/mask operation.</p>
<p>Each implemented method contains documentation and examples showing exactly how
the abstract integer space is mapped to real memory.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.load_le" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/field.rs.html#118-151">source</a><a href="#method.load_le" class="anchor"></a><h4 class="code-header">fn <a href="../field/trait.BitField.html#tymethod.load_le" class="fnname">load_le</a>&lt;I&gt;(&amp;self) -&gt; I<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="../../funty/trait.Integral.html" title="trait funty::Integral">Integral</a>,</span></h4></section></summary><div class="docblock"><h5 id="lsb0-little-endian-integer-loading"><a href="#lsb0-little-endian-integer-loading"><code>Lsb0</code> Little-Endian Integer Loading</a></h5>
<p>This implementation uses the <code>Lsb0</code> bit-ordering to determine <em>which</em> bits in a
partially-occupied memory element contain the contents of an integer to be
loaded, using little-endian element ordering.</p>
<p>See the <a href="../field/trait.BitField.html#tymethod.load_le">trait method definition</a> for an overview of what element ordering
means.</p>
<h6 id="signed-integer-loading"><a href="#signed-integer-loading">Signed-Integer Loading</a></h6>
<p>As described in the trait definition, when loading as a signed integer, the most
significant bit <em>loaded</em> from memory is sign-extended to the full width of the
returned type. In this method, that means the most-significant loaded bit of the
final element.</p>
<h6 id="examples-90"><a href="#examples-90">Examples</a></h6>
<p>In each memory element, the <code>Lsb0</code> ordering counts indices leftward from the
right edge:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>raw = <span class="number">0b00_10110_0u8</span>;
<span class="comment">//           76 54321 0
//              ^ sign bit
</span><span class="macro">assert_eq!</span>(
  raw.view_bits::&lt;Lsb0&gt;()
     [<span class="number">1 </span>.. <span class="number">6</span>]
     .load_le::&lt;u8&gt;(),
  <span class="number">0b000_10110</span>,
);
<span class="macro">assert_eq!</span>(
  raw.view_bits::&lt;Lsb0&gt;()
     [<span class="number">1 </span>.. <span class="number">6</span>]
     .load_le::&lt;i8&gt;(),
  <span class="number">0b111_10110u8 </span><span class="kw">as </span>i8,
);</code></pre></div>
<p>In bit-slices that span multiple elements, the little-endian element ordering
means that the slice index increases with numerical significance:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>raw = [
  <span class="number">0x8_Fu8</span>,
<span class="comment">//  7 0
  </span><span class="number">0x0_1u8</span>,
<span class="comment">// 15 8
  </span><span class="number">0b1111_0010u8</span>,
<span class="comment">//       ^ sign bit
// 23       16
</span>];
<span class="macro">assert_eq!</span>(
  raw.view_bits::&lt;Lsb0&gt;()
     [<span class="number">4 </span>.. <span class="number">20</span>]
     .load_le::&lt;u16&gt;(),
  <span class="number">0x2018u16</span>,
);</code></pre></div>
<p>Note that while these examples use <code>u8</code> storage for convenience in displaying
the literals, <code>BitField</code> operates identically with <em>any</em> storage type. As most
machines use little-endian <em>byte ordering</em> within wider element types, and
<code>bitvec</code> exclusively operates on <em>elements</em>, the actual bytes of memory may
rapidly start to behave oddly when translating between numeric literals and
in-memory representation.</p>
<p>The <a href="https://bitvecto-rs.github.io/bitvec/memory-layout">user guide</a> has a chapter that translates bit indices into memory positions
for each combination of <code>&lt;T: BitStore, O: BitOrder&gt;</code>, and may be of additional
use when choosing a combination of type parameters and load functions.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.load_be" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/field.rs.html#155-184">source</a><a href="#method.load_be" class="anchor"></a><h4 class="code-header">fn <a href="../field/trait.BitField.html#tymethod.load_be" class="fnname">load_be</a>&lt;I&gt;(&amp;self) -&gt; I<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="../../funty/trait.Integral.html" title="trait funty::Integral">Integral</a>,</span></h4></section></summary><div class="docblock"><h5 id="lsb0-big-endian-integer-loading"><a href="#lsb0-big-endian-integer-loading"><code>Lsb0</code> Big-Endian Integer Loading</a></h5>
<p>This implementation uses the <code>Lsb0</code> bit-ordering to determine <em>which</em> bits in a
partially-occupied memory element contain the contents of an integer to be
loaded, using big-endian element ordering.</p>
<p>See the <a href="../field/trait.BitField.html#tymethod.load_le">trait method definition</a> for an overview of what element ordering
means.</p>
<h6 id="signed-integer-loading-1"><a href="#signed-integer-loading-1">Signed-Integer Loading</a></h6>
<p>As described in the trait definition, when loading as a signed integer, the most
significant bit <em>loaded</em> from memory is sign-extended to the full width of the
returned type. In this method, that means that the most-significant bit of the
first element.</p>
<h6 id="examples-91"><a href="#examples-91">Examples</a></h6>
<p>In each memory element, the <code>Lsb0</code> ordering counts indices leftward from the
right edge:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>raw = <span class="number">0b00_10110_0u8</span>;
<span class="comment">//           76 54321 0
//              ^ sign bit
</span><span class="macro">assert_eq!</span>(
  raw.view_bits::&lt;Lsb0&gt;()
     [<span class="number">1 </span>.. <span class="number">6</span>]
     .load_be::&lt;u8&gt;(),
  <span class="number">0b000_10110</span>,
);
<span class="macro">assert_eq!</span>(
  raw.view_bits::&lt;Lsb0&gt;()
     [<span class="number">1 </span>.. <span class="number">6</span>]
     .load_be::&lt;i8&gt;(),
  <span class="number">0b111_10110u8 </span><span class="kw">as </span>i8,
);</code></pre></div>
<p>In bit-slices that span multiple elements, the big-endian element ordering means
that the slice index increases while numeric significance decreases:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>raw = [
  <span class="number">0b0010_1111u8</span>,
<span class="comment">//  ^ sign bit
//  7       0
  </span><span class="number">0x0_1u8</span>,
<span class="comment">// 15 8
  </span><span class="number">0xF_8u8</span>,
<span class="comment">// 23 16
</span>];
<span class="macro">assert_eq!</span>(
  raw.view_bits::&lt;Lsb0&gt;()
     [<span class="number">4 </span>.. <span class="number">20</span>]
     .load_be::&lt;u16&gt;(),
  <span class="number">0x2018u16</span>,
);</code></pre></div>
<p>Note that while these examples use <code>u8</code> storage for convenience in displaying
the literals, <code>BitField</code> operates identically with <em>any</em> storage type. As most
machines use little-endian <em>byte ordering</em> within wider element types, and
<code>bitvec</code> exclusively operates on <em>elements</em>, the actual bytes of memory may
rapidly start to behave oddly when translating between numeric literals and
in-memory representation.</p>
<p>The <a href="https://bitvecto-rs.github.io/bitvec/memory-layout">user guide</a> has a chapter that translates bit indices into memory positions
for each combination of <code>&lt;T: BitStore, O: BitOrder&gt;</code>, and may be of additional
use when choosing a combination of type parameters and load functions.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.store_le" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/field.rs.html#188-215">source</a><a href="#method.store_le" class="anchor"></a><h4 class="code-header">fn <a href="../field/trait.BitField.html#tymethod.store_le" class="fnname">store_le</a>&lt;I&gt;(&amp;mut self, value: I)<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="../../funty/trait.Integral.html" title="trait funty::Integral">Integral</a>,</span></h4></section></summary><div class="docblock"><h5 id="lsb0-little-endian-integer-storing"><a href="#lsb0-little-endian-integer-storing"><code>Lsb0</code> Little-Endian Integer Storing</a></h5>
<p>This implementation uses the <code>Lsb0</code> bit-ordering to determine <em>which</em> bits in a
partially-occupied memory element are used for storage, using little-endian
element ordering.</p>
<p>See the <a href="../field/trait.BitField.html#tymethod.store_le">trait method definition</a> for an overview of what element ordering
means.</p>
<h6 id="narrowing-behavior"><a href="#narrowing-behavior">Narrowing Behavior</a></h6>
<p>Integers are truncated from the high end. When storing into a bit-slice of
length <code>n</code>, the <code>n</code> least numerically significant bits are stored, and any
remaining high bits are ignored.</p>
<p>Be aware of this behavior if you are storing signed integers! The signed integer
<code>-14i8</code> (bit pattern <code>0b1111_0010u8</code>) will, when stored into and loaded back
from a 4-bit slice, become the value <code>2i8</code>.</p>
<h6 id="examples-92"><a href="#examples-92">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>raw = <span class="number">0u8</span>;
raw.view_bits_mut::&lt;Lsb0&gt;()
   [<span class="number">1 </span>.. <span class="number">6</span>]
   .store_le(<span class="number">22u8</span>);
<span class="macro">assert_eq!</span>(raw, <span class="number">0b00_10110_0</span>);
<span class="comment">//                 76 54321 0
</span>raw.view_bits_mut::&lt;Lsb0&gt;()
   [<span class="number">1 </span>.. <span class="number">6</span>]
   .store_le(-<span class="number">10i8</span>);
<span class="macro">assert_eq!</span>(raw, <span class="number">0b00_10110_0</span>);</code></pre></div>
<p>In bit-slices that span multiple elements, the little-endian element ordering
means that the slice index increases with numerical significance:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>raw = [!<span class="number">0u8</span>; <span class="number">3</span>];
raw.view_bits_mut::&lt;Lsb0&gt;()
   [<span class="number">4 </span>.. <span class="number">20</span>]
   .store_le(<span class="number">0x2018u16</span>);
<span class="macro">assert_eq!</span>(raw, [
  <span class="number">0x8_F</span>,
<span class="comment">//  7 0
  </span><span class="number">0x0_1</span>,
<span class="comment">// 15 8
  </span><span class="number">0xF_2</span>,
<span class="comment">// 23 16
</span>]);</code></pre></div>
<p>Note that while these examples use <code>u8</code> storage for convenience in displaying
the literals, <code>BitField</code> operates identically with <em>any</em> storage type. As most
machines use little-endian <em>byte ordering</em> within wider element types, and
<code>bitvec</code> exclusively operates on <em>elements</em>, the actual bytes of memory may
rapidly start to behave oddly when translating between numeric literals and
in-memory representation.</p>
<p>The <a href="https://bitvecto-rs.github.io/bitvec/memory-layout">user guide</a> has a chapter that translates bit indices into memory positions
for each combination of <code>&lt;T: BitStore, O: BitOrder&gt;</code>, and may be of additional
use when choosing a combination of type parameters and store functions.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.store_be" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/field.rs.html#219-246">source</a><a href="#method.store_be" class="anchor"></a><h4 class="code-header">fn <a href="../field/trait.BitField.html#tymethod.store_be" class="fnname">store_be</a>&lt;I&gt;(&amp;mut self, value: I)<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="../../funty/trait.Integral.html" title="trait funty::Integral">Integral</a>,</span></h4></section></summary><div class="docblock"><h5 id="lsb0-big-endian-integer-storing"><a href="#lsb0-big-endian-integer-storing"><code>Lsb0</code> Big-Endian Integer Storing</a></h5>
<p>This implementation uses the <code>Lsb0</code> bit-ordering to determine <em>which</em> bits in a
partially-occupied memory element are used for storage, using big-endian element
ordering.</p>
<p>See the <a href="../field/trait.BitField.html#tymethod.store_be">trait method definition</a> for an overview of what element ordering
means.</p>
<h6 id="narrowing-behavior-1"><a href="#narrowing-behavior-1">Narrowing Behavior</a></h6>
<p>Integers are truncated from the high end. When storing into a bit-slice of
length <code>n</code>, the <code>n</code> least numerically significant bits are stored, and any
remaining high bits are ignored.</p>
<p>Be aware of this behavior if you are storing signed integers! The signed integer
<code>-14i8</code> (bit pattern <code>0b1111_0010u8</code>) will, when stored into and loaded back
from a 4-bit slice, become the value <code>2i8</code>.</p>
<h6 id="examples-93"><a href="#examples-93">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>raw = <span class="number">0u8</span>;
raw.view_bits_mut::&lt;Lsb0&gt;()
   [<span class="number">1 </span>.. <span class="number">6</span>]
   .store_be(<span class="number">22u8</span>);
<span class="macro">assert_eq!</span>(raw, <span class="number">0b00_10110_0</span>);
<span class="comment">//                 76 54321 0
</span>raw.view_bits_mut::&lt;Lsb0&gt;()
   [<span class="number">1 </span>.. <span class="number">6</span>]
   .store_be(-<span class="number">10i8</span>);
<span class="macro">assert_eq!</span>(raw, <span class="number">0b00_10110_0</span>);</code></pre></div>
<p>In bit-slices that span multiple elements, the big-endian element ordering means
that the slice index increases while numerical significance decreases:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>raw = [!<span class="number">0u8</span>; <span class="number">3</span>];
raw.view_bits_mut::&lt;Lsb0&gt;()
   [<span class="number">4 </span>.. <span class="number">20</span>]
   .store_be(<span class="number">0x2018u16</span>);
<span class="macro">assert_eq!</span>(raw, [
  <span class="number">0x2_F</span>,
<span class="comment">//  7 0
  </span><span class="number">0x0_1</span>,
<span class="comment">// 15 8
  </span><span class="number">0xF_8</span>,
<span class="comment">// 23 16
</span>]);</code></pre></div>
<p>Note that while these examples use <code>u8</code> storage for convenience in displaying
the literals, <code>BitField</code> operates identically with <em>any</em> storage type. As most
machines use little-endian <em>byte ordering</em> within wider element types, and
<code>bitvec</code> exclusively operates on <em>elements</em>, the actual bytes of memory may
rapidly start to behave oddly when translating between numeric literals and
in-memory representation.</p>
<p>The <a href="https://bitvecto-rs.github.io/bitvec/memory-layout">user guide</a> has a chapter that translates bit indices into memory positions
for each combination of <code>&lt;T: BitStore, O: BitOrder&gt;</code>, and may be of additional
use when choosing a combination of type parameters and store functions.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.load" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/field.rs.html#46-67">source</a><a href="#method.load" class="anchor"></a><h4 class="code-header">fn <a href="../field/trait.BitField.html#method.load" class="fnname">load</a>&lt;I&gt;(&amp;self) -&gt; I<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="../../funty/trait.Integral.html" title="trait funty::Integral">Integral</a>,</span></h4></section></summary><div class='docblock'>Integer Loading <a href="../field/trait.BitField.html#method.load">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.store" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/field.rs.html#72-93">source</a><a href="#method.store" class="anchor"></a><h4 class="code-header">fn <a href="../field/trait.BitField.html#method.store" class="fnname">store</a>&lt;I&gt;(&amp;mut self, value: I)<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="../../funty/trait.Integral.html" title="trait funty::Integral">Integral</a>,</span></h4></section></summary><div class='docblock'>Integer Storing <a href="../field/trait.BitField.html#method.store">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BitField-for-BitSlice%3CT%2C%20Msb0%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/field.rs.html#250-389">source</a><a href="#impl-BitField-for-BitSlice%3CT%2C%20Msb0%3E" class="anchor"></a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a> for <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, <a class="struct" href="../order/struct.Msb0.html" title="struct bitvec::order::Msb0">Msb0</a>&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section></summary><div class="docblock"><h4 id="msb0-bit-field-behavior"><a href="#msb0-bit-field-behavior"><code>Msb0</code> Bit-Field Behavior</a></h4>
<p><code>BitField</code> has no requirements about the in-memory representation or layout of
stored integers within a bit-slice, only that round-tripping an integer through
a store and a load of the same element suffix on the same bit-slice is
idempotent (with respect to sign truncation).</p>
<p><code>Msb0</code> provides a contiguous translation from bit-index to real memory: for any
given bit index <code>n</code> and its position <code>P(n)</code>, <code>P(n + 1)</code> is <code>P(n) - 1</code>. This
allows it to provide batched behavior: since the section of contiguous indices
used within an element translates to a section of contiguous bits in real
memory, the transaction is always a single shift-mask operation.</p>
<p>Each implemented method contains documentation and examples showing exactly how
the abstract integer space is mapped to real memory.</p>
<h5 id="notes-4"><a href="#notes-4">Notes</a></h5>
<p>In particular, note that while <code>Msb0</code> indexes bits from the most significant
down to the least, and integers index from the least up to the most, this
<strong>does not</strong> reörder any bits of the integer value! This ordering only finds a
region in real memory; it does <em>not</em> affect the partial-integer contents stored
in that region.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.load_le-1" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/field.rs.html#255-289">source</a><a href="#method.load_le-1" class="anchor"></a><h4 class="code-header">fn <a href="../field/trait.BitField.html#tymethod.load_le" class="fnname">load_le</a>&lt;I&gt;(&amp;self) -&gt; I<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="../../funty/trait.Integral.html" title="trait funty::Integral">Integral</a>,</span></h4></section></summary><div class="docblock"><h5 id="msb0-little-endian-integer-loading"><a href="#msb0-little-endian-integer-loading"><code>Msb0</code> Little-Endian Integer Loading</a></h5>
<p>This implementation uses the <code>Msb0</code> bit-ordering to determine <em>which</em> bits in a
partially-occupied memory element contain the contents of an integer to be
loaded, using little-endian element ordering.</p>
<p>See the <a href="../field/trait.BitField.html#tymethod.load_le">trait method definition</a> for an overview of what element ordering
means.</p>
<h6 id="signed-integer-loading-2"><a href="#signed-integer-loading-2">Signed-Integer Loading</a></h6>
<p>As described in the trait definition, when loading as a signed integer, the most
significant bit <em>loaded</em> from memory is sign-extended to the full width of the
returned type. In this method, that means the most-significant loaded bit of the
final element.</p>
<h6 id="examples-94"><a href="#examples-94">Examples</a></h6>
<p>In each memory element, the <code>Msb0</code> ordering counts indices rightward from the
left edge:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>raw = <span class="number">0b00_10110_0u8</span>;
<span class="comment">//           01 23456 7
//              ^ sign bit
</span><span class="macro">assert_eq!</span>(
  raw.view_bits::&lt;Msb0&gt;()
     [<span class="number">2 </span>.. <span class="number">7</span>]
     .load_le::&lt;u8&gt;(),
  <span class="number">0b000_10110</span>,
);
<span class="macro">assert_eq!</span>(
  raw.view_bits::&lt;Msb0&gt;()
     [<span class="number">2 </span>.. <span class="number">7</span>]
     .load_le::&lt;i8&gt;(),
  <span class="number">0b111_10110u8 </span><span class="kw">as </span>i8,
);</code></pre></div>
<p>In bit-slices that span multiple elements, the little-endian element ordering
means that the slice index increases with numerical significance:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>raw = [
  <span class="number">0xF_8u8</span>,
<span class="comment">//  0 7
  </span><span class="number">0x0_1u8</span>,
<span class="comment">//  8 15
  </span><span class="number">0b0010_1111u8</span>,
<span class="comment">//  ^ sign bit
// 16       23
</span>];
<span class="macro">assert_eq!</span>(
  raw.view_bits::&lt;Msb0&gt;()
     [<span class="number">4 </span>.. <span class="number">20</span>]
     .load_le::&lt;u16&gt;(),
  <span class="number">0x2018u16</span>,
);</code></pre></div>
<p>Note that while these examples use <code>u8</code> storage for convenience in displaying
the literals, <code>BitField</code> operates identically with <em>any</em> storage type. As most
machines use little-endian <em>byte ordering</em> within wider element types, and
<code>bitvec</code> exclusively operates on <em>elements</em>, the actual bytes of memory may
rapidly start to behave oddly when translating between numeric literals and
in-memory representation.</p>
<p>The <a href="https://bitvecto-rs.github.io/bitvec/memory-layout">user guide</a> has a chapter that translates bit indices into memory positions
for each combination of <code>&lt;T: BitStore, O: BitOrder&gt;</code>, and may be of additional
use when choosing a combination of type parameters and load functions.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.load_be-1" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/field.rs.html#293-325">source</a><a href="#method.load_be-1" class="anchor"></a><h4 class="code-header">fn <a href="../field/trait.BitField.html#tymethod.load_be" class="fnname">load_be</a>&lt;I&gt;(&amp;self) -&gt; I<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="../../funty/trait.Integral.html" title="trait funty::Integral">Integral</a>,</span></h4></section></summary><div class="docblock"><h5 id="msb0-big-endian-integer-loading"><a href="#msb0-big-endian-integer-loading"><code>Msb0</code> Big-Endian Integer Loading</a></h5>
<p>This implementation uses the <code>Msb0</code> bit-ordering to determine <em>which</em> bits in a
partially-occupied memory element contain the contents of an integer to be
loaded, using big-endian element ordering.</p>
<p>See the <a href="../field/trait.BitField.html#tymethod.load_le">trait method definition</a> for an overview of what element ordering
means.</p>
<h6 id="signed-integer-loading-3"><a href="#signed-integer-loading-3">Signed-Integer Loading</a></h6>
<p>As described in the trait definition, when loading as a signed integer, the most
significant bit <em>loaded</em> from memory is sign-extended to the full width of the
returned type. In this method, that means the most-significant loaded bit of the
first element.</p>
<h6 id="examples-95"><a href="#examples-95">Examples</a></h6>
<p>In each memory element, the <code>Msb0</code> ordering counts indices rightward from the
left edge:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>raw = <span class="number">0b00_10110_0u8</span>;
<span class="comment">//           01 23456 7
//              ^ sign bit
</span><span class="macro">assert_eq!</span>(
  raw.view_bits::&lt;Msb0&gt;()
     [<span class="number">2 </span>.. <span class="number">7</span>]
     .load_be::&lt;u8&gt;(),
  <span class="number">0b000_10110</span>,
);
<span class="macro">assert_eq!</span>(
  raw.view_bits::&lt;Msb0&gt;()
     [<span class="number">2 </span>.. <span class="number">7</span>]
     .load_be::&lt;i8&gt;(),
  <span class="number">0b111_10110u8 </span><span class="kw">as </span>i8,
);</code></pre></div>
<p>In bit-slices that span multiple elements, the big-endian element ordering means
that the slice index increases with numerical significance:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>raw = [
  <span class="number">0b1111_0010u8</span>,
<span class="comment">//       ^ sign bit
//  0       7
  </span><span class="number">0x0_1u8</span>,
<span class="comment">//  8 15
  </span><span class="number">0x8_Fu8</span>,
<span class="comment">// 16 23
</span>];
<span class="macro">assert_eq!</span>(
  raw.view_bits::&lt;Msb0&gt;()
     [<span class="number">4 </span>.. <span class="number">20</span>]
     .load_be::&lt;u16&gt;(),
  <span class="number">0x2018u16</span>,
);</code></pre></div>
<p>Note that while these examples use <code>u8</code> storage for convenience in displaying
the literals, <code>BitField</code> operates identically with <em>any</em> storage type. As most
machines use little-endian <em>byte ordering</em> within wider element types, and
<code>bitvec</code> exclusively operates on <em>elements</em>, the actual bytes of memory may
rapidly start to behave oddly when translating between numeric literals and
in-memory representation.</p>
<p>The <a href="https://bitvecto-rs.github.io/bitvec/memory-layout">user guide</a> has a chapter that translates bit indices into memory positions
for each combination of <code>&lt;T: BitStore, O: BitOrder&gt;</code>, and may be of additional
use when choosing a combination of type parameters and load functions.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.store_le-1" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/field.rs.html#329-357">source</a><a href="#method.store_le-1" class="anchor"></a><h4 class="code-header">fn <a href="../field/trait.BitField.html#tymethod.store_le" class="fnname">store_le</a>&lt;I&gt;(&amp;mut self, value: I)<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="../../funty/trait.Integral.html" title="trait funty::Integral">Integral</a>,</span></h4></section></summary><div class="docblock"><h5 id="msb0-little-endian-integer-storing"><a href="#msb0-little-endian-integer-storing"><code>Msb0</code> Little-Endian Integer Storing</a></h5>
<p>This implementation uses the <code>Msb0</code> bit-ordering to determine <em>which</em> bits in a
partially-occupied memory element are used for storage, using little-endian
element ordering.</p>
<p>See the <a href="../field/trait.BitField.html#tymethod.store_le">trait method definition</a> for an overview of what element ordering
means.</p>
<h6 id="narrowing-behavior-2"><a href="#narrowing-behavior-2">Narrowing Behavior</a></h6>
<p>Integers are truncated from the high end. When storing into a bit-slice of
length <code>n</code>, the <code>n</code> least numerically significant bits are stored, and any
remaining high bits are ignored.</p>
<p>Be aware of this behavior if you are storing signed integers! The signed integer
<code>-14i8</code> (bit pattern <code>0b1111_0010u8</code>) will, when stored into and loaded back
from a 4-bit slice, become the value <code>2i8</code>.</p>
<h6 id="examples-96"><a href="#examples-96">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>raw = <span class="number">0u8</span>;
raw.view_bits_mut::&lt;Msb0&gt;()
   [<span class="number">2 </span>.. <span class="number">7</span>]
   .store_le(<span class="number">22u8</span>);
<span class="macro">assert_eq!</span>(raw, <span class="number">0b00_10110_0</span>);
<span class="comment">//                 01 23456 7
</span>raw.view_bits_mut::&lt;Msb0&gt;()
   [<span class="number">2 </span>.. <span class="number">7</span>]
   .store_le(-<span class="number">10i8</span>);
<span class="macro">assert_eq!</span>(raw, <span class="number">0b00_10110_0</span>);</code></pre></div>
<p>In bit-slices that span multiple elements, the little-endian element ordering
means that the slice index increases with numerical significance:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>raw = [!<span class="number">0u8</span>; <span class="number">3</span>];
raw.view_bits_mut::&lt;Msb0&gt;()
   [<span class="number">4 </span>.. <span class="number">20</span>]
   .store_le(<span class="number">0x2018u16</span>);
<span class="macro">assert_eq!</span>(raw, [
  <span class="number">0xF_8</span>,
<span class="comment">//  0 7
  </span><span class="number">0x0_1</span>,
<span class="comment">//  8 15
  </span><span class="number">0x2_F</span>,
<span class="comment">// 16 23
</span>]);</code></pre></div>
<p>Note that while these examples use <code>u8</code> storage for convenience in displaying
the literals, <code>BitField</code> operates identically with <em>any</em> storage type. As most
machines use little-endian <em>byte ordering</em> within wider element types, and
<code>bitvec</code> exclusively operates on <em>elements</em>, the actual bytes of memory may
rapidly start to behave oddly when translating between numeric literals and
in-memory representation.</p>
<p>The <a href="https://bitvecto-rs.github.io/bitvec/memory-layout">user guide</a> has a chapter that translates bit indices into memory positions
for each combination of <code>&lt;T: BitStore, O: BitOrder&gt;</code>, and may be of additional
use when choosing a combination of type parameters and store functions.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.store_be-1" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/field.rs.html#361-388">source</a><a href="#method.store_be-1" class="anchor"></a><h4 class="code-header">fn <a href="../field/trait.BitField.html#tymethod.store_be" class="fnname">store_be</a>&lt;I&gt;(&amp;mut self, value: I)<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="../../funty/trait.Integral.html" title="trait funty::Integral">Integral</a>,</span></h4></section></summary><div class="docblock"><h5 id="msb0-big-endian-integer-storing"><a href="#msb0-big-endian-integer-storing"><code>Msb0</code> Big-Endian Integer Storing</a></h5>
<p>This implementation uses the <code>Msb0</code> bit-ordering to determine <em>which</em> bits in a
partially-occupied memory element are used for storage, using big-endian element
ordering.</p>
<p>See the <a href="../field/trait.BitField.html#tymethod.store_be">trait method definition</a> for an overview of what element ordering
means.</p>
<h6 id="narrowing-behavior-3"><a href="#narrowing-behavior-3">Narrowing Behavior</a></h6>
<p>Integers are truncated from the high end. When storing into a bit-slice of
length <code>n</code>, the <code>n</code> least numerically significant bits are stored, and any
remaining high bits are ignored.</p>
<p>Be aware of this behavior if you are storing signed integers! The signed integer
<code>-14i8</code> (bit pattern <code>0b1111_0010u8</code>) will, when stored into and loaded back
from a 4-bit slice, become the value <code>2i8</code>.</p>
<h6 id="examples-97"><a href="#examples-97">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>raw = <span class="number">0u8</span>;
raw.view_bits_mut::&lt;Msb0&gt;()
   [<span class="number">2 </span>.. <span class="number">7</span>]
   .store_be(<span class="number">22u8</span>);
<span class="macro">assert_eq!</span>(raw, <span class="number">0b00_10110_0</span>);
<span class="comment">//                 01 23456 7
</span>raw.view_bits_mut::&lt;Msb0&gt;()
   [<span class="number">2 </span>.. <span class="number">7</span>]
   .store_be(-<span class="number">10i8</span>);
<span class="macro">assert_eq!</span>(raw, <span class="number">0b00_10110_0</span>);</code></pre></div>
<p>In bit-slices that span multiple elements, the big-endian element ordering means
that the slice index increases while numerical significance decreases:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>raw = [!<span class="number">0u8</span>; <span class="number">3</span>];
raw.view_bits_mut::&lt;Msb0&gt;()
   [<span class="number">4 </span>.. <span class="number">20</span>]
   .store_be(<span class="number">0x2018u16</span>);
<span class="macro">assert_eq!</span>(raw, [
  <span class="number">0xF_2</span>,
<span class="comment">//  0 7
  </span><span class="number">0x0_1</span>,
<span class="comment">//  8 15
  </span><span class="number">0x8_F</span>,
<span class="comment">// 16 23
</span>]);</code></pre></div>
<p>Note that while these examples use <code>u8</code> storage for convenience in displaying
the literals, <code>BitField</code> operates identically with <em>any</em> storage type. As most
machines use little-endian <em>byte ordering</em> within wider element types, and
<code>bitvec</code> exclusively operates on <em>elements</em>, the actual bytes of memory may
rapidly start to behave oddly when translating between numeric literals and
in-memory representation.</p>
<p>The <a href="https://bitvecto-rs.github.io/bitvec/memory-layout">user guide</a> has a chapter that translates bit indices into memory positions
for each combination of <code>&lt;T: BitStore, O: BitOrder&gt;</code>, and may be of additional
use when choosing a combination of type parameters and store functions.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.load-1" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/field.rs.html#46-67">source</a><a href="#method.load-1" class="anchor"></a><h4 class="code-header">fn <a href="../field/trait.BitField.html#method.load" class="fnname">load</a>&lt;I&gt;(&amp;self) -&gt; I<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="../../funty/trait.Integral.html" title="trait funty::Integral">Integral</a>,</span></h4></section></summary><div class='docblock'>Integer Loading <a href="../field/trait.BitField.html#method.load">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.store-1" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/field.rs.html#72-93">source</a><a href="#method.store-1" class="anchor"></a><h4 class="code-header">fn <a href="../field/trait.BitField.html#method.store" class="fnname">store</a>&lt;I&gt;(&amp;mut self, value: I)<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="../../funty/trait.Integral.html" title="trait funty::Integral">Integral</a>,</span></h4></section></summary><div class='docblock'>Integer Storing <a href="../field/trait.BitField.html#method.store">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BitOrAssign%3C%26BitArray%3CA%2C%20O%3E%3E-for-BitSlice%3CA%3A%3AStore%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/array/ops.rs.html#89-98">source</a><a href="#impl-BitOrAssign%3C%26BitArray%3CA%2C%20O%3E%3E-for-BitSlice%3CA%3A%3AStore%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;A, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/bit/trait.BitOrAssign.html" title="trait core::ops::bit::BitOrAssign">BitOrAssign</a>&lt;&amp;<a class="struct" href="../array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;A, O&gt;&gt; for <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;A::<a class="associatedtype" href="../view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;A: <a class="trait" href="../view/trait.BitViewSized.html" title="trait bitvec::view::BitViewSized">BitViewSized</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.bitor_assign-1" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/array/ops.rs.html#95-97">source</a><a href="#method.bitor_assign-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/ops/bit/trait.BitOrAssign.html#tymethod.bitor_assign" class="fnname">bitor_assign</a>(&amp;mut self, rhs: &amp;<a class="struct" href="../array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;A, O&gt;)</h4></section></summary><div class='docblock'>Performs the <code>|=</code> operation. <a href="https://doc.rust-lang.org/1.66.1/core/ops/bit/trait.BitOrAssign.html#tymethod.bitor_assign">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BitOrAssign%3C%26BitBox%3CT%2C%20O%3E%3E-for-BitSlice%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/boxed/ops.rs.html#91-100">source</a><a href="#impl-BitOrAssign%3C%26BitBox%3CT%2C%20O%3E%3E-for-BitSlice%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/bit/trait.BitOrAssign.html" title="trait core::ops::bit::BitOrAssign">BitOrAssign</a>&lt;&amp;<a class="struct" href="../boxed/struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt;&gt; for <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.bitor_assign-3" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/boxed/ops.rs.html#97-99">source</a><a href="#method.bitor_assign-3" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/ops/bit/trait.BitOrAssign.html#tymethod.bitor_assign" class="fnname">bitor_assign</a>(&amp;mut self, rhs: &amp;<a class="struct" href="../boxed/struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt;)</h4></section></summary><div class='docblock'>Performs the <code>|=</code> operation. <a href="https://doc.rust-lang.org/1.66.1/core/ops/bit/trait.BitOrAssign.html#tymethod.bitor_assign">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BitOrAssign%3C%26BitSlice%3CT2%2C%20O2%3E%3E-for-BitSlice%3CT1%2C%20O1%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/ops.rs.html#67-94">source</a><a href="#impl-BitOrAssign%3C%26BitSlice%3CT2%2C%20O2%3E%3E-for-BitSlice%3CT1%2C%20O1%3E" class="anchor"></a><h3 class="code-header">impl&lt;T1, T2, O1, O2&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/bit/trait.BitOrAssign.html" title="trait core::ops::bit::BitOrAssign">BitOrAssign</a>&lt;&amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T2, O2&gt;&gt; for <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T1, O1&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T1: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O1: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.bitor_assign-4" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/ops.rs.html#76-93">source</a><a href="#method.bitor_assign-4" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/ops/bit/trait.BitOrAssign.html#tymethod.bitor_assign" class="fnname">bitor_assign</a>(&amp;mut self, rhs: &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T2, O2&gt;)</h4></section></summary><div class="docblock"><h5 id="boolean-arithmetic-1"><a href="#boolean-arithmetic-1">Boolean Arithmetic</a></h5>
<p>This merges another bit-slice into <code>self</code> with a Boolean arithmetic operation.
If the other bit-slice is shorter than <code>self</code>, it is zero-extended. For <code>BitAnd</code>,
this clears all excess bits of <code>self</code> to <code>0</code>; for <code>BitOr</code> and <code>BitXor</code>, it
leaves them untouched</p>
<h6 id="behavior-2"><a href="#behavior-2">Behavior</a></h6>
<p>The Boolean operation proceeds across each bit-slice in iteration order. This is
<code>3O(n)</code> in the length of the shorter of <code>self</code> and <code>rhs</code>. However, it can be
accelerated if <code>rhs</code> has the same type parameters as <code>self</code>, and both are using
one of the orderings provided by <code>bitvec</code>. In this case, the implementation
specializes to use <code>BitField</code> batch operations to operate on the slices one word
at a time, rather than one bit.</p>
<p>Acceleration is not currently provided for custom bit-orderings that use the
same storage type.</p>
<h6 id="pre-10-behavior-1"><a href="#pre-10-behavior-1">Pre-<code>1.0</code> Behavior</a></h6>
<p>In the <code>0.</code> development series, Boolean arithmetic was implemented against all
<code>I: Iterator&lt;Item = bool&gt;</code>. This allowed code such as <code>bits |= [false, true];</code>,
but forbad acceleration in the most common use case (combining two bit-slices)
because <code>BitSlice</code> is not such an iterator.</p>
<p>Usage surveys indicate that it is better for the arithmetic operators to operate
on bit-slices, and to allow the possibility of specialized acceleration, rather
than to allow folding against any iterator of <code>bool</code>s.</p>
<p>If pre-<code>1.0</code> code relies on this behavior specifically, and has non-<code>BitSlice</code>
arguments to the Boolean sigils, then they will need to be replaced with the
equivalent loop.</p>
<h6 id="examples-99"><a href="#examples-99">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>a = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="kw">let </span>b = <span class="macro">bits!</span>[    <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];

<span class="kw-2">*</span>a ^= b;
<span class="macro">assert_eq!</span>(a, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]);

<span class="kw">let </span>c = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="kw">let </span>d = [<span class="bool-val">false</span>, <span class="bool-val">true</span>, <span class="bool-val">false</span>, <span class="bool-val">true</span>];

<span class="comment">// no longer allowed
// c &amp;= d.into_iter().by_vals();
</span><span class="kw">for </span>(<span class="kw-2">mut </span>c, d) <span class="kw">in </span>c.iter_mut().zip(d.into_iter())
{
  <span class="kw-2">*</span>c ^= d;
}
<span class="macro">assert_eq!</span>(c, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]);</code></pre></div>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BitOrAssign%3C%26BitVec%3CT%2C%20O%3E%3E-for-BitSlice%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/ops.rs.html#96-105">source</a><a href="#impl-BitOrAssign%3C%26BitVec%3CT%2C%20O%3E%3E-for-BitSlice%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/bit/trait.BitOrAssign.html" title="trait core::ops::bit::BitOrAssign">BitOrAssign</a>&lt;&amp;<a class="struct" href="../vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;T, O&gt;&gt; for <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.bitor_assign-6" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/ops.rs.html#102-104">source</a><a href="#method.bitor_assign-6" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/ops/bit/trait.BitOrAssign.html#tymethod.bitor_assign" class="fnname">bitor_assign</a>(&amp;mut self, rhs: &amp;<a class="struct" href="../vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;T, O&gt;)</h4></section></summary><div class='docblock'>Performs the <code>|=</code> operation. <a href="https://doc.rust-lang.org/1.66.1/core/ops/bit/trait.BitOrAssign.html#tymethod.bitor_assign">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BitOrAssign%3CBitArray%3CA%2C%20O%3E%3E-for-BitSlice%3CA%3A%3AStore%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/array/ops.rs.html#77-86">source</a><a href="#impl-BitOrAssign%3CBitArray%3CA%2C%20O%3E%3E-for-BitSlice%3CA%3A%3AStore%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;A, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/bit/trait.BitOrAssign.html" title="trait core::ops::bit::BitOrAssign">BitOrAssign</a>&lt;<a class="struct" href="../array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;A, O&gt;&gt; for <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;A::<a class="associatedtype" href="../view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;A: <a class="trait" href="../view/trait.BitViewSized.html" title="trait bitvec::view::BitViewSized">BitViewSized</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.bitor_assign" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/array/ops.rs.html#83-85">source</a><a href="#method.bitor_assign" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/ops/bit/trait.BitOrAssign.html#tymethod.bitor_assign" class="fnname">bitor_assign</a>(&amp;mut self, rhs: <a class="struct" href="../array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;A, O&gt;)</h4></section></summary><div class='docblock'>Performs the <code>|=</code> operation. <a href="https://doc.rust-lang.org/1.66.1/core/ops/bit/trait.BitOrAssign.html#tymethod.bitor_assign">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BitOrAssign%3CBitBox%3CT%2C%20O%3E%3E-for-BitSlice%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/boxed/ops.rs.html#79-88">source</a><a href="#impl-BitOrAssign%3CBitBox%3CT%2C%20O%3E%3E-for-BitSlice%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/bit/trait.BitOrAssign.html" title="trait core::ops::bit::BitOrAssign">BitOrAssign</a>&lt;<a class="struct" href="../boxed/struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt;&gt; for <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.bitor_assign-2" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/boxed/ops.rs.html#85-87">source</a><a href="#method.bitor_assign-2" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/ops/bit/trait.BitOrAssign.html#tymethod.bitor_assign" class="fnname">bitor_assign</a>(&amp;mut self, rhs: <a class="struct" href="../boxed/struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt;)</h4></section></summary><div class='docblock'>Performs the <code>|=</code> operation. <a href="https://doc.rust-lang.org/1.66.1/core/ops/bit/trait.BitOrAssign.html#tymethod.bitor_assign">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BitOrAssign%3CBitVec%3CT%2C%20O%3E%3E-for-BitSlice%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/ops.rs.html#84-93">source</a><a href="#impl-BitOrAssign%3CBitVec%3CT%2C%20O%3E%3E-for-BitSlice%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/bit/trait.BitOrAssign.html" title="trait core::ops::bit::BitOrAssign">BitOrAssign</a>&lt;<a class="struct" href="../vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;T, O&gt;&gt; for <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.bitor_assign-5" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/ops.rs.html#90-92">source</a><a href="#method.bitor_assign-5" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/ops/bit/trait.BitOrAssign.html#tymethod.bitor_assign" class="fnname">bitor_assign</a>(&amp;mut self, rhs: <a class="struct" href="../vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;T, O&gt;)</h4></section></summary><div class='docblock'>Performs the <code>|=</code> operation. <a href="https://doc.rust-lang.org/1.66.1/core/ops/bit/trait.BitOrAssign.html#tymethod.bitor_assign">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BitXorAssign%3C%26BitArray%3CA%2C%20O%3E%3E-for-BitSlice%3CA%3A%3AStore%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/array/ops.rs.html#140-149">source</a><a href="#impl-BitXorAssign%3C%26BitArray%3CA%2C%20O%3E%3E-for-BitSlice%3CA%3A%3AStore%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;A, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/bit/trait.BitXorAssign.html" title="trait core::ops::bit::BitXorAssign">BitXorAssign</a>&lt;&amp;<a class="struct" href="../array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;A, O&gt;&gt; for <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;A::<a class="associatedtype" href="../view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;A: <a class="trait" href="../view/trait.BitViewSized.html" title="trait bitvec::view::BitViewSized">BitViewSized</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.bitxor_assign-1" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/array/ops.rs.html#146-148">source</a><a href="#method.bitxor_assign-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/ops/bit/trait.BitXorAssign.html#tymethod.bitxor_assign" class="fnname">bitxor_assign</a>(&amp;mut self, rhs: &amp;<a class="struct" href="../array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;A, O&gt;)</h4></section></summary><div class='docblock'>Performs the <code>^=</code> operation. <a href="https://doc.rust-lang.org/1.66.1/core/ops/bit/trait.BitXorAssign.html#tymethod.bitxor_assign">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BitXorAssign%3C%26BitBox%3CT%2C%20O%3E%3E-for-BitSlice%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/boxed/ops.rs.html#142-151">source</a><a href="#impl-BitXorAssign%3C%26BitBox%3CT%2C%20O%3E%3E-for-BitSlice%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/bit/trait.BitXorAssign.html" title="trait core::ops::bit::BitXorAssign">BitXorAssign</a>&lt;&amp;<a class="struct" href="../boxed/struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt;&gt; for <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.bitxor_assign-3" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/boxed/ops.rs.html#148-150">source</a><a href="#method.bitxor_assign-3" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/ops/bit/trait.BitXorAssign.html#tymethod.bitxor_assign" class="fnname">bitxor_assign</a>(&amp;mut self, rhs: &amp;<a class="struct" href="../boxed/struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt;)</h4></section></summary><div class='docblock'>Performs the <code>^=</code> operation. <a href="https://doc.rust-lang.org/1.66.1/core/ops/bit/trait.BitXorAssign.html#tymethod.bitxor_assign">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BitXorAssign%3C%26BitSlice%3CT2%2C%20O2%3E%3E-for-BitSlice%3CT1%2C%20O1%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/ops.rs.html#96-123">source</a><a href="#impl-BitXorAssign%3C%26BitSlice%3CT2%2C%20O2%3E%3E-for-BitSlice%3CT1%2C%20O1%3E" class="anchor"></a><h3 class="code-header">impl&lt;T1, T2, O1, O2&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/bit/trait.BitXorAssign.html" title="trait core::ops::bit::BitXorAssign">BitXorAssign</a>&lt;&amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T2, O2&gt;&gt; for <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T1, O1&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T1: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O1: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.bitxor_assign-4" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/ops.rs.html#105-122">source</a><a href="#method.bitxor_assign-4" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/ops/bit/trait.BitXorAssign.html#tymethod.bitxor_assign" class="fnname">bitxor_assign</a>(&amp;mut self, rhs: &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T2, O2&gt;)</h4></section></summary><div class="docblock"><h5 id="boolean-arithmetic-2"><a href="#boolean-arithmetic-2">Boolean Arithmetic</a></h5>
<p>This merges another bit-slice into <code>self</code> with a Boolean arithmetic operation.
If the other bit-slice is shorter than <code>self</code>, it is zero-extended. For <code>BitAnd</code>,
this clears all excess bits of <code>self</code> to <code>0</code>; for <code>BitOr</code> and <code>BitXor</code>, it
leaves them untouched</p>
<h6 id="behavior-3"><a href="#behavior-3">Behavior</a></h6>
<p>The Boolean operation proceeds across each bit-slice in iteration order. This is
<code>3O(n)</code> in the length of the shorter of <code>self</code> and <code>rhs</code>. However, it can be
accelerated if <code>rhs</code> has the same type parameters as <code>self</code>, and both are using
one of the orderings provided by <code>bitvec</code>. In this case, the implementation
specializes to use <code>BitField</code> batch operations to operate on the slices one word
at a time, rather than one bit.</p>
<p>Acceleration is not currently provided for custom bit-orderings that use the
same storage type.</p>
<h6 id="pre-10-behavior-2"><a href="#pre-10-behavior-2">Pre-<code>1.0</code> Behavior</a></h6>
<p>In the <code>0.</code> development series, Boolean arithmetic was implemented against all
<code>I: Iterator&lt;Item = bool&gt;</code>. This allowed code such as <code>bits |= [false, true];</code>,
but forbad acceleration in the most common use case (combining two bit-slices)
because <code>BitSlice</code> is not such an iterator.</p>
<p>Usage surveys indicate that it is better for the arithmetic operators to operate
on bit-slices, and to allow the possibility of specialized acceleration, rather
than to allow folding against any iterator of <code>bool</code>s.</p>
<p>If pre-<code>1.0</code> code relies on this behavior specifically, and has non-<code>BitSlice</code>
arguments to the Boolean sigils, then they will need to be replaced with the
equivalent loop.</p>
<h6 id="examples-100"><a href="#examples-100">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>a = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="kw">let </span>b = <span class="macro">bits!</span>[    <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];

<span class="kw-2">*</span>a ^= b;
<span class="macro">assert_eq!</span>(a, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]);

<span class="kw">let </span>c = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="kw">let </span>d = [<span class="bool-val">false</span>, <span class="bool-val">true</span>, <span class="bool-val">false</span>, <span class="bool-val">true</span>];

<span class="comment">// no longer allowed
// c &amp;= d.into_iter().by_vals();
</span><span class="kw">for </span>(<span class="kw-2">mut </span>c, d) <span class="kw">in </span>c.iter_mut().zip(d.into_iter())
{
  <span class="kw-2">*</span>c ^= d;
}
<span class="macro">assert_eq!</span>(c, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]);</code></pre></div>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BitXorAssign%3C%26BitVec%3CT%2C%20O%3E%3E-for-BitSlice%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/ops.rs.html#149-158">source</a><a href="#impl-BitXorAssign%3C%26BitVec%3CT%2C%20O%3E%3E-for-BitSlice%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/bit/trait.BitXorAssign.html" title="trait core::ops::bit::BitXorAssign">BitXorAssign</a>&lt;&amp;<a class="struct" href="../vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;T, O&gt;&gt; for <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.bitxor_assign-6" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/ops.rs.html#155-157">source</a><a href="#method.bitxor_assign-6" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/ops/bit/trait.BitXorAssign.html#tymethod.bitxor_assign" class="fnname">bitxor_assign</a>(&amp;mut self, rhs: &amp;<a class="struct" href="../vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;T, O&gt;)</h4></section></summary><div class='docblock'>Performs the <code>^=</code> operation. <a href="https://doc.rust-lang.org/1.66.1/core/ops/bit/trait.BitXorAssign.html#tymethod.bitxor_assign">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BitXorAssign%3CBitArray%3CA%2C%20O%3E%3E-for-BitSlice%3CA%3A%3AStore%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/array/ops.rs.html#128-137">source</a><a href="#impl-BitXorAssign%3CBitArray%3CA%2C%20O%3E%3E-for-BitSlice%3CA%3A%3AStore%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;A, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/bit/trait.BitXorAssign.html" title="trait core::ops::bit::BitXorAssign">BitXorAssign</a>&lt;<a class="struct" href="../array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;A, O&gt;&gt; for <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;A::<a class="associatedtype" href="../view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;A: <a class="trait" href="../view/trait.BitViewSized.html" title="trait bitvec::view::BitViewSized">BitViewSized</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.bitxor_assign" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/array/ops.rs.html#134-136">source</a><a href="#method.bitxor_assign" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/ops/bit/trait.BitXorAssign.html#tymethod.bitxor_assign" class="fnname">bitxor_assign</a>(&amp;mut self, rhs: <a class="struct" href="../array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;A, O&gt;)</h4></section></summary><div class='docblock'>Performs the <code>^=</code> operation. <a href="https://doc.rust-lang.org/1.66.1/core/ops/bit/trait.BitXorAssign.html#tymethod.bitxor_assign">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BitXorAssign%3CBitBox%3CT%2C%20O%3E%3E-for-BitSlice%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/boxed/ops.rs.html#130-139">source</a><a href="#impl-BitXorAssign%3CBitBox%3CT%2C%20O%3E%3E-for-BitSlice%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/bit/trait.BitXorAssign.html" title="trait core::ops::bit::BitXorAssign">BitXorAssign</a>&lt;<a class="struct" href="../boxed/struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt;&gt; for <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.bitxor_assign-2" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/boxed/ops.rs.html#136-138">source</a><a href="#method.bitxor_assign-2" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/ops/bit/trait.BitXorAssign.html#tymethod.bitxor_assign" class="fnname">bitxor_assign</a>(&amp;mut self, rhs: <a class="struct" href="../boxed/struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt;)</h4></section></summary><div class='docblock'>Performs the <code>^=</code> operation. <a href="https://doc.rust-lang.org/1.66.1/core/ops/bit/trait.BitXorAssign.html#tymethod.bitxor_assign">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BitXorAssign%3CBitVec%3CT%2C%20O%3E%3E-for-BitSlice%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/ops.rs.html#137-146">source</a><a href="#impl-BitXorAssign%3CBitVec%3CT%2C%20O%3E%3E-for-BitSlice%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/bit/trait.BitXorAssign.html" title="trait core::ops::bit::BitXorAssign">BitXorAssign</a>&lt;<a class="struct" href="../vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;T, O&gt;&gt; for <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.bitxor_assign-5" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/ops.rs.html#143-145">source</a><a href="#method.bitxor_assign-5" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/ops/bit/trait.BitXorAssign.html#tymethod.bitxor_assign" class="fnname">bitxor_assign</a>(&amp;mut self, rhs: <a class="struct" href="../vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;T, O&gt;)</h4></section></summary><div class='docblock'>Performs the <code>^=</code> operation. <a href="https://doc.rust-lang.org/1.66.1/core/ops/bit/trait.BitXorAssign.html#tymethod.bitxor_assign">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Borrow%3CBitSlice%3C%3CA%20as%20BitView%3E%3A%3AStore%2C%20O%3E%3E-for-BitArray%3CA%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/array/traits.rs.html#36-45">source</a><a href="#impl-Borrow%3CBitSlice%3C%3CA%20as%20BitView%3E%3A%3AStore%2C%20O%3E%3E-for-BitArray%3CA%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;A, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;&lt;A as <a class="trait" href="../view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a>&gt;::<a class="associatedtype" href="../view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>, O&gt;&gt; for <a class="struct" href="../array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;A, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;A: <a class="trait" href="../view/trait.BitViewSized.html" title="trait bitvec::view::BitViewSized">BitViewSized</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/array/traits.rs.html#42-44">source</a><a href="#method.borrow" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/borrow/trait.Borrow.html#tymethod.borrow" class="fnname">borrow</a>(&amp;self) -&gt; &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;A::<a class="associatedtype" href="../view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>, O&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/std/io/trait.Read.html" title="trait std::io::Read">Read</a> for &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,</span></span><span class="where fmt-newline">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/std/io/trait.Write.html" title="trait std::io::Write">Write</a> for &amp;mut <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,</span></span></code></span></span></span></span></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.66.1/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Borrow%3CBitSlice%3CT%2C%20O%3E%3E-for-BitBox%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/boxed/traits.rs.html#40-49">source</a><a href="#impl-Borrow%3CBitSlice%3CT%2C%20O%3E%3E-for-BitBox%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;&gt; for <a class="struct" href="../boxed/struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.borrow-1" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/boxed/traits.rs.html#46-48">source</a><a href="#method.borrow-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/borrow/trait.Borrow.html#tymethod.borrow" class="fnname">borrow</a>(&amp;self) -&gt; &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/std/io/trait.Read.html" title="trait std::io::Read">Read</a> for &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,</span></span><span class="where fmt-newline">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/std/io/trait.Write.html" title="trait std::io::Write">Write</a> for &amp;mut <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,</span></span></code></span></span></span></span></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.66.1/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Borrow%3CBitSlice%3CT%2C%20O%3E%3E-for-BitVec%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#41-50">source</a><a href="#impl-Borrow%3CBitSlice%3CT%2C%20O%3E%3E-for-BitVec%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;&gt; for <a class="struct" href="../vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.borrow-2" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#47-49">source</a><a href="#method.borrow-2" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/borrow/trait.Borrow.html#tymethod.borrow" class="fnname">borrow</a>(&amp;self) -&gt; &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/std/io/trait.Read.html" title="trait std::io::Read">Read</a> for &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,</span></span><span class="where fmt-newline">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/std/io/trait.Write.html" title="trait std::io::Write">Write</a> for &amp;mut <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,</span></span></code></span></span></span></span></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.66.1/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BorrowMut%3CBitSlice%3C%3CA%20as%20BitView%3E%3A%3AStore%2C%20O%3E%3E-for-BitArray%3CA%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/array/traits.rs.html#48-57">source</a><a href="#impl-BorrowMut%3CBitSlice%3C%3CA%20as%20BitView%3E%3A%3AStore%2C%20O%3E%3E-for-BitArray%3CA%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;A, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;&lt;A as <a class="trait" href="../view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a>&gt;::<a class="associatedtype" href="../view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>, O&gt;&gt; for <a class="struct" href="../array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;A, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;A: <a class="trait" href="../view/trait.BitViewSized.html" title="trait bitvec::view::BitViewSized">BitViewSized</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/array/traits.rs.html#54-56">source</a><a href="#method.borrow_mut" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fnname">borrow_mut</a>(&amp;mut self) -&gt; &amp;mut <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;A::<a class="associatedtype" href="../view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>, O&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/std/io/trait.Read.html" title="trait std::io::Read">Read</a> for &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,</span></span><span class="where fmt-newline">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/std/io/trait.Write.html" title="trait std::io::Write">Write</a> for &amp;mut <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,</span></span></code></span></span></span></span></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.66.1/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BorrowMut%3CBitSlice%3CT%2C%20O%3E%3E-for-BitBox%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/boxed/traits.rs.html#52-61">source</a><a href="#impl-BorrowMut%3CBitSlice%3CT%2C%20O%3E%3E-for-BitBox%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;&gt; for <a class="struct" href="../boxed/struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.borrow_mut-1" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/boxed/traits.rs.html#58-60">source</a><a href="#method.borrow_mut-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fnname">borrow_mut</a>(&amp;mut self) -&gt; &amp;mut <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/std/io/trait.Read.html" title="trait std::io::Read">Read</a> for &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,</span></span><span class="where fmt-newline">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/std/io/trait.Write.html" title="trait std::io::Write">Write</a> for &amp;mut <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,</span></span></code></span></span></span></span></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.66.1/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BorrowMut%3CBitSlice%3CT%2C%20O%3E%3E-for-BitVec%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#53-62">source</a><a href="#impl-BorrowMut%3CBitSlice%3CT%2C%20O%3E%3E-for-BitVec%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;&gt; for <a class="struct" href="../vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.borrow_mut-2" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#59-61">source</a><a href="#method.borrow_mut-2" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fnname">borrow_mut</a>(&amp;mut self) -&gt; &amp;mut <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/std/io/trait.Read.html" title="trait std::io::Read">Read</a> for &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,</span></span><span class="where fmt-newline">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/std/io/trait.Write.html" title="trait std::io::Write">Write</a> for &amp;mut <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,</span></span></code></span></span></span></span></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.66.1/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Debug-for-BitSlice%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/traits.rs.html#363-374">source</a><a href="#impl-Debug-for-BitSlice%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="docblock"><p><a href="https://doc.rust-lang.org/std/primitive.slice.html#impl-Debug">Original</a></p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/traits.rs.html#369-373">source</a><a href="#method.fmt" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/fmt/trait.Debug.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, fmt: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.66.1/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.66.1/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.66.1/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Default-for-%26BitSlice%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/traits.rs.html#339-348">source</a><a href="#impl-Default-for-%26BitSlice%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/default/trait.Default.html" title="trait core::default::Default">Default</a> for &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="docblock"><p><a href="https://doc.rust-lang.org/std/primitive.slice.html#impl-Default-1">Original</a></p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.default" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/traits.rs.html#345-347">source</a><a href="#method.default" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/default/trait.Default.html#tymethod.default" class="fnname">default</a>() -&gt; Self</h4></section></summary><div class='docblock'>Returns the “default value” for a type. <a href="https://doc.rust-lang.org/1.66.1/core/default/trait.Default.html#tymethod.default">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Default-for-%26mut%20BitSlice%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/traits.rs.html#351-360">source</a><a href="#impl-Default-for-%26mut%20BitSlice%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/default/trait.Default.html" title="trait core::default::Default">Default</a> for &amp;mut <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="docblock"><p><a href="https://doc.rust-lang.org/std/primitive.slice.html#impl-Default">Original</a></p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.default-1" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/traits.rs.html#357-359">source</a><a href="#method.default-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/default/trait.Default.html#tymethod.default" class="fnname">default</a>() -&gt; Self</h4></section></summary><div class='docblock'>Returns the “default value” for a type. <a href="https://doc.rust-lang.org/1.66.1/core/default/trait.Default.html#tymethod.default">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Display-for-BitSlice%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/traits.rs.html#376-387">source</a><a href="#impl-Display-for-BitSlice%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/fmt/trait.Display.html" title="trait core::fmt::Display">Display</a> for <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt-1" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/traits.rs.html#382-386">source</a><a href="#method.fmt-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/fmt/trait.Display.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, fmt: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.66.1/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.66.1/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.66.1/core/fmt/trait.Display.html#tymethod.fmt">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-From%3C%26BitSlice%3CT%2C%20O%3E%3E-for-BitBox%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/boxed/traits.rs.html#229-238">source</a><a href="#impl-From%3C%26BitSlice%3CT%2C%20O%3E%3E-for-BitBox%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;&amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;&gt; for <a class="struct" href="../boxed/struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/boxed/traits.rs.html#235-237">source</a><a href="#method.from" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(slice: &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;) -&gt; Self</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-From%3C%26BitSlice%3CT%2C%20O%3E%3E-for-BitVec%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#254-263">source</a><a href="#impl-From%3C%26BitSlice%3CT%2C%20O%3E%3E-for-BitVec%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;&amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;&gt; for <a class="struct" href="../vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from-1" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#260-262">source</a><a href="#method.from-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(slice: &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;) -&gt; Self</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-From%3C%26mut%20BitSlice%3CT%2C%20O%3E%3E-for-BitVec%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#266-275">source</a><a href="#impl-From%3C%26mut%20BitSlice%3CT%2C%20O%3E%3E-for-BitVec%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;&amp;mut <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;&gt; for <a class="struct" href="../vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from-2" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#272-274">source</a><a href="#method.from-2" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(slice: &amp;mut <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;) -&gt; Self</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Hash-for-BitSlice%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/traits.rs.html#532-542">source</a><a href="#impl-Hash-for-BitSlice%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> for <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="docblock"><p><a href="https://doc.rust-lang.org/std/primitive.slice.html#impl-Hash">Original</a></p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.hash" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/traits.rs.html#538-541">source</a><a href="#method.hash" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/hash/trait.Hash.html#tymethod.hash" class="fnname">hash</a>&lt;H&gt;(&amp;self, hasher: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;mut </a>H)<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;H: <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/hash/trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a>,</span></h4></section></summary><div class='docblock'>Feeds this value into the given <a href="https://doc.rust-lang.org/1.66.1/core/hash/trait.Hasher.html" title="Hasher"><code>Hasher</code></a>. <a href="https://doc.rust-lang.org/1.66.1/core/hash/trait.Hash.html#tymethod.hash">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Index%3CRange%3Cusize%3E%3E-for-BitSlice%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/ops.rs.html#197-204">source</a><a href="#impl-Index%3CRange%3Cusize%3E%3E-for-BitSlice%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/index/trait.Index.html" title="trait core::ops::index::Index">Index</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.66.1/core/ops/range/struct.Range.html" title="struct core::ops::range::Range">Range</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>&gt;&gt; for <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Output-1" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Output-1" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.66.1/core/ops/index/trait.Index.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;</h4></section></summary><div class='docblock'>The returned type after indexing.</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.index-1" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/ops.rs.html#197-204">source</a><a href="#method.index-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/ops/index/trait.Index.html#tymethod.index" class="fnname">index</a>(&amp;self, index: <a class="struct" href="https://doc.rust-lang.org/1.66.1/core/ops/range/struct.Range.html" title="struct core::ops::range::Range">Range</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>&gt;) -&gt; &amp;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.66.1/core/ops/index/trait.Index.html#associatedtype.Output" title="type core::ops::index::Index::Output">Output</a></h4></section></summary><div class='docblock'>Performs the indexing (<code>container[index]</code>) operation. <a href="https://doc.rust-lang.org/1.66.1/core/ops/index/trait.Index.html#tymethod.index">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Index%3CRangeFrom%3Cusize%3E%3E-for-BitSlice%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/ops.rs.html#197-204">source</a><a href="#impl-Index%3CRangeFrom%3Cusize%3E%3E-for-BitSlice%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/index/trait.Index.html" title="trait core::ops::index::Index">Index</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.66.1/core/ops/range/struct.RangeFrom.html" title="struct core::ops::range::RangeFrom">RangeFrom</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>&gt;&gt; for <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Output-2" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Output-2" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.66.1/core/ops/index/trait.Index.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;</h4></section></summary><div class='docblock'>The returned type after indexing.</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.index-2" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/ops.rs.html#197-204">source</a><a href="#method.index-2" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/ops/index/trait.Index.html#tymethod.index" class="fnname">index</a>(&amp;self, index: <a class="struct" href="https://doc.rust-lang.org/1.66.1/core/ops/range/struct.RangeFrom.html" title="struct core::ops::range::RangeFrom">RangeFrom</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>&gt;) -&gt; &amp;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.66.1/core/ops/index/trait.Index.html#associatedtype.Output" title="type core::ops::index::Index::Output">Output</a></h4></section></summary><div class='docblock'>Performs the indexing (<code>container[index]</code>) operation. <a href="https://doc.rust-lang.org/1.66.1/core/ops/index/trait.Index.html#tymethod.index">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Index%3CRangeFull%3E-for-BitSlice%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/ops.rs.html#197-204">source</a><a href="#impl-Index%3CRangeFull%3E-for-BitSlice%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/index/trait.Index.html" title="trait core::ops::index::Index">Index</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.66.1/core/ops/range/struct.RangeFull.html" title="struct core::ops::range::RangeFull">RangeFull</a>&gt; for <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Output-3" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Output-3" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.66.1/core/ops/index/trait.Index.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;</h4></section></summary><div class='docblock'>The returned type after indexing.</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.index-3" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/ops.rs.html#197-204">source</a><a href="#method.index-3" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/ops/index/trait.Index.html#tymethod.index" class="fnname">index</a>(&amp;self, index: <a class="struct" href="https://doc.rust-lang.org/1.66.1/core/ops/range/struct.RangeFull.html" title="struct core::ops::range::RangeFull">RangeFull</a>) -&gt; &amp;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.66.1/core/ops/index/trait.Index.html#associatedtype.Output" title="type core::ops::index::Index::Output">Output</a></h4></section></summary><div class='docblock'>Performs the indexing (<code>container[index]</code>) operation. <a href="https://doc.rust-lang.org/1.66.1/core/ops/index/trait.Index.html#tymethod.index">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Index%3CRangeInclusive%3Cusize%3E%3E-for-BitSlice%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/ops.rs.html#197-204">source</a><a href="#impl-Index%3CRangeInclusive%3Cusize%3E%3E-for-BitSlice%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/index/trait.Index.html" title="trait core::ops::index::Index">Index</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.66.1/core/ops/range/struct.RangeInclusive.html" title="struct core::ops::range::RangeInclusive">RangeInclusive</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>&gt;&gt; for <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Output-4" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Output-4" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.66.1/core/ops/index/trait.Index.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;</h4></section></summary><div class='docblock'>The returned type after indexing.</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.index-4" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/ops.rs.html#197-204">source</a><a href="#method.index-4" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/ops/index/trait.Index.html#tymethod.index" class="fnname">index</a>(&amp;self, index: <a class="struct" href="https://doc.rust-lang.org/1.66.1/core/ops/range/struct.RangeInclusive.html" title="struct core::ops::range::RangeInclusive">RangeInclusive</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>&gt;) -&gt; &amp;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.66.1/core/ops/index/trait.Index.html#associatedtype.Output" title="type core::ops::index::Index::Output">Output</a></h4></section></summary><div class='docblock'>Performs the indexing (<code>container[index]</code>) operation. <a href="https://doc.rust-lang.org/1.66.1/core/ops/index/trait.Index.html#tymethod.index">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Index%3CRangeTo%3Cusize%3E%3E-for-BitSlice%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/ops.rs.html#197-204">source</a><a href="#impl-Index%3CRangeTo%3Cusize%3E%3E-for-BitSlice%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/index/trait.Index.html" title="trait core::ops::index::Index">Index</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.66.1/core/ops/range/struct.RangeTo.html" title="struct core::ops::range::RangeTo">RangeTo</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>&gt;&gt; for <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Output-5" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Output-5" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.66.1/core/ops/index/trait.Index.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;</h4></section></summary><div class='docblock'>The returned type after indexing.</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.index-5" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/ops.rs.html#197-204">source</a><a href="#method.index-5" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/ops/index/trait.Index.html#tymethod.index" class="fnname">index</a>(&amp;self, index: <a class="struct" href="https://doc.rust-lang.org/1.66.1/core/ops/range/struct.RangeTo.html" title="struct core::ops::range::RangeTo">RangeTo</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>&gt;) -&gt; &amp;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.66.1/core/ops/index/trait.Index.html#associatedtype.Output" title="type core::ops::index::Index::Output">Output</a></h4></section></summary><div class='docblock'>Performs the indexing (<code>container[index]</code>) operation. <a href="https://doc.rust-lang.org/1.66.1/core/ops/index/trait.Index.html#tymethod.index">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Index%3CRangeToInclusive%3Cusize%3E%3E-for-BitSlice%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/ops.rs.html#197-204">source</a><a href="#impl-Index%3CRangeToInclusive%3Cusize%3E%3E-for-BitSlice%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/index/trait.Index.html" title="trait core::ops::index::Index">Index</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.66.1/core/ops/range/struct.RangeToInclusive.html" title="struct core::ops::range::RangeToInclusive">RangeToInclusive</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>&gt;&gt; for <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Output-6" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Output-6" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.66.1/core/ops/index/trait.Index.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;</h4></section></summary><div class='docblock'>The returned type after indexing.</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.index-6" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/ops.rs.html#197-204">source</a><a href="#method.index-6" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/ops/index/trait.Index.html#tymethod.index" class="fnname">index</a>(&amp;self, index: <a class="struct" href="https://doc.rust-lang.org/1.66.1/core/ops/range/struct.RangeToInclusive.html" title="struct core::ops::range::RangeToInclusive">RangeToInclusive</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>&gt;) -&gt; &amp;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.66.1/core/ops/index/trait.Index.html#associatedtype.Output" title="type core::ops::index::Index::Output">Output</a></h4></section></summary><div class='docblock'>Performs the indexing (<code>container[index]</code>) operation. <a href="https://doc.rust-lang.org/1.66.1/core/ops/index/trait.Index.html#tymethod.index">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Index%3Cusize%3E-for-BitSlice%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/ops.rs.html#125-164">source</a><a href="#impl-Index%3Cusize%3E-for-BitSlice%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/index/trait.Index.html" title="trait core::ops::index::Index">Index</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>&gt; for <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.index" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/ops.rs.html#158-163">source</a><a href="#method.index" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/ops/index/trait.Index.html#tymethod.index" class="fnname">index</a>(&amp;self, index: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>) -&gt; &amp;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.66.1/core/ops/index/trait.Index.html#associatedtype.Output" title="type core::ops::index::Index::Output">Output</a></h4></section></summary><div class="docblock"><p>Looks up a single bit by its semantic index.</p>
<h6 id="examples-101"><a href="#examples-101">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[u8, Msb0; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="macro">assert!</span>(!bits[<span class="number">0</span>]); <span class="comment">// -----^  |  |
</span><span class="macro">assert!</span>( bits[<span class="number">1</span>]); <span class="comment">// --------^  |
</span><span class="macro">assert!</span>(!bits[<span class="number">2</span>]); <span class="comment">// -----------^</span></code></pre></div>
<p>If the index is greater than or equal to the length, indexing will
panic.</p>
<p>The below test will panic when accessing index 1, as only index 0 is
valid.</p>

<div class="example-wrap should_panic"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>,  ];
bits[<span class="number">1</span>]; <span class="comment">// --------^</span></code></pre></div>
</div></details><details class="rustdoc-toggle" open><summary><section id="associatedtype.Output" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Output" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.66.1/core/ops/index/trait.Index.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>The returned type after indexing.</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-IndexMut%3CRange%3Cusize%3E%3E-for-BitSlice%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/ops.rs.html#197-204">source</a><a href="#impl-IndexMut%3CRange%3Cusize%3E%3E-for-BitSlice%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/index/trait.IndexMut.html" title="trait core::ops::index::IndexMut">IndexMut</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.66.1/core/ops/range/struct.Range.html" title="struct core::ops::range::Range">Range</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>&gt;&gt; for <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.index_mut" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/ops.rs.html#197-204">source</a><a href="#method.index_mut" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/ops/index/trait.IndexMut.html#tymethod.index_mut" class="fnname">index_mut</a>(&amp;mut self, index: <a class="struct" href="https://doc.rust-lang.org/1.66.1/core/ops/range/struct.Range.html" title="struct core::ops::range::Range">Range</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>&gt;) -&gt; &amp;mut Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.66.1/core/ops/index/trait.Index.html#associatedtype.Output" title="type core::ops::index::Index::Output">Output</a></h4></section></summary><div class='docblock'>Performs the mutable indexing (<code>container[index]</code>) operation. <a href="https://doc.rust-lang.org/1.66.1/core/ops/index/trait.IndexMut.html#tymethod.index_mut">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-IndexMut%3CRangeFrom%3Cusize%3E%3E-for-BitSlice%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/ops.rs.html#197-204">source</a><a href="#impl-IndexMut%3CRangeFrom%3Cusize%3E%3E-for-BitSlice%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/index/trait.IndexMut.html" title="trait core::ops::index::IndexMut">IndexMut</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.66.1/core/ops/range/struct.RangeFrom.html" title="struct core::ops::range::RangeFrom">RangeFrom</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>&gt;&gt; for <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.index_mut-1" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/ops.rs.html#197-204">source</a><a href="#method.index_mut-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/ops/index/trait.IndexMut.html#tymethod.index_mut" class="fnname">index_mut</a>(&amp;mut self, index: <a class="struct" href="https://doc.rust-lang.org/1.66.1/core/ops/range/struct.RangeFrom.html" title="struct core::ops::range::RangeFrom">RangeFrom</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>&gt;) -&gt; &amp;mut Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.66.1/core/ops/index/trait.Index.html#associatedtype.Output" title="type core::ops::index::Index::Output">Output</a></h4></section></summary><div class='docblock'>Performs the mutable indexing (<code>container[index]</code>) operation. <a href="https://doc.rust-lang.org/1.66.1/core/ops/index/trait.IndexMut.html#tymethod.index_mut">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-IndexMut%3CRangeFull%3E-for-BitSlice%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/ops.rs.html#197-204">source</a><a href="#impl-IndexMut%3CRangeFull%3E-for-BitSlice%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/index/trait.IndexMut.html" title="trait core::ops::index::IndexMut">IndexMut</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.66.1/core/ops/range/struct.RangeFull.html" title="struct core::ops::range::RangeFull">RangeFull</a>&gt; for <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.index_mut-2" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/ops.rs.html#197-204">source</a><a href="#method.index_mut-2" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/ops/index/trait.IndexMut.html#tymethod.index_mut" class="fnname">index_mut</a>(&amp;mut self, index: <a class="struct" href="https://doc.rust-lang.org/1.66.1/core/ops/range/struct.RangeFull.html" title="struct core::ops::range::RangeFull">RangeFull</a>) -&gt; &amp;mut Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.66.1/core/ops/index/trait.Index.html#associatedtype.Output" title="type core::ops::index::Index::Output">Output</a></h4></section></summary><div class='docblock'>Performs the mutable indexing (<code>container[index]</code>) operation. <a href="https://doc.rust-lang.org/1.66.1/core/ops/index/trait.IndexMut.html#tymethod.index_mut">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-IndexMut%3CRangeInclusive%3Cusize%3E%3E-for-BitSlice%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/ops.rs.html#197-204">source</a><a href="#impl-IndexMut%3CRangeInclusive%3Cusize%3E%3E-for-BitSlice%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/index/trait.IndexMut.html" title="trait core::ops::index::IndexMut">IndexMut</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.66.1/core/ops/range/struct.RangeInclusive.html" title="struct core::ops::range::RangeInclusive">RangeInclusive</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>&gt;&gt; for <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.index_mut-3" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/ops.rs.html#197-204">source</a><a href="#method.index_mut-3" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/ops/index/trait.IndexMut.html#tymethod.index_mut" class="fnname">index_mut</a>(&amp;mut self, index: <a class="struct" href="https://doc.rust-lang.org/1.66.1/core/ops/range/struct.RangeInclusive.html" title="struct core::ops::range::RangeInclusive">RangeInclusive</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>&gt;) -&gt; &amp;mut Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.66.1/core/ops/index/trait.Index.html#associatedtype.Output" title="type core::ops::index::Index::Output">Output</a></h4></section></summary><div class='docblock'>Performs the mutable indexing (<code>container[index]</code>) operation. <a href="https://doc.rust-lang.org/1.66.1/core/ops/index/trait.IndexMut.html#tymethod.index_mut">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-IndexMut%3CRangeTo%3Cusize%3E%3E-for-BitSlice%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/ops.rs.html#197-204">source</a><a href="#impl-IndexMut%3CRangeTo%3Cusize%3E%3E-for-BitSlice%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/index/trait.IndexMut.html" title="trait core::ops::index::IndexMut">IndexMut</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.66.1/core/ops/range/struct.RangeTo.html" title="struct core::ops::range::RangeTo">RangeTo</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>&gt;&gt; for <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.index_mut-4" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/ops.rs.html#197-204">source</a><a href="#method.index_mut-4" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/ops/index/trait.IndexMut.html#tymethod.index_mut" class="fnname">index_mut</a>(&amp;mut self, index: <a class="struct" href="https://doc.rust-lang.org/1.66.1/core/ops/range/struct.RangeTo.html" title="struct core::ops::range::RangeTo">RangeTo</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>&gt;) -&gt; &amp;mut Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.66.1/core/ops/index/trait.Index.html#associatedtype.Output" title="type core::ops::index::Index::Output">Output</a></h4></section></summary><div class='docblock'>Performs the mutable indexing (<code>container[index]</code>) operation. <a href="https://doc.rust-lang.org/1.66.1/core/ops/index/trait.IndexMut.html#tymethod.index_mut">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-IndexMut%3CRangeToInclusive%3Cusize%3E%3E-for-BitSlice%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/ops.rs.html#197-204">source</a><a href="#impl-IndexMut%3CRangeToInclusive%3Cusize%3E%3E-for-BitSlice%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/index/trait.IndexMut.html" title="trait core::ops::index::IndexMut">IndexMut</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.66.1/core/ops/range/struct.RangeToInclusive.html" title="struct core::ops::range::RangeToInclusive">RangeToInclusive</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>&gt;&gt; for <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.index_mut-5" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/ops.rs.html#197-204">source</a><a href="#method.index_mut-5" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/ops/index/trait.IndexMut.html#tymethod.index_mut" class="fnname">index_mut</a>(&amp;mut self, index: <a class="struct" href="https://doc.rust-lang.org/1.66.1/core/ops/range/struct.RangeToInclusive.html" title="struct core::ops::range::RangeToInclusive">RangeToInclusive</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>&gt;) -&gt; &amp;mut Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.66.1/core/ops/index/trait.Index.html#associatedtype.Output" title="type core::ops::index::Index::Output">Output</a></h4></section></summary><div class='docblock'>Performs the mutable indexing (<code>container[index]</code>) operation. <a href="https://doc.rust-lang.org/1.66.1/core/ops/index/trait.IndexMut.html#tymethod.index_mut">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-IntoIterator-for-%26%27a%20BitSlice%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/iter.rs.html#42-54">source</a><a href="#impl-IntoIterator-for-%26%27a%20BitSlice%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;'a, T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a> for &amp;'a <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="docblock"><p><a href="https://doc.rust-lang.org/core/iter/trait.IntoIterator.html#impl-IntoIterator-1">Original</a></p>
</div><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.IntoIter" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.IntoIter" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.66.1/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" class="associatedtype">IntoIter</a> = <a class="struct" href="struct.Iter.html" title="struct bitvec::slice::Iter">Iter</a>&lt;'a, T, O&gt;</h4></section></summary><div class='docblock'>Which kind of iterator are we turning this into?</div></details><details class="rustdoc-toggle" open><summary><section id="associatedtype.Item" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Item" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.66.1/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.Item" class="associatedtype">Item</a> = &lt;&lt;&amp;'a <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt; as <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.66.1/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" title="type core::iter::traits::collect::IntoIterator::IntoIter">IntoIter</a> as <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.66.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a></h4></section></summary><div class='docblock'>The type of the elements being iterated over.</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.into_iter" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/iter.rs.html#51-53">source</a><a href="#method.into_iter" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/iter/traits/collect/trait.IntoIterator.html#tymethod.into_iter" class="fnname">into_iter</a>(self) -&gt; Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.66.1/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" title="type core::iter::traits::collect::IntoIterator::IntoIter">IntoIter</a></h4></section></summary><div class='docblock'>Creates an iterator from a value. <a href="https://doc.rust-lang.org/1.66.1/core/iter/traits/collect/trait.IntoIterator.html#tymethod.into_iter">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-IntoIterator-for-%26%27a%20mut%20BitSlice%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/iter.rs.html#58-70">source</a><a href="#impl-IntoIterator-for-%26%27a%20mut%20BitSlice%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;'a, T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a> for &amp;'a mut <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="docblock"><p><a href="https://doc.rust-lang.org/core/iter/trait.IntoIterator.html#impl-IntoIterator-3">Original</a></p>
</div><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.IntoIter-1" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.IntoIter-1" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.66.1/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" class="associatedtype">IntoIter</a> = <a class="struct" href="struct.IterMut.html" title="struct bitvec::slice::IterMut">IterMut</a>&lt;'a, T, O&gt;</h4></section></summary><div class='docblock'>Which kind of iterator are we turning this into?</div></details><details class="rustdoc-toggle" open><summary><section id="associatedtype.Item-1" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Item-1" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.66.1/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.Item" class="associatedtype">Item</a> = &lt;&lt;&amp;'a mut <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt; as <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.66.1/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" title="type core::iter::traits::collect::IntoIterator::IntoIter">IntoIter</a> as <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.66.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a></h4></section></summary><div class='docblock'>The type of the elements being iterated over.</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.into_iter-1" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/iter.rs.html#67-69">source</a><a href="#method.into_iter-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/iter/traits/collect/trait.IntoIterator.html#tymethod.into_iter" class="fnname">into_iter</a>(self) -&gt; Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.66.1/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" title="type core::iter::traits::collect::IntoIterator::IntoIter">IntoIter</a></h4></section></summary><div class='docblock'>Creates an iterator from a value. <a href="https://doc.rust-lang.org/1.66.1/core/iter/traits/collect/trait.IntoIterator.html#tymethod.into_iter">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-LowerHex-for-BitSlice%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/traits.rs.html#523-528">source</a><a href="#impl-LowerHex-for-BitSlice%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/fmt/trait.LowerHex.html" title="trait core::fmt::LowerHex">LowerHex</a> for <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="docblock"><h4 id="bit-slice-rendering-2"><a href="#bit-slice-rendering-2">Bit-Slice Rendering</a></h4>
<p>This implementation prints the contents of a <code>&amp;BitSlice</code> in one of binary,
octal, or hexadecimal. It is important to note that this does <em>not</em> render the
raw underlying memory! They render the semantically-ordered contents of the
bit-slice as numerals. This distinction matters if you use type parameters that
differ from those presumed by your debugger (which is usually <code>&lt;u8, Msb0&gt;</code>).</p>
<p>The output separates the <code>T</code> elements as individual list items, and renders each
element as a base- 2, 8, or 16 numeric string. When walking an element, the bits
traversed by the bit-slice are considered to be stored in
most-significant-bit-first ordering. This means that index <code>[0]</code> is the high bit
of the left-most digit, and index <code>[n]</code> is the low bit of the right-most digit,
in a given printed word.</p>
<p>In order to render according to expectations of the Arabic numeral system, an
element being transcribed is chunked into digits from the least-significant end
of its rendered form. This is most noticeable in octal, which will always have a
smaller ceiling on the left-most digit in a printed word, while the right-most
digit in that word is able to use the full <code>0 ..= 7</code> numeral range.</p>
<h5 id="examples-104"><a href="#examples-104">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>data = [
  <span class="number">0b000000_10u8</span>,
<span class="comment">// digits print LTR
  </span><span class="number">0b10_001_101</span>,
<span class="comment">// significance is computed RTL
  </span><span class="number">0b01_000000</span>,
];
<span class="kw">let </span>bits = <span class="kw-2">&amp;</span>data.view_bits::&lt;Msb0&gt;()[<span class="number">6 </span>.. <span class="number">18</span>];

<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">&quot;{:b}&quot;</span>, bits), <span class="string">&quot;[10, 10001101, 01]&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">&quot;{:o}&quot;</span>, bits), <span class="string">&quot;[2, 215, 1]&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">&quot;{:X}&quot;</span>, bits), <span class="string">&quot;[2, 8D, 1]&quot;</span>);</code></pre></div>
<p>The <code>{:#}</code> format modifier causes the standard <code>0b</code>, <code>0o</code>, or <code>0x</code> prefix to be
applied to each printed word. The other format specifiers are not interpreted by
this implementation, and apply to the entire rendered text, not to individual
words.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt-5" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/traits.rs.html#523-528">source</a><a href="#method.fmt-5" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/fmt/trait.LowerHex.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, fmt: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.66.1/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.66.1/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter.</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Not-for-%26%27a%20mut%20BitSlice%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/ops.rs.html#212-239">source</a><a href="#impl-Not-for-%26%27a%20mut%20BitSlice%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;'a, T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/bit/trait.Not.html" title="trait core::ops::bit::Not">Not</a> for &amp;'a mut <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="docblock"><p>Inverts each bit in the bit-slice.</p>
<p>Unlike the <code>&amp;</code>, <code>|</code>, and <code>^</code> operators, this implementation is guaranteed to
update each memory element only once, and is not required to traverse every live
bit in the underlying region.</p>
</div><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Output-7" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Output-7" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.66.1/core/ops/bit/trait.Not.html#associatedtype.Output" class="associatedtype">Output</a> = &amp;'a mut <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;</h4></section></summary><div class='docblock'>The resulting type after applying the <code>!</code> operator.</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.not" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/ops.rs.html#220-238">source</a><a href="#method.not" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/ops/bit/trait.Not.html#tymethod.not" class="fnname">not</a>(self) -&gt; Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.66.1/core/ops/bit/trait.Not.html#associatedtype.Output" title="type core::ops::bit::Not::Output">Output</a></h4></section></summary><div class='docblock'>Performs the unary <code>!</code> operation. <a href="https://doc.rust-lang.org/1.66.1/core/ops/bit/trait.Not.html#tymethod.not">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Octal-for-BitSlice%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/traits.rs.html#523-528">source</a><a href="#impl-Octal-for-BitSlice%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/fmt/trait.Octal.html" title="trait core::fmt::Octal">Octal</a> for <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="docblock"><h4 id="bit-slice-rendering-1"><a href="#bit-slice-rendering-1">Bit-Slice Rendering</a></h4>
<p>This implementation prints the contents of a <code>&amp;BitSlice</code> in one of binary,
octal, or hexadecimal. It is important to note that this does <em>not</em> render the
raw underlying memory! They render the semantically-ordered contents of the
bit-slice as numerals. This distinction matters if you use type parameters that
differ from those presumed by your debugger (which is usually <code>&lt;u8, Msb0&gt;</code>).</p>
<p>The output separates the <code>T</code> elements as individual list items, and renders each
element as a base- 2, 8, or 16 numeric string. When walking an element, the bits
traversed by the bit-slice are considered to be stored in
most-significant-bit-first ordering. This means that index <code>[0]</code> is the high bit
of the left-most digit, and index <code>[n]</code> is the low bit of the right-most digit,
in a given printed word.</p>
<p>In order to render according to expectations of the Arabic numeral system, an
element being transcribed is chunked into digits from the least-significant end
of its rendered form. This is most noticeable in octal, which will always have a
smaller ceiling on the left-most digit in a printed word, while the right-most
digit in that word is able to use the full <code>0 ..= 7</code> numeral range.</p>
<h5 id="examples-103"><a href="#examples-103">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>data = [
  <span class="number">0b000000_10u8</span>,
<span class="comment">// digits print LTR
  </span><span class="number">0b10_001_101</span>,
<span class="comment">// significance is computed RTL
  </span><span class="number">0b01_000000</span>,
];
<span class="kw">let </span>bits = <span class="kw-2">&amp;</span>data.view_bits::&lt;Msb0&gt;()[<span class="number">6 </span>.. <span class="number">18</span>];

<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">&quot;{:b}&quot;</span>, bits), <span class="string">&quot;[10, 10001101, 01]&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">&quot;{:o}&quot;</span>, bits), <span class="string">&quot;[2, 215, 1]&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">&quot;{:X}&quot;</span>, bits), <span class="string">&quot;[2, 8D, 1]&quot;</span>);</code></pre></div>
<p>The <code>{:#}</code> format modifier causes the standard <code>0b</code>, <code>0o</code>, or <code>0x</code> prefix to be
applied to each printed word. The other format specifiers are not interpreted by
this implementation, and apply to the entire rendered text, not to individual
words.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt-4" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/traits.rs.html#523-528">source</a><a href="#method.fmt-4" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/fmt/trait.Octal.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, fmt: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.66.1/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.66.1/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter.</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Ord-for-BitSlice%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/traits.rs.html#76-86">source</a><a href="#impl-Ord-for-BitSlice%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.Ord.html" title="trait core::cmp::Ord">Ord</a> for <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="docblock"><p><a href="https://doc.rust-lang.org/std/primitive.slice.html#impl-Ord">Original</a></p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.cmp" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/traits.rs.html#82-85">source</a><a href="#method.cmp" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.Ord.html#tymethod.cmp" class="fnname">cmp</a>(&amp;self, rhs: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.66.1/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a></h4></section></summary><div class='docblock'>This method returns an <a href="https://doc.rust-lang.org/1.66.1/core/cmp/enum.Ordering.html" title="Ordering"><code>Ordering</code></a> between <code>self</code> and <code>other</code>. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.Ord.html#tymethod.cmp">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-PartialEq%3C%26BitSlice%3CT2%2C%20O2%3E%3E-for-BitSlice%3CT1%2C%20O1%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/traits.rs.html#157-168">source</a><a href="#impl-PartialEq%3C%26BitSlice%3CT2%2C%20O2%3E%3E-for-BitSlice%3CT1%2C%20O1%3E" class="anchor"></a><h3 class="code-header">impl&lt;T1, T2, O1, O2&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;&amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T2, O2&gt;&gt; for <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T1, O1&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T1: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O1: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.eq-7" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/traits.rs.html#165-167">source</a><a href="#method.eq-7" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialEq.html#tymethod.eq" class="fnname">eq</a>(&amp;self, rhs: &amp;&amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T2, O2&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialEq.html#tymethod.eq">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.ne-7" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/cmp.rs.html#227">source</a></span><a href="#method.ne-7" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialEq.html#method.ne" class="fnname">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>!=</code>. The default implementation is almost always
sufficient, and should not be overridden without very good reason. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialEq.html#method.ne">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-PartialEq%3C%26mut%20BitSlice%3CT2%2C%20O2%3E%3E-for-BitSlice%3CT1%2C%20O1%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/traits.rs.html#170-181">source</a><a href="#impl-PartialEq%3C%26mut%20BitSlice%3CT2%2C%20O2%3E%3E-for-BitSlice%3CT1%2C%20O1%3E" class="anchor"></a><h3 class="code-header">impl&lt;T1, T2, O1, O2&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;&amp;mut <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T2, O2&gt;&gt; for <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T1, O1&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T1: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O1: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.eq-8" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/traits.rs.html#178-180">source</a><a href="#method.eq-8" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialEq.html#tymethod.eq" class="fnname">eq</a>(&amp;self, rhs: &amp;&amp;mut <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T2, O2&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialEq.html#tymethod.eq">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.ne-8" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/cmp.rs.html#227">source</a></span><a href="#method.ne-8" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialEq.html#method.ne" class="fnname">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>!=</code>. The default implementation is almost always
sufficient, and should not be overridden without very good reason. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialEq.html#method.ne">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-PartialEq%3CBitArray%3CA%2C%20O2%3E%3E-for-BitSlice%3CT%2C%20O1%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/array/traits.rs.html#96-107">source</a><a href="#impl-PartialEq%3CBitArray%3CA%2C%20O2%3E%3E-for-BitSlice%3CT%2C%20O1%3E" class="anchor"></a><h3 class="code-header">impl&lt;O1, A, O2, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="../array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;A, O2&gt;&gt; for <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O1&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O1: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A: <a class="trait" href="../view/trait.BitViewSized.html" title="trait bitvec::view::BitViewSized">BitViewSized</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.eq" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/array/traits.rs.html#104-106">source</a><a href="#method.eq" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialEq.html#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;<a class="struct" href="../array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;A, O2&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialEq.html#tymethod.eq">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.ne" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/cmp.rs.html#227">source</a></span><a href="#method.ne" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialEq.html#method.ne" class="fnname">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>!=</code>. The default implementation is almost always
sufficient, and should not be overridden without very good reason. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialEq.html#method.ne">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-PartialEq%3CBitBox%3CT2%2C%20O2%3E%3E-for-%26BitSlice%3CT1%2C%20O1%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/boxed/traits.rs.html#110-121">source</a><a href="#impl-PartialEq%3CBitBox%3CT2%2C%20O2%3E%3E-for-%26BitSlice%3CT1%2C%20O1%3E" class="anchor"></a><h3 class="code-header">impl&lt;O1, O2, T1, T2&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="../boxed/struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T2, O2&gt;&gt; for &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T1, O1&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O1: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T1: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.eq-2" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/boxed/traits.rs.html#118-120">source</a><a href="#method.eq-2" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialEq.html#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;<a class="struct" href="../boxed/struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T2, O2&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialEq.html#tymethod.eq">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.ne-2" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/cmp.rs.html#227">source</a></span><a href="#method.ne-2" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialEq.html#method.ne" class="fnname">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>!=</code>. The default implementation is almost always
sufficient, and should not be overridden without very good reason. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialEq.html#method.ne">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-PartialEq%3CBitBox%3CT2%2C%20O2%3E%3E-for-%26mut%20BitSlice%3CT1%2C%20O1%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/boxed/traits.rs.html#124-135">source</a><a href="#impl-PartialEq%3CBitBox%3CT2%2C%20O2%3E%3E-for-%26mut%20BitSlice%3CT1%2C%20O1%3E" class="anchor"></a><h3 class="code-header">impl&lt;O1, O2, T1, T2&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="../boxed/struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T2, O2&gt;&gt; for &amp;mut <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T1, O1&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O1: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T1: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.eq-3" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/boxed/traits.rs.html#132-134">source</a><a href="#method.eq-3" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialEq.html#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;<a class="struct" href="../boxed/struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T2, O2&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialEq.html#tymethod.eq">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.ne-3" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/cmp.rs.html#227">source</a></span><a href="#method.ne-3" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialEq.html#method.ne" class="fnname">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>!=</code>. The default implementation is almost always
sufficient, and should not be overridden without very good reason. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialEq.html#method.ne">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-PartialEq%3CBitBox%3CT2%2C%20O2%3E%3E-for-BitSlice%3CT1%2C%20O1%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/boxed/traits.rs.html#96-107">source</a><a href="#impl-PartialEq%3CBitBox%3CT2%2C%20O2%3E%3E-for-BitSlice%3CT1%2C%20O1%3E" class="anchor"></a><h3 class="code-header">impl&lt;O1, O2, T1, T2&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="../boxed/struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T2, O2&gt;&gt; for <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T1, O1&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O1: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T1: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.eq-1" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/boxed/traits.rs.html#104-106">source</a><a href="#method.eq-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialEq.html#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;<a class="struct" href="../boxed/struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T2, O2&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialEq.html#tymethod.eq">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.ne-1" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/cmp.rs.html#227">source</a></span><a href="#method.ne-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialEq.html#method.ne" class="fnname">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>!=</code>. The default implementation is almost always
sufficient, and should not be overridden without very good reason. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialEq.html#method.ne">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-PartialEq%3CBitSlice%3CT2%2C%20O2%3E%3E-for-%26BitSlice%3CT1%2C%20O1%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/traits.rs.html#129-140">source</a><a href="#impl-PartialEq%3CBitSlice%3CT2%2C%20O2%3E%3E-for-%26BitSlice%3CT1%2C%20O1%3E" class="anchor"></a><h3 class="code-header">impl&lt;T1, T2, O1, O2&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T2, O2&gt;&gt; for &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T1, O1&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T1: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O1: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.eq-5" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/traits.rs.html#137-139">source</a><a href="#method.eq-5" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialEq.html#tymethod.eq" class="fnname">eq</a>(&amp;self, rhs: &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T2, O2&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialEq.html#tymethod.eq">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.ne-5" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/cmp.rs.html#227">source</a></span><a href="#method.ne-5" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialEq.html#method.ne" class="fnname">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>!=</code>. The default implementation is almost always
sufficient, and should not be overridden without very good reason. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialEq.html#method.ne">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-PartialEq%3CBitSlice%3CT2%2C%20O2%3E%3E-for-%26mut%20BitSlice%3CT1%2C%20O1%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/traits.rs.html#142-153">source</a><a href="#impl-PartialEq%3CBitSlice%3CT2%2C%20O2%3E%3E-for-%26mut%20BitSlice%3CT1%2C%20O1%3E" class="anchor"></a><h3 class="code-header">impl&lt;T1, T2, O1, O2&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T2, O2&gt;&gt; for &amp;mut <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T1, O1&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T1: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O1: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.eq-6" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/traits.rs.html#150-152">source</a><a href="#method.eq-6" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialEq.html#tymethod.eq" class="fnname">eq</a>(&amp;self, rhs: &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T2, O2&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialEq.html#tymethod.eq">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.ne-6" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/cmp.rs.html#227">source</a></span><a href="#method.ne-6" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialEq.html#method.ne" class="fnname">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>!=</code>. The default implementation is almost always
sufficient, and should not be overridden without very good reason. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialEq.html#method.ne">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-PartialEq%3CBitSlice%3CT2%2C%20O2%3E%3E-for-BitSlice%3CT1%2C%20O1%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/traits.rs.html#97-125">source</a><a href="#impl-PartialEq%3CBitSlice%3CT2%2C%20O2%3E%3E-for-BitSlice%3CT1%2C%20O1%3E" class="anchor"></a><h3 class="code-header">impl&lt;T1, T2, O1, O2&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T2, O2&gt;&gt; for <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T1, O1&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T1: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O1: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="docblock"><p>Tests if two <code>BitSlice</code>s are semantically — not representationally — equal.</p>
<p>It is valid to compare slices of different ordering or memory types.</p>
<p>The equality condition requires that they have the same length and that at each
index, the two slices have the same bit value.</p>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#impl-PartialEq%3C%5BB%5D%3E">Original</a></p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.eq-4" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/traits.rs.html#105-124">source</a><a href="#method.eq-4" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialEq.html#tymethod.eq" class="fnname">eq</a>(&amp;self, rhs: &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T2, O2&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialEq.html#tymethod.eq">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.ne-4" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/cmp.rs.html#227">source</a></span><a href="#method.ne-4" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialEq.html#method.ne" class="fnname">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>!=</code>. The default implementation is almost always
sufficient, and should not be overridden without very good reason. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialEq.html#method.ne">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-PartialEq%3CBitVec%3CT2%2C%20O2%3E%3E-for-%26BitSlice%3CT1%2C%20O1%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#110-121">source</a><a href="#impl-PartialEq%3CBitVec%3CT2%2C%20O2%3E%3E-for-%26BitSlice%3CT1%2C%20O1%3E" class="anchor"></a><h3 class="code-header">impl&lt;T1, T2, O1, O2&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="../vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;T2, O2&gt;&gt; for &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T1, O1&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T1: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O1: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.eq-10" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#118-120">source</a><a href="#method.eq-10" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialEq.html#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;<a class="struct" href="../vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;T2, O2&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialEq.html#tymethod.eq">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.ne-10" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/cmp.rs.html#227">source</a></span><a href="#method.ne-10" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialEq.html#method.ne" class="fnname">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>!=</code>. The default implementation is almost always
sufficient, and should not be overridden without very good reason. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialEq.html#method.ne">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-PartialEq%3CBitVec%3CT2%2C%20O2%3E%3E-for-%26mut%20BitSlice%3CT1%2C%20O1%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#124-135">source</a><a href="#impl-PartialEq%3CBitVec%3CT2%2C%20O2%3E%3E-for-%26mut%20BitSlice%3CT1%2C%20O1%3E" class="anchor"></a><h3 class="code-header">impl&lt;T1, T2, O1, O2&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="../vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;T2, O2&gt;&gt; for &amp;mut <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T1, O1&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T1: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O1: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.eq-11" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#132-134">source</a><a href="#method.eq-11" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialEq.html#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;<a class="struct" href="../vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;T2, O2&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialEq.html#tymethod.eq">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.ne-11" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/cmp.rs.html#227">source</a></span><a href="#method.ne-11" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialEq.html#method.ne" class="fnname">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>!=</code>. The default implementation is almost always
sufficient, and should not be overridden without very good reason. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialEq.html#method.ne">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-PartialEq%3CBitVec%3CT2%2C%20O2%3E%3E-for-BitSlice%3CT1%2C%20O1%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#96-107">source</a><a href="#impl-PartialEq%3CBitVec%3CT2%2C%20O2%3E%3E-for-BitSlice%3CT1%2C%20O1%3E" class="anchor"></a><h3 class="code-header">impl&lt;T1, T2, O1, O2&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="../vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;T2, O2&gt;&gt; for <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T1, O1&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T1: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O1: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.eq-9" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#104-106">source</a><a href="#method.eq-9" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialEq.html#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;<a class="struct" href="../vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;T2, O2&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialEq.html#tymethod.eq">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.ne-9" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/cmp.rs.html#227">source</a></span><a href="#method.ne-9" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialEq.html#method.ne" class="fnname">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>!=</code>. The default implementation is almost always
sufficient, and should not be overridden without very good reason. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialEq.html#method.ne">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-PartialOrd%3C%26BitSlice%3CT2%2C%20O2%3E%3E-for-%26mut%20BitSlice%3CT1%2C%20O1%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/traits.rs.html#283-294">source</a><a href="#impl-PartialOrd%3C%26BitSlice%3CT2%2C%20O2%3E%3E-for-%26mut%20BitSlice%3CT1%2C%20O1%3E" class="anchor"></a><h3 class="code-header">impl&lt;T1, T2, O1, O2&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;&amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T2, O2&gt;&gt; for &amp;mut <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T1, O1&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T1: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O1: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.partial_cmp-10" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/traits.rs.html#291-293">source</a><a href="#method.partial_cmp-10" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fnname">partial_cmp</a>(&amp;self, rhs: &amp;&amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T2, O2&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.66.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.66.1/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</h4></section></summary><div class='docblock'>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.lt-10" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/cmp.rs.html#1119">source</a></span><a href="#method.lt-10" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.lt" class="fnname">lt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.lt">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.le-10" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/cmp.rs.html#1138">source</a></span><a href="#method.le-10" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.le" class="fnname">le</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code>
operator. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.le">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.gt-10" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/cmp.rs.html#1156">source</a></span><a href="#method.gt-10" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.gt" class="fnname">gt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.gt">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.ge-10" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/cmp.rs.html#1175">source</a></span><a href="#method.ge-10" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.ge" class="fnname">ge</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code>
operator. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.ge">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-PartialOrd%3C%26BitSlice%3CT2%2C%20O2%3E%3E-for-BitSlice%3CT1%2C%20O1%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/traits.rs.html#242-253">source</a><a href="#impl-PartialOrd%3C%26BitSlice%3CT2%2C%20O2%3E%3E-for-BitSlice%3CT1%2C%20O1%3E" class="anchor"></a><h3 class="code-header">impl&lt;T1, T2, O1, O2&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;&amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T2, O2&gt;&gt; for <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T1, O1&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T1: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O1: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.partial_cmp-7" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/traits.rs.html#250-252">source</a><a href="#method.partial_cmp-7" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fnname">partial_cmp</a>(&amp;self, rhs: &amp;&amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T2, O2&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.66.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.66.1/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</h4></section></summary><div class='docblock'>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.lt-7" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/cmp.rs.html#1119">source</a></span><a href="#method.lt-7" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.lt" class="fnname">lt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.lt">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.le-7" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/cmp.rs.html#1138">source</a></span><a href="#method.le-7" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.le" class="fnname">le</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code>
operator. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.le">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.gt-7" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/cmp.rs.html#1156">source</a></span><a href="#method.gt-7" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.gt" class="fnname">gt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.gt">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.ge-7" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/cmp.rs.html#1175">source</a></span><a href="#method.ge-7" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.ge" class="fnname">ge</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code>
operator. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.ge">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-PartialOrd%3C%26mut%20BitSlice%3CT2%2C%20O2%3E%3E-for-%26BitSlice%3CT1%2C%20O1%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/traits.rs.html#270-281">source</a><a href="#impl-PartialOrd%3C%26mut%20BitSlice%3CT2%2C%20O2%3E%3E-for-%26BitSlice%3CT1%2C%20O1%3E" class="anchor"></a><h3 class="code-header">impl&lt;T1, T2, O1, O2&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;&amp;mut <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T2, O2&gt;&gt; for &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T1, O1&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T1: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O1: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.partial_cmp-9" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/traits.rs.html#278-280">source</a><a href="#method.partial_cmp-9" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fnname">partial_cmp</a>(&amp;self, rhs: &amp;&amp;mut <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T2, O2&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.66.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.66.1/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</h4></section></summary><div class='docblock'>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.lt-9" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/cmp.rs.html#1119">source</a></span><a href="#method.lt-9" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.lt" class="fnname">lt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.lt">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.le-9" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/cmp.rs.html#1138">source</a></span><a href="#method.le-9" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.le" class="fnname">le</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code>
operator. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.le">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.gt-9" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/cmp.rs.html#1156">source</a></span><a href="#method.gt-9" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.gt" class="fnname">gt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.gt">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.ge-9" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/cmp.rs.html#1175">source</a></span><a href="#method.ge-9" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.ge" class="fnname">ge</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code>
operator. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.ge">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-PartialOrd%3C%26mut%20BitSlice%3CT2%2C%20O2%3E%3E-for-BitSlice%3CT1%2C%20O1%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/traits.rs.html#255-266">source</a><a href="#impl-PartialOrd%3C%26mut%20BitSlice%3CT2%2C%20O2%3E%3E-for-BitSlice%3CT1%2C%20O1%3E" class="anchor"></a><h3 class="code-header">impl&lt;T1, T2, O1, O2&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;&amp;mut <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T2, O2&gt;&gt; for <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T1, O1&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T1: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O1: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.partial_cmp-8" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/traits.rs.html#263-265">source</a><a href="#method.partial_cmp-8" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fnname">partial_cmp</a>(&amp;self, rhs: &amp;&amp;mut <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T2, O2&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.66.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.66.1/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</h4></section></summary><div class='docblock'>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.lt-8" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/cmp.rs.html#1119">source</a></span><a href="#method.lt-8" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.lt" class="fnname">lt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.lt">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.le-8" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/cmp.rs.html#1138">source</a></span><a href="#method.le-8" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.le" class="fnname">le</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code>
operator. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.le">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.gt-8" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/cmp.rs.html#1156">source</a></span><a href="#method.gt-8" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.gt" class="fnname">gt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.gt">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.ge-8" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/cmp.rs.html#1175">source</a></span><a href="#method.ge-8" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.ge" class="fnname">ge</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code>
operator. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.ge">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-PartialOrd%3CBitArray%3CA%2C%20O%3E%3E-for-BitSlice%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/array/traits.rs.html#124-134">source</a><a href="#impl-PartialOrd%3CBitArray%3CA%2C%20O%3E%3E-for-BitSlice%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;A, T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;<a class="struct" href="../array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;A, O&gt;&gt; for <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;A: <a class="trait" href="../view/trait.BitViewSized.html" title="trait bitvec::view::BitViewSized">BitViewSized</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.partial_cmp" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/array/traits.rs.html#131-133">source</a><a href="#method.partial_cmp" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fnname">partial_cmp</a>(&amp;self, other: &amp;<a class="struct" href="../array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;A, O&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.66.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.66.1/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</h4></section></summary><div class='docblock'>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.lt" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/cmp.rs.html#1119">source</a></span><a href="#method.lt" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.lt" class="fnname">lt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.lt">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.le" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/cmp.rs.html#1138">source</a></span><a href="#method.le" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.le" class="fnname">le</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code>
operator. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.le">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.gt" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/cmp.rs.html#1156">source</a></span><a href="#method.gt" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.gt" class="fnname">gt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.gt">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.ge" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/cmp.rs.html#1175">source</a></span><a href="#method.ge" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.ge" class="fnname">ge</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code>
operator. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.ge">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-PartialOrd%3CBitBox%3CT2%2C%20O2%3E%3E-for-%26%27a%20BitSlice%3CT1%2C%20O1%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/boxed/traits.rs.html#178-189">source</a><a href="#impl-PartialOrd%3CBitBox%3CT2%2C%20O2%3E%3E-for-%26%27a%20BitSlice%3CT1%2C%20O1%3E" class="anchor"></a><h3 class="code-header">impl&lt;'a, O1, O2, T1, T2&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;<a class="struct" href="../boxed/struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T2, O2&gt;&gt; for &amp;'a <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T1, O1&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O1: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T1: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.partial_cmp-2" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/boxed/traits.rs.html#186-188">source</a><a href="#method.partial_cmp-2" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fnname">partial_cmp</a>(&amp;self, other: &amp;<a class="struct" href="../boxed/struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T2, O2&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.66.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.66.1/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</h4></section></summary><div class='docblock'>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.lt-2" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/cmp.rs.html#1119">source</a></span><a href="#method.lt-2" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.lt" class="fnname">lt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.lt">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.le-2" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/cmp.rs.html#1138">source</a></span><a href="#method.le-2" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.le" class="fnname">le</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code>
operator. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.le">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.gt-2" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/cmp.rs.html#1156">source</a></span><a href="#method.gt-2" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.gt" class="fnname">gt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.gt">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.ge-2" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/cmp.rs.html#1175">source</a></span><a href="#method.ge-2" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.ge" class="fnname">ge</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code>
operator. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.ge">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-PartialOrd%3CBitBox%3CT2%2C%20O2%3E%3E-for-%26%27a%20mut%20BitSlice%3CT1%2C%20O1%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/boxed/traits.rs.html#192-203">source</a><a href="#impl-PartialOrd%3CBitBox%3CT2%2C%20O2%3E%3E-for-%26%27a%20mut%20BitSlice%3CT1%2C%20O1%3E" class="anchor"></a><h3 class="code-header">impl&lt;'a, O1, O2, T1, T2&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;<a class="struct" href="../boxed/struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T2, O2&gt;&gt; for &amp;'a mut <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T1, O1&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O1: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T1: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.partial_cmp-3" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/boxed/traits.rs.html#200-202">source</a><a href="#method.partial_cmp-3" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fnname">partial_cmp</a>(&amp;self, other: &amp;<a class="struct" href="../boxed/struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T2, O2&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.66.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.66.1/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</h4></section></summary><div class='docblock'>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.lt-3" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/cmp.rs.html#1119">source</a></span><a href="#method.lt-3" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.lt" class="fnname">lt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.lt">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.le-3" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/cmp.rs.html#1138">source</a></span><a href="#method.le-3" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.le" class="fnname">le</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code>
operator. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.le">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.gt-3" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/cmp.rs.html#1156">source</a></span><a href="#method.gt-3" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.gt" class="fnname">gt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.gt">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.ge-3" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/cmp.rs.html#1175">source</a></span><a href="#method.ge-3" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.ge" class="fnname">ge</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code>
operator. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.ge">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-PartialOrd%3CBitBox%3CT2%2C%20O2%3E%3E-for-BitSlice%3CT1%2C%20O1%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/boxed/traits.rs.html#151-162">source</a><a href="#impl-PartialOrd%3CBitBox%3CT2%2C%20O2%3E%3E-for-BitSlice%3CT1%2C%20O1%3E" class="anchor"></a><h3 class="code-header">impl&lt;O1, O2, T1, T2&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;<a class="struct" href="../boxed/struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T2, O2&gt;&gt; for <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T1, O1&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O1: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T1: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.partial_cmp-1" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/boxed/traits.rs.html#159-161">source</a><a href="#method.partial_cmp-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fnname">partial_cmp</a>(&amp;self, other: &amp;<a class="struct" href="../boxed/struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T2, O2&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.66.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.66.1/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</h4></section></summary><div class='docblock'>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.lt-1" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/cmp.rs.html#1119">source</a></span><a href="#method.lt-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.lt" class="fnname">lt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.lt">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.le-1" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/cmp.rs.html#1138">source</a></span><a href="#method.le-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.le" class="fnname">le</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code>
operator. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.le">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.gt-1" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/cmp.rs.html#1156">source</a></span><a href="#method.gt-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.gt" class="fnname">gt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.gt">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.ge-1" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/cmp.rs.html#1175">source</a></span><a href="#method.ge-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.ge" class="fnname">ge</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code>
operator. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.ge">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-PartialOrd%3CBitSlice%3CT2%2C%20O2%3E%3E-for-%26BitSlice%3CT1%2C%20O1%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/traits.rs.html#214-225">source</a><a href="#impl-PartialOrd%3CBitSlice%3CT2%2C%20O2%3E%3E-for-%26BitSlice%3CT1%2C%20O1%3E" class="anchor"></a><h3 class="code-header">impl&lt;T1, T2, O1, O2&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T2, O2&gt;&gt; for &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T1, O1&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T1: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O1: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.partial_cmp-5" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/traits.rs.html#222-224">source</a><a href="#method.partial_cmp-5" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fnname">partial_cmp</a>(&amp;self, rhs: &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T2, O2&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.66.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.66.1/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</h4></section></summary><div class='docblock'>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.lt-5" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/cmp.rs.html#1119">source</a></span><a href="#method.lt-5" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.lt" class="fnname">lt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.lt">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.le-5" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/cmp.rs.html#1138">source</a></span><a href="#method.le-5" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.le" class="fnname">le</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code>
operator. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.le">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.gt-5" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/cmp.rs.html#1156">source</a></span><a href="#method.gt-5" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.gt" class="fnname">gt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.gt">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.ge-5" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/cmp.rs.html#1175">source</a></span><a href="#method.ge-5" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.ge" class="fnname">ge</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code>
operator. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.ge">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-PartialOrd%3CBitSlice%3CT2%2C%20O2%3E%3E-for-%26mut%20BitSlice%3CT1%2C%20O1%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/traits.rs.html#227-238">source</a><a href="#impl-PartialOrd%3CBitSlice%3CT2%2C%20O2%3E%3E-for-%26mut%20BitSlice%3CT1%2C%20O1%3E" class="anchor"></a><h3 class="code-header">impl&lt;T1, T2, O1, O2&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T2, O2&gt;&gt; for &amp;mut <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T1, O1&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T1: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O1: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.partial_cmp-6" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/traits.rs.html#235-237">source</a><a href="#method.partial_cmp-6" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fnname">partial_cmp</a>(&amp;self, rhs: &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T2, O2&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.66.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.66.1/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</h4></section></summary><div class='docblock'>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.lt-6" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/cmp.rs.html#1119">source</a></span><a href="#method.lt-6" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.lt" class="fnname">lt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.lt">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.le-6" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/cmp.rs.html#1138">source</a></span><a href="#method.le-6" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.le" class="fnname">le</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code>
operator. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.le">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.gt-6" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/cmp.rs.html#1156">source</a></span><a href="#method.gt-6" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.gt" class="fnname">gt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.gt">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.ge-6" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/cmp.rs.html#1175">source</a></span><a href="#method.ge-6" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.ge" class="fnname">ge</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code>
operator. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.ge">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-PartialOrd%3CBitSlice%3CT2%2C%20O2%3E%3E-for-BitSlice%3CT1%2C%20O1%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/traits.rs.html#192-210">source</a><a href="#impl-PartialOrd%3CBitSlice%3CT2%2C%20O2%3E%3E-for-BitSlice%3CT1%2C%20O1%3E" class="anchor"></a><h3 class="code-header">impl&lt;T1, T2, O1, O2&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T2, O2&gt;&gt; for <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T1, O1&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T1: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O1: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="docblock"><p>Compares two <code>BitSlice</code>s by semantic — not representational — ordering.</p>
<p>The comparison sorts by testing at each index if one slice has a high bit where
the other has a low. At the first index where the slices differ, the slice with
the high bit is greater. If the slices are equal until at least one terminates,
then they are compared by length.</p>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#impl-PartialOrd%3C%5BT%5D%3E">Original</a></p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.partial_cmp-4" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/traits.rs.html#200-209">source</a><a href="#method.partial_cmp-4" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fnname">partial_cmp</a>(&amp;self, rhs: &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T2, O2&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.66.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.66.1/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</h4></section></summary><div class='docblock'>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.lt-4" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/cmp.rs.html#1119">source</a></span><a href="#method.lt-4" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.lt" class="fnname">lt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.lt">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.le-4" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/cmp.rs.html#1138">source</a></span><a href="#method.le-4" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.le" class="fnname">le</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code>
operator. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.le">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.gt-4" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/cmp.rs.html#1156">source</a></span><a href="#method.gt-4" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.gt" class="fnname">gt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.gt">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.ge-4" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/cmp.rs.html#1175">source</a></span><a href="#method.ge-4" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.ge" class="fnname">ge</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code>
operator. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.ge">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-PartialOrd%3CBitVec%3CT2%2C%20O2%3E%3E-for-%26%27a%20BitSlice%3CT1%2C%20O1%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#165-176">source</a><a href="#impl-PartialOrd%3CBitVec%3CT2%2C%20O2%3E%3E-for-%26%27a%20BitSlice%3CT1%2C%20O1%3E" class="anchor"></a><h3 class="code-header">impl&lt;'a, T1, T2, O1, O2&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;<a class="struct" href="../vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;T2, O2&gt;&gt; for &amp;'a <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T1, O1&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T1: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O1: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.partial_cmp-12" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#173-175">source</a><a href="#method.partial_cmp-12" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fnname">partial_cmp</a>(&amp;self, other: &amp;<a class="struct" href="../vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;T2, O2&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.66.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.66.1/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</h4></section></summary><div class='docblock'>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.lt-12" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/cmp.rs.html#1119">source</a></span><a href="#method.lt-12" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.lt" class="fnname">lt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.lt">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.le-12" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/cmp.rs.html#1138">source</a></span><a href="#method.le-12" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.le" class="fnname">le</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code>
operator. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.le">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.gt-12" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/cmp.rs.html#1156">source</a></span><a href="#method.gt-12" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.gt" class="fnname">gt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.gt">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.ge-12" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/cmp.rs.html#1175">source</a></span><a href="#method.ge-12" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.ge" class="fnname">ge</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code>
operator. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.ge">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-PartialOrd%3CBitVec%3CT2%2C%20O2%3E%3E-for-%26%27a%20mut%20BitSlice%3CT1%2C%20O1%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#179-190">source</a><a href="#impl-PartialOrd%3CBitVec%3CT2%2C%20O2%3E%3E-for-%26%27a%20mut%20BitSlice%3CT1%2C%20O1%3E" class="anchor"></a><h3 class="code-header">impl&lt;'a, T1, T2, O1, O2&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;<a class="struct" href="../vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;T2, O2&gt;&gt; for &amp;'a mut <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T1, O1&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T1: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O1: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.partial_cmp-13" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#187-189">source</a><a href="#method.partial_cmp-13" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fnname">partial_cmp</a>(&amp;self, other: &amp;<a class="struct" href="../vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;T2, O2&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.66.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.66.1/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</h4></section></summary><div class='docblock'>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.lt-13" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/cmp.rs.html#1119">source</a></span><a href="#method.lt-13" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.lt" class="fnname">lt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.lt">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.le-13" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/cmp.rs.html#1138">source</a></span><a href="#method.le-13" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.le" class="fnname">le</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code>
operator. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.le">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.gt-13" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/cmp.rs.html#1156">source</a></span><a href="#method.gt-13" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.gt" class="fnname">gt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.gt">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.ge-13" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/cmp.rs.html#1175">source</a></span><a href="#method.ge-13" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.ge" class="fnname">ge</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code>
operator. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.ge">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-PartialOrd%3CBitVec%3CT2%2C%20O2%3E%3E-for-BitSlice%3CT1%2C%20O1%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#151-162">source</a><a href="#impl-PartialOrd%3CBitVec%3CT2%2C%20O2%3E%3E-for-BitSlice%3CT1%2C%20O1%3E" class="anchor"></a><h3 class="code-header">impl&lt;T1, T2, O1, O2&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;<a class="struct" href="../vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;T2, O2&gt;&gt; for <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T1, O1&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T1: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O1: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.partial_cmp-11" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#159-161">source</a><a href="#method.partial_cmp-11" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fnname">partial_cmp</a>(&amp;self, other: &amp;<a class="struct" href="../vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;T2, O2&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.66.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.66.1/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</h4></section></summary><div class='docblock'>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.lt-11" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/cmp.rs.html#1119">source</a></span><a href="#method.lt-11" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.lt" class="fnname">lt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.lt">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.le-11" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/cmp.rs.html#1138">source</a></span><a href="#method.le-11" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.le" class="fnname">le</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code>
operator. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.le">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.gt-11" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/cmp.rs.html#1156">source</a></span><a href="#method.gt-11" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.gt" class="fnname">gt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.gt">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.ge-11" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/cmp.rs.html#1175">source</a></span><a href="#method.ge-11" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.ge" class="fnname">ge</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code>
operator. <a href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.PartialOrd.html#method.ge">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Pointer-for-BitSlice%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/traits.rs.html#389-398">source</a><a href="#impl-Pointer-for-BitSlice%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/fmt/trait.Pointer.html" title="trait core::fmt::Pointer">Pointer</a> for <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt-2" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/traits.rs.html#395-397">source</a><a href="#method.fmt-2" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/fmt/trait.Pointer.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, fmt: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.66.1/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.66.1/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter.</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Read-for-%26BitSlice%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/field/io.rs.html#21-39">source</a><a href="#impl-Read-for-%26BitSlice%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/std/io/trait.Read.html" title="trait std::io::Read">Read</a> for &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,</span></h3></section></summary><div class="docblock"><h4 id="reading-from-a-bit-slice"><a href="#reading-from-a-bit-slice">Reading From a Bit-Slice</a></h4>
<p>The implementation loads bytes out of the referenced bit-slice until either the
destination buffer is filled or the source has no more bytes to provide. When
<code>.read()</code> returns, the provided bit-slice handle will have been updated to no
longer include the leading segment copied out as bytes into <code>buf</code>.</p>
<p>Note that the return value of <code>.read()</code> is always the number of <em>bytes</em> of <code>buf</code>
filled!</p>
<p>The implementation uses <a href="../field/trait.BitField.html#tymethod.load_be"><code>BitField::load_be</code></a> to collect bytes. Note that unlike
the standard library, it is implemented on bit-slices of <em>any</em> underlying
element type. However, using a <code>BitSlice&lt;_, u8&gt;</code> is still likely to be fastest.</p>
<h5 id="original-64"><a href="#original-64">Original</a></h5>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#impl-Read"><code>impl Read for [u8]</code></a></p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.read" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/field/io.rs.html#28-38">source</a><a href="#method.read" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/std/io/trait.Read.html#tymethod.read" class="fnname">read</a>(&amp;mut self, buf: &amp;mut [<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.u8.html">u8</a>]) -&gt; <a class="type" href="https://doc.rust-lang.org/1.66.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class='docblock'>Pull some bytes from this source into the specified buffer, returning
how many bytes were read. <a href="https://doc.rust-lang.org/1.66.1/std/io/trait.Read.html#tymethod.read">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.read_vectored" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.36.0">1.36.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/std/io/mod.rs.html#645">source</a></span><a href="#method.read_vectored" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/std/io/trait.Read.html#method.read_vectored" class="fnname">read_vectored</a>(&amp;mut self, bufs: &amp;mut [<a class="struct" href="https://doc.rust-lang.org/1.66.1/std/io/struct.IoSliceMut.html" title="struct std::io::IoSliceMut">IoSliceMut</a>&lt;'_&gt;]) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.66.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>, <a class="struct" href="https://doc.rust-lang.org/1.66.1/std/io/error/struct.Error.html" title="struct std::io::error::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Like <code>read</code>, except that it reads into a slice of buffers. <a href="https://doc.rust-lang.org/1.66.1/std/io/trait.Read.html#method.read_vectored">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.is_read_vectored" class="method trait-impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.66.1/src/std/io/mod.rs.html#658">source</a><a href="#method.is_read_vectored" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/std/io/trait.Read.html#method.is_read_vectored" class="fnname">is_read_vectored</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>can_vector</code>)</span></div></span><div class='docblock'>Determines if this <code>Read</code>er has an efficient <code>read_vectored</code>
implementation. <a href="https://doc.rust-lang.org/1.66.1/std/io/trait.Read.html#method.is_read_vectored">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.read_to_end" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/std/io/mod.rs.html#709">source</a></span><a href="#method.read_to_end" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/std/io/trait.Read.html#method.read_to_end" class="fnname">read_to_end</a>(&amp;mut self, buf: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.66.1/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.u8.html">u8</a>, <a class="struct" href="https://doc.rust-lang.org/1.66.1/alloc/alloc/struct.Global.html" title="struct alloc::alloc::Global">Global</a>&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.66.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>, <a class="struct" href="https://doc.rust-lang.org/1.66.1/std/io/error/struct.Error.html" title="struct std::io::error::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Read all bytes until EOF in this source, placing them into <code>buf</code>. <a href="https://doc.rust-lang.org/1.66.1/std/io/trait.Read.html#method.read_to_end">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.read_to_string" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/std/io/mod.rs.html#752">source</a></span><a href="#method.read_to_string" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/std/io/trait.Read.html#method.read_to_string" class="fnname">read_to_string</a>(&amp;mut self, buf: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.66.1/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.66.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>, <a class="struct" href="https://doc.rust-lang.org/1.66.1/std/io/error/struct.Error.html" title="struct std::io::error::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Read all bytes until EOF in this source, appending them to <code>buf</code>. <a href="https://doc.rust-lang.org/1.66.1/std/io/trait.Read.html#method.read_to_string">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.read_exact" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.6.0">1.6.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/std/io/mod.rs.html#807">source</a></span><a href="#method.read_exact" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/std/io/trait.Read.html#method.read_exact" class="fnname">read_exact</a>(&amp;mut self, buf: &amp;mut [<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.u8.html">u8</a>]) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.66.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.unit.html">()</a>, <a class="struct" href="https://doc.rust-lang.org/1.66.1/std/io/error/struct.Error.html" title="struct std::io::error::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Read the exact number of bytes required to fill <code>buf</code>. <a href="https://doc.rust-lang.org/1.66.1/std/io/trait.Read.html#method.read_exact">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.read_buf" class="method trait-impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.66.1/src/std/io/mod.rs.html#818">source</a><a href="#method.read_buf" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/std/io/trait.Read.html#method.read_buf" class="fnname">read_buf</a>(&amp;mut self, buf: <a class="struct" href="https://doc.rust-lang.org/1.66.1/std/io/readbuf/struct.BorrowedCursor.html" title="struct std::io::readbuf::BorrowedCursor">BorrowedCursor</a>&lt;'_&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.66.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.unit.html">()</a>, <a class="struct" href="https://doc.rust-lang.org/1.66.1/std/io/error/struct.Error.html" title="struct std::io::error::Error">Error</a>&gt;</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>read_buf</code>)</span></div></span><div class='docblock'>Pull some bytes from this source into the specified buffer. <a href="https://doc.rust-lang.org/1.66.1/std/io/trait.Read.html#method.read_buf">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.read_buf_exact" class="method trait-impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.66.1/src/std/io/mod.rs.html#827">source</a><a href="#method.read_buf_exact" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/std/io/trait.Read.html#method.read_buf_exact" class="fnname">read_buf_exact</a>(&amp;mut self, cursor: <a class="struct" href="https://doc.rust-lang.org/1.66.1/std/io/readbuf/struct.BorrowedCursor.html" title="struct std::io::readbuf::BorrowedCursor">BorrowedCursor</a>&lt;'_&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.66.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.unit.html">()</a>, <a class="struct" href="https://doc.rust-lang.org/1.66.1/std/io/error/struct.Error.html" title="struct std::io::error::Error">Error</a>&gt;</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>read_buf</code>)</span></div></span><div class='docblock'>Read the exact number of bytes required to fill <code>cursor</code>. <a href="https://doc.rust-lang.org/1.66.1/std/io/trait.Read.html#method.read_buf_exact">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.by_ref" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/std/io/mod.rs.html#879-881">source</a></span><a href="#method.by_ref" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/std/io/trait.Read.html#method.by_ref" class="fnname">by_ref</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;mut </a>Self<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h4></section></summary><div class='docblock'>Creates a “by reference” adaptor for this instance of <code>Read</code>. <a href="https://doc.rust-lang.org/1.66.1/std/io/trait.Read.html#method.by_ref">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.bytes" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/std/io/mod.rs.html#922-924">source</a></span><a href="#method.bytes" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/std/io/trait.Read.html#method.bytes" class="fnname">bytes</a>(self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.66.1/std/io/struct.Bytes.html" title="struct std::io::Bytes">Bytes</a>&lt;Self&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h4></section></summary><div class='docblock'>Transforms this <code>Read</code> instance to an <a href="https://doc.rust-lang.org/1.66.1/core/iter/traits/iterator/trait.Iterator.html" title="Iterator"><code>Iterator</code></a> over its bytes. <a href="https://doc.rust-lang.org/1.66.1/std/io/trait.Read.html#method.bytes">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.chain" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/std/io/mod.rs.html#960-962">source</a></span><a href="#method.chain" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/std/io/trait.Read.html#method.chain" class="fnname">chain</a>&lt;R&gt;(self, next: R) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.66.1/std/io/struct.Chain.html" title="struct std::io::Chain">Chain</a>&lt;Self, R&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;R: <a class="trait" href="https://doc.rust-lang.org/1.66.1/std/io/trait.Read.html" title="trait std::io::Read">Read</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h4></section></summary><div class='docblock'>Creates an adapter which will chain this stream with another. <a href="https://doc.rust-lang.org/1.66.1/std/io/trait.Read.html#method.chain">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.take" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/std/io/mod.rs.html#999-1001">source</a></span><a href="#method.take" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/std/io/trait.Read.html#method.take" class="fnname">take</a>(self, limit: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.u64.html">u64</a>) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.66.1/std/io/struct.Take.html" title="struct std::io::Take">Take</a>&lt;Self&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h4></section></summary><div class='docblock'>Creates an adapter which will read at most <code>limit</code> bytes from it. <a href="https://doc.rust-lang.org/1.66.1/std/io/trait.Read.html#method.take">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-ToOwned-for-BitSlice%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/traits.rs.html#571-582">source</a><a href="#impl-ToOwned-for-BitSlice%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="docblock"><p><a href="https://doc.rust-lang.org/std/primitive.slice.html#impl-ToOwned">Original</a></p>
</div><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Owned" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.66.1/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = <a class="struct" href="../vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;T, O&gt;</h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/traits.rs.html#579-581">source</a><a href="#method.to_owned" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fnname">to_owned</a>(&amp;self) -&gt; Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.66.1/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" title="type alloc::borrow::ToOwned::Owned">Owned</a></h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/1.66.1/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.63.0">1.63.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/alloc/borrow.rs.html#76">source</a></span><a href="#method.clone_into" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fnname">clone_into</a>(&amp;self, target: &amp;mut Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.66.1/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" title="type alloc::borrow::ToOwned::Owned">Owned</a>)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/1.66.1/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-TryFrom%3C%26%27a%20%5BT%5D%3E-for-%26%27a%20BitSlice%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/traits.rs.html#303-314">source</a><a href="#impl-TryFrom%3C%26%27a%20%5BT%5D%3E-for-%26%27a%20BitSlice%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;'a, T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;&amp;'a <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.slice.html">[T]</a>&gt; for &amp;'a <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="docblock"><p>Calls <a href="struct.BitSlice.html#method.try_from_slice"><code>BitSlice::try_from_slice</code></a>, but returns the original Rust slice on
error instead of the failure event.</p>
<p>This only fails if <code>slice.len()</code> exceeds <code>BitSlice::MAX_ELTS</code>.</p>
</div><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Error-3" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Error-3" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.66.1/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = &amp;'a <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.slice.html">[T]</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.try_from-3" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/traits.rs.html#311-313">source</a><a href="#method.try_from-3" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/convert/trait.TryFrom.html#tymethod.try_from" class="fnname">try_from</a>(slice: &amp;'a <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.slice.html">[T]</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.66.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;Self, Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.66.1/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-TryFrom%3C%26%27a%20mut%20%5BT%5D%3E-for-%26%27a%20mut%20BitSlice%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/traits.rs.html#323-336">source</a><a href="#impl-TryFrom%3C%26%27a%20mut%20%5BT%5D%3E-for-%26%27a%20mut%20BitSlice%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;'a, T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;&amp;'a mut <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.slice.html">[T]</a>&gt; for &amp;'a mut <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="docblock"><p>Calls <a href="struct.BitSlice.html#method.try_from_slice_mut"><code>BitSlice::try_from_slice_mut</code></a>, but returns the original Rust slice
on error instead of the failure event.</p>
<p>This only fails if <code>slice.len()</code> exceeds <code>BitSlice::MAX_ELTS</code>.</p>
</div><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Error-4" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Error-4" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.66.1/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = &amp;'a mut <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.slice.html">[T]</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.try_from-4" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/traits.rs.html#331-335">source</a><a href="#method.try_from-4" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/convert/trait.TryFrom.html#tymethod.try_from" class="fnname">try_from</a>(slice: &amp;'a mut <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.slice.html">[T]</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.66.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;Self, Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.66.1/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-TryFrom%3C%26BitSlice%3C%3CA%20as%20BitView%3E%3A%3AStore%2C%20O%3E%3E-for-%26BitArray%3CA%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/array/traits.rs.html#199-216">source</a><a href="#impl-TryFrom%3C%26BitSlice%3C%3CA%20as%20BitView%3E%3A%3AStore%2C%20O%3E%3E-for-%26BitArray%3CA%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;A, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;&amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;&lt;A as <a class="trait" href="../view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a>&gt;::<a class="associatedtype" href="../view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>, O&gt;&gt; for &amp;<a class="struct" href="../array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;A, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;A: <a class="trait" href="../view/trait.BitViewSized.html" title="trait bitvec::view::BitViewSized">BitViewSized</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Error-1" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.66.1/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = TryFromBitSliceError</h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.try_from-1" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/array/traits.rs.html#207-215">source</a><a href="#method.try_from-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/convert/trait.TryFrom.html#tymethod.try_from" class="fnname">try_from</a>(src: &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;A::<a class="associatedtype" href="../view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>, O&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.66.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;Self, Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.66.1/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-TryFrom%3C%26BitSlice%3C%3CA%20as%20BitView%3E%3A%3AStore%2C%20O%3E%3E-for-BitArray%3CA%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/array/traits.rs.html#186-197">source</a><a href="#impl-TryFrom%3C%26BitSlice%3C%3CA%20as%20BitView%3E%3A%3AStore%2C%20O%3E%3E-for-BitArray%3CA%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;A, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;&amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;&lt;A as <a class="trait" href="../view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a>&gt;::<a class="associatedtype" href="../view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>, O&gt;&gt; for <a class="struct" href="../array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;A, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;A: <a class="trait" href="../view/trait.BitViewSized.html" title="trait bitvec::view::BitViewSized">BitViewSized</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Error" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.66.1/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = TryFromBitSliceError</h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/array/traits.rs.html#194-196">source</a><a href="#method.try_from" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/convert/trait.TryFrom.html#tymethod.try_from" class="fnname">try_from</a>(src: &amp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;A::<a class="associatedtype" href="../view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>, O&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.66.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;Self, Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.66.1/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-TryFrom%3C%26mut%20BitSlice%3C%3CA%20as%20BitView%3E%3A%3AStore%2C%20O%3E%3E-for-%26mut%20BitArray%3CA%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/array/traits.rs.html#218-235">source</a><a href="#impl-TryFrom%3C%26mut%20BitSlice%3C%3CA%20as%20BitView%3E%3A%3AStore%2C%20O%3E%3E-for-%26mut%20BitArray%3CA%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;A, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;&amp;mut <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;&lt;A as <a class="trait" href="../view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a>&gt;::<a class="associatedtype" href="../view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>, O&gt;&gt; for &amp;mut <a class="struct" href="../array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;A, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;A: <a class="trait" href="../view/trait.BitViewSized.html" title="trait bitvec::view::BitViewSized">BitViewSized</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Error-2" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Error-2" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.66.1/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = TryFromBitSliceError</h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.try_from-2" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/array/traits.rs.html#226-234">source</a><a href="#method.try_from-2" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/convert/trait.TryFrom.html#tymethod.try_from" class="fnname">try_from</a>(src: &amp;mut <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;A::<a class="associatedtype" href="../view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>, O&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.66.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;Self, Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.66.1/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-UpperHex-for-BitSlice%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/traits.rs.html#523-528">source</a><a href="#impl-UpperHex-for-BitSlice%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/fmt/trait.UpperHex.html" title="trait core::fmt::UpperHex">UpperHex</a> for <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section></summary><div class="docblock"><h4 id="bit-slice-rendering-3"><a href="#bit-slice-rendering-3">Bit-Slice Rendering</a></h4>
<p>This implementation prints the contents of a <code>&amp;BitSlice</code> in one of binary,
octal, or hexadecimal. It is important to note that this does <em>not</em> render the
raw underlying memory! They render the semantically-ordered contents of the
bit-slice as numerals. This distinction matters if you use type parameters that
differ from those presumed by your debugger (which is usually <code>&lt;u8, Msb0&gt;</code>).</p>
<p>The output separates the <code>T</code> elements as individual list items, and renders each
element as a base- 2, 8, or 16 numeric string. When walking an element, the bits
traversed by the bit-slice are considered to be stored in
most-significant-bit-first ordering. This means that index <code>[0]</code> is the high bit
of the left-most digit, and index <code>[n]</code> is the low bit of the right-most digit,
in a given printed word.</p>
<p>In order to render according to expectations of the Arabic numeral system, an
element being transcribed is chunked into digits from the least-significant end
of its rendered form. This is most noticeable in octal, which will always have a
smaller ceiling on the left-most digit in a printed word, while the right-most
digit in that word is able to use the full <code>0 ..= 7</code> numeral range.</p>
<h5 id="examples-105"><a href="#examples-105">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>data = [
  <span class="number">0b000000_10u8</span>,
<span class="comment">// digits print LTR
  </span><span class="number">0b10_001_101</span>,
<span class="comment">// significance is computed RTL
  </span><span class="number">0b01_000000</span>,
];
<span class="kw">let </span>bits = <span class="kw-2">&amp;</span>data.view_bits::&lt;Msb0&gt;()[<span class="number">6 </span>.. <span class="number">18</span>];

<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">&quot;{:b}&quot;</span>, bits), <span class="string">&quot;[10, 10001101, 01]&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">&quot;{:o}&quot;</span>, bits), <span class="string">&quot;[2, 215, 1]&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">&quot;{:X}&quot;</span>, bits), <span class="string">&quot;[2, 8D, 1]&quot;</span>);</code></pre></div>
<p>The <code>{:#}</code> format modifier causes the standard <code>0b</code>, <code>0o</code>, or <code>0x</code> prefix to be
applied to each printed word. The other format specifiers are not interpreted by
this implementation, and apply to the entire rendered text, not to individual
words.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt-6" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/traits.rs.html#523-528">source</a><a href="#method.fmt-6" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/fmt/trait.UpperHex.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, fmt: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.66.1/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.66.1/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter.</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Write-for-%26mut%20BitSlice%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/field/io.rs.html#42-68">source</a><a href="#impl-Write-for-%26mut%20BitSlice%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/std/io/trait.Write.html" title="trait std::io::Write">Write</a> for &amp;mut <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,</span></h3></section></summary><div class="docblock"><h4 id="writing-into-a-bit-slice"><a href="#writing-into-a-bit-slice">Writing Into a Bit-Slice</a></h4>
<p>The implementation stores bytes into the referenced bit-slice until either the
source buffer is exhausted or the destination has no more slots to fill. When
<code>.write()</code> returns, the provided bit-slice handle will have been updated to no
longer include the leading segment filled with bytes from <code>buf</code>.</p>
<p>Note that the return value of <code>.write()</code> is always the number of <em>bytes</em> of
<code>buf</code> consumed!</p>
<p>The implementation uses <a href="../field/trait.BitField.html#tymethod.store_be"><code>BitField::store_be</code></a> to fill bytes. Note that unlike
the standard library, it is implemented on bit-slices of <em>any</em> underlying
element type. However, using a <code>BitSlice&lt;_, u8&gt;</code> is still likely to be fastest.</p>
<h5 id="original-65"><a href="#original-65">Original</a></h5>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#impl-Write"><code>impl Write for [u8]</code></a></p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.write" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/field/io.rs.html#49-61">source</a><a href="#method.write" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/std/io/trait.Write.html#tymethod.write" class="fnname">write</a>(&amp;mut self, buf: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.u8.html">u8</a>]) -&gt; <a class="type" href="https://doc.rust-lang.org/1.66.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class='docblock'>Write a buffer into this writer, returning how many bytes were written. <a href="https://doc.rust-lang.org/1.66.1/std/io/trait.Write.html#tymethod.write">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.flush" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/field/io.rs.html#65-67">source</a><a href="#method.flush" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/std/io/trait.Write.html#tymethod.flush" class="fnname">flush</a>(&amp;mut self) -&gt; <a class="type" href="https://doc.rust-lang.org/1.66.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.unit.html">()</a>&gt;</h4></section></summary><div class='docblock'>Flush this output stream, ensuring that all intermediately buffered
contents reach their destination. <a href="https://doc.rust-lang.org/1.66.1/std/io/trait.Write.html#tymethod.flush">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.write_vectored" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.36.0">1.36.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/std/io/mod.rs.html#1463">source</a></span><a href="#method.write_vectored" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/std/io/trait.Write.html#method.write_vectored" class="fnname">write_vectored</a>(&amp;mut self, bufs: &amp;[<a class="struct" href="https://doc.rust-lang.org/1.66.1/std/io/struct.IoSlice.html" title="struct std::io::IoSlice">IoSlice</a>&lt;'_&gt;]) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.66.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>, <a class="struct" href="https://doc.rust-lang.org/1.66.1/std/io/error/struct.Error.html" title="struct std::io::error::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Like <a href="https://doc.rust-lang.org/1.66.1/std/io/trait.Write.html#tymethod.write"><code>write</code></a>, except that it writes from a slice of buffers. <a href="https://doc.rust-lang.org/1.66.1/std/io/trait.Write.html#method.write_vectored">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.is_write_vectored" class="method trait-impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.66.1/src/std/io/mod.rs.html#1478">source</a><a href="#method.is_write_vectored" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/std/io/trait.Write.html#method.is_write_vectored" class="fnname">is_write_vectored</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>can_vector</code>)</span></div></span><div class='docblock'>Determines if this <code>Write</code>r has an efficient <a href="https://doc.rust-lang.org/1.66.1/std/io/trait.Write.html#method.write_vectored"><code>write_vectored</code></a>
implementation. <a href="https://doc.rust-lang.org/1.66.1/std/io/trait.Write.html#method.is_write_vectored">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.write_all" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/std/io/mod.rs.html#1540">source</a></span><a href="#method.write_all" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/std/io/trait.Write.html#method.write_all" class="fnname">write_all</a>(&amp;mut self, buf: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.u8.html">u8</a>]) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.66.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.unit.html">()</a>, <a class="struct" href="https://doc.rust-lang.org/1.66.1/std/io/error/struct.Error.html" title="struct std::io::error::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Attempts to write an entire buffer into this writer. <a href="https://doc.rust-lang.org/1.66.1/std/io/trait.Write.html#method.write_all">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.write_all_vectored" class="method trait-impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.66.1/src/std/io/mod.rs.html#1605">source</a><a href="#method.write_all_vectored" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/std/io/trait.Write.html#method.write_all_vectored" class="fnname">write_all_vectored</a>(&amp;mut self, bufs: &amp;mut [<a class="struct" href="https://doc.rust-lang.org/1.66.1/std/io/struct.IoSlice.html" title="struct std::io::IoSlice">IoSlice</a>&lt;'_&gt;]) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.66.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.unit.html">()</a>, <a class="struct" href="https://doc.rust-lang.org/1.66.1/std/io/error/struct.Error.html" title="struct std::io::error::Error">Error</a>&gt;</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>write_all_vectored</code>)</span></div></span><div class='docblock'>Attempts to write multiple buffers into this writer. <a href="https://doc.rust-lang.org/1.66.1/std/io/trait.Write.html#method.write_all_vectored">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.write_fmt" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/std/io/mod.rs.html#1661">source</a></span><a href="#method.write_fmt" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/std/io/trait.Write.html#method.write_fmt" class="fnname">write_fmt</a>(&amp;mut self, fmt: <a class="struct" href="https://doc.rust-lang.org/1.66.1/core/fmt/struct.Arguments.html" title="struct core::fmt::Arguments">Arguments</a>&lt;'_&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.66.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.unit.html">()</a>, <a class="struct" href="https://doc.rust-lang.org/1.66.1/std/io/error/struct.Error.html" title="struct std::io::error::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Writes a formatted string into this writer, returning any error
encountered. <a href="https://doc.rust-lang.org/1.66.1/std/io/trait.Write.html#method.write_fmt">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.by_ref-1" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/std/io/mod.rs.html#1717-1719">source</a></span><a href="#method.by_ref-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/std/io/trait.Write.html#method.by_ref" class="fnname">by_ref</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;mut </a>Self<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h4></section></summary><div class='docblock'>Creates a “by reference” adapter for this instance of <code>Write</code>. <a href="https://doc.rust-lang.org/1.66.1/std/io/trait.Write.html#method.by_ref">Read more</a></div></details></div></details><section id="impl-Eq-for-BitSlice%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/traits.rs.html#68-73">source</a><a href="#impl-Eq-for-BitSlice%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> for <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section><div class="docblock"><p><a href="https://doc.rust-lang.org/std/primitive.slice.html#impl-Eq">Original</a></p>
</div><section id="impl-Send-for-BitSlice%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/traits.rs.html#545-550">source</a><a href="#impl-Send-for-BitSlice%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a> + <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section><div class="docblock"><h4 id="bit-slice-thread-safety"><a href="#bit-slice-thread-safety">Bit-Slice Thread Safety</a></h4>
<p>This allows bit-slice references to be moved across thread boundaries only when
the underlying <code>T</code> element can tolerate concurrency.</p>
<p>All <code>BitSlice</code> references, shared or exclusive, are only threadsafe if the <code>T</code>
element type is <code>Send</code>, because any given bit-slice reference may only have
partial control of a memory element that is also being shared by a bit-slice
reference on another thread. As such, this is never implemented for <code>Cell&lt;U&gt;</code>,
but always implemented for <code>AtomicU</code> and <code>U</code> for a given unsigned integer type
<code>U</code>.</p>
<p>Atomic integers safely handle concurrent writes, cells do not allow concurrency
at all, so the only missing piece is <code>&amp;mut BitSlice&lt;_, U: Unsigned&gt;</code>. This is
handled by the aliasing system that the mutable splitters employ: a mutable
reference to an unsynchronized bit-slice can only cross threads when no other
handle is able to exist to the elements it governs. Splitting a mutable
bit-slice causes the split halves to change over to either atomics or cells, so
concurrency is either safe or impossible.</p>
</div><section id="impl-Sync-for-BitSlice%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/traits.rs.html#553-558">source</a><a href="#impl-Sync-for-BitSlice%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a> + <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section><div class="docblock"><h4 id="bit-slice-thread-safety-1"><a href="#bit-slice-thread-safety-1">Bit-Slice Thread Safety</a></h4>
<p>This allows bit-slice references to be moved across thread boundaries only when
the underlying <code>T</code> element can tolerate concurrency.</p>
<p>All <code>BitSlice</code> references, shared or exclusive, are only threadsafe if the <code>T</code>
element type is <code>Send</code>, because any given bit-slice reference may only have
partial control of a memory element that is also being shared by a bit-slice
reference on another thread. As such, this is never implemented for <code>Cell&lt;U&gt;</code>,
but always implemented for <code>AtomicU</code> and <code>U</code> for a given unsigned integer type
<code>U</code>.</p>
<p>Atomic integers safely handle concurrent writes, cells do not allow concurrency
at all, so the only missing piece is <code>&amp;mut BitSlice&lt;_, U: Unsigned&gt;</code>. This is
handled by the aliasing system that the mutable splitters employ: a mutable
reference to an unsynchronized bit-slice can only cross threads when no other
handle is able to exist to the elements it governs. Splitting a mutable
bit-slice causes the split halves to change over to either atomics or cells, so
concurrency is either safe or impossible.</p>
</div><section id="impl-Unpin-for-BitSlice%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/traits.rs.html#561-566">source</a><a href="#impl-Unpin-for-BitSlice%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,</span></h3></section><div class="docblock"><p><a href="https://doc.rust-lang.org/std/primitive.slice.html#impl-Unpin">Original</a></p>
</div></div><h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor"></a></h2><div id="synthetic-implementations-list"><section id="impl-RefUnwindSafe-for-BitSlice%3CT%2C%20O%3E" class="impl has-srclink"><a href="#impl-RefUnwindSafe-for-BitSlice%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a>,</span></h3></section><section id="impl-Sized-for-BitSlice%3CT%2C%20O%3E" class="impl has-srclink"><a href="#impl-Sized-for-BitSlice%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T&nbsp;=&nbsp;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.usize.html">usize</a>, O&nbsp;=&nbsp;<a class="struct" href="../order/struct.Lsb0.html" title="struct bitvec::order::Lsb0">Lsb0</a>&gt; !<a class="trait" href="https://doc.rust-lang.org/1.66.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> for <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;</h3></section><section id="impl-UnwindSafe-for-BitSlice%3CT%2C%20O%3E" class="impl has-srclink"><a href="#impl-UnwindSafe-for-BitSlice%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a>,</span></h3></section></div><h2 id="blanket-implementations" class="small-section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor"></a></h2><div id="blanket-implementations-list"><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Any-for-BitSlice%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.66.1/src/core/any.rs.html#200">source</a><a href="#impl-Any-for-BitSlice%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.66.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.66.1/src/core/any.rs.html#201">source</a><a href="#method.type_id" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/any/trait.Any.html#tymethod.type_id" class="fnname">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.66.1/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.66.1/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-BitSlice%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.66.1/src/core/borrow.rs.html#211">source</a><a href="#impl-Borrow%3CT%3E-for-BitSlice%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/1.66.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.borrow-3" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/91522" title="Tracking issue for const_borrow">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/borrow.rs.html#213">source</a></span><a href="#method.borrow-3" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/borrow/trait.Borrow.html#tymethod.borrow" class="fnname">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>T</h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.66.1/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-BitSlice%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.66.1/src/core/borrow.rs.html#220">source</a><a href="#impl-BorrowMut%3CT%3E-for-BitSlice%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/1.66.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.borrow_mut-3" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/91522" title="Tracking issue for const_borrow">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/borrow.rs.html#221">source</a></span><a href="#method.borrow_mut-3" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fnname">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;mut </a>T</h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.66.1/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Conv-for-BitSlice%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/tap/conv.rs.html#58">source</a><a href="#impl-Conv-for-BitSlice%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../tap/conv/trait.Conv.html" title="trait tap::conv::Conv">Conv</a> for T</h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.conv" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/tap/conv.rs.html#49-52">source</a><a href="#method.conv" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/conv/trait.Conv.html#method.conv" class="fnname">conv</a>&lt;T&gt;(self) -&gt; T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</span></h4></section></summary><div class='docblock'>Converts <code>self</code> into <code>T</code> using <code>Into&lt;T&gt;</code>. <a href="../../tap/conv/trait.Conv.html#method.conv">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-FmtForward-for-BitSlice%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/wyz/fmt.rs.html#114">source</a><a href="#impl-FmtForward-for-BitSlice%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../wyz/fmt/trait.FmtForward.html" title="trait wyz::fmt::FmtForward">FmtForward</a> for T</h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt_binary" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/wyz/fmt.rs.html#41-42">source</a><a href="#method.fmt_binary" class="anchor"></a><h4 class="code-header">fn <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_binary" class="fnname">fmt_binary</a>(self) -&gt; <a class="struct" href="../../wyz/fmt/struct.FmtBinary.html" title="struct wyz::fmt::FmtBinary">FmtBinary</a>&lt;Self&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/fmt/trait.Binary.html" title="trait core::fmt::Binary">Binary</a>,</span></h4></section></summary><div class='docblock'>Causes <code>self</code> to use its <code>Binary</code> implementation when <code>Debug</code>-formatted.</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt_display" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/wyz/fmt.rs.html#49-50">source</a><a href="#method.fmt_display" class="anchor"></a><h4 class="code-header">fn <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_display" class="fnname">fmt_display</a>(self) -&gt; <a class="struct" href="../../wyz/fmt/struct.FmtDisplay.html" title="struct wyz::fmt::FmtDisplay">FmtDisplay</a>&lt;Self&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/fmt/trait.Display.html" title="trait core::fmt::Display">Display</a>,</span></h4></section></summary><div class='docblock'>Causes <code>self</code> to use its <code>Display</code> implementation when
<code>Debug</code>-formatted. <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_display">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt_lower_exp" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/wyz/fmt.rs.html#57-58">source</a><a href="#method.fmt_lower_exp" class="anchor"></a><h4 class="code-header">fn <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_lower_exp" class="fnname">fmt_lower_exp</a>(self) -&gt; <a class="struct" href="../../wyz/fmt/struct.FmtLowerExp.html" title="struct wyz::fmt::FmtLowerExp">FmtLowerExp</a>&lt;Self&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/fmt/trait.LowerExp.html" title="trait core::fmt::LowerExp">LowerExp</a>,</span></h4></section></summary><div class='docblock'>Causes <code>self</code> to use its <code>LowerExp</code> implementation when
<code>Debug</code>-formatted. <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_lower_exp">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt_lower_hex" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/wyz/fmt.rs.html#65-66">source</a><a href="#method.fmt_lower_hex" class="anchor"></a><h4 class="code-header">fn <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_lower_hex" class="fnname">fmt_lower_hex</a>(self) -&gt; <a class="struct" href="../../wyz/fmt/struct.FmtLowerHex.html" title="struct wyz::fmt::FmtLowerHex">FmtLowerHex</a>&lt;Self&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/fmt/trait.LowerHex.html" title="trait core::fmt::LowerHex">LowerHex</a>,</span></h4></section></summary><div class='docblock'>Causes <code>self</code> to use its <code>LowerHex</code> implementation when
<code>Debug</code>-formatted. <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_lower_hex">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt_octal" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/wyz/fmt.rs.html#72-73">source</a><a href="#method.fmt_octal" class="anchor"></a><h4 class="code-header">fn <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_octal" class="fnname">fmt_octal</a>(self) -&gt; <a class="struct" href="../../wyz/fmt/struct.FmtOctal.html" title="struct wyz::fmt::FmtOctal">FmtOctal</a>&lt;Self&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/fmt/trait.Octal.html" title="trait core::fmt::Octal">Octal</a>,</span></h4></section></summary><div class='docblock'>Causes <code>self</code> to use its <code>Octal</code> implementation when <code>Debug</code>-formatted.</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt_pointer" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/wyz/fmt.rs.html#80-81">source</a><a href="#method.fmt_pointer" class="anchor"></a><h4 class="code-header">fn <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_pointer" class="fnname">fmt_pointer</a>(self) -&gt; <a class="struct" href="../../wyz/fmt/struct.FmtPointer.html" title="struct wyz::fmt::FmtPointer">FmtPointer</a>&lt;Self&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/fmt/trait.Pointer.html" title="trait core::fmt::Pointer">Pointer</a>,</span></h4></section></summary><div class='docblock'>Causes <code>self</code> to use its <code>Pointer</code> implementation when
<code>Debug</code>-formatted. <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_pointer">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt_upper_exp" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/wyz/fmt.rs.html#88-89">source</a><a href="#method.fmt_upper_exp" class="anchor"></a><h4 class="code-header">fn <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_upper_exp" class="fnname">fmt_upper_exp</a>(self) -&gt; <a class="struct" href="../../wyz/fmt/struct.FmtUpperExp.html" title="struct wyz::fmt::FmtUpperExp">FmtUpperExp</a>&lt;Self&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/fmt/trait.UpperExp.html" title="trait core::fmt::UpperExp">UpperExp</a>,</span></h4></section></summary><div class='docblock'>Causes <code>self</code> to use its <code>UpperExp</code> implementation when
<code>Debug</code>-formatted. <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_upper_exp">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt_upper_hex" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/wyz/fmt.rs.html#96-97">source</a><a href="#method.fmt_upper_hex" class="anchor"></a><h4 class="code-header">fn <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_upper_hex" class="fnname">fmt_upper_hex</a>(self) -&gt; <a class="struct" href="../../wyz/fmt/struct.FmtUpperHex.html" title="struct wyz::fmt::FmtUpperHex">FmtUpperHex</a>&lt;Self&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/fmt/trait.UpperHex.html" title="trait core::fmt::UpperHex">UpperHex</a>,</span></h4></section></summary><div class='docblock'>Causes <code>self</code> to use its <code>UpperHex</code> implementation when
<code>Debug</code>-formatted. <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_upper_hex">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt_list" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/wyz/fmt.rs.html#108-109">source</a><a href="#method.fmt_list" class="anchor"></a><h4 class="code-header">fn <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_list" class="fnname">fmt_list</a>(self) -&gt; <a class="struct" href="../../wyz/fmt/struct.FmtList.html" title="struct wyz::fmt::FmtList">FmtList</a>&lt;Self&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;'a </a>Self: for&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>,</span></h4></section></summary><div class='docblock'>Formats each item in a sequence. <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_list">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-BitSlice%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.66.1/src/core/convert/mod.rs.html#733">source</a><a href="#impl-From%3CT%3E-for-BitSlice%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from-3" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/convert/mod.rs.html#736">source</a></span><a href="#method.from-3" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-BitSlice%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.66.1/src/core/convert/mod.rs.html#717">source</a><a href="#impl-Into%3CU%3E-for-BitSlice%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.into" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/convert/mod.rs.html#725">source</a></span><a href="#method.into" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/convert/trait.Into.html#tymethod.into" class="fnname">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.66.1/core/convert/trait.From.html" title="From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Pipe-for-BitSlice%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/tap/pipe.rs.html#234">source</a><a href="#impl-Pipe-for-BitSlice%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../tap/pipe/trait.Pipe.html" title="trait tap::pipe::Pipe">Pipe</a> for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/1.66.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.pipe" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/tap/pipe.rs.html#73-76">source</a><a href="#method.pipe" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/pipe/trait.Pipe.html#method.pipe" class="fnname">pipe</a>&lt;R&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(Self) -&gt; R) -&gt; R<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h4></section></summary><div class='docblock'>Pipes by value. This is generally the method you want to use. <a href="../../tap/pipe/trait.Pipe.html#method.pipe">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.pipe_ref" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/tap/pipe.rs.html#97-99">source</a><a href="#method.pipe_ref" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/pipe/trait.Pipe.html#method.pipe_ref" class="fnname">pipe_ref</a>&lt;'a, R&gt;(&amp;'a self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;'a </a>Self) -&gt; R) -&gt; R<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;R: 'a,</span></h4></section></summary><div class='docblock'>Borrows <code>self</code> and passes that borrow into the pipe function. <a href="../../tap/pipe/trait.Pipe.html#method.pipe_ref">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.pipe_ref_mut" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/tap/pipe.rs.html#122-127">source</a><a href="#method.pipe_ref_mut" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/pipe/trait.Pipe.html#method.pipe_ref_mut" class="fnname">pipe_ref_mut</a>&lt;'a, R&gt;(&amp;'a mut self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;'a mut </a>Self) -&gt; R) -&gt; R<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;R: 'a,</span></h4></section></summary><div class='docblock'>Mutably borrows <code>self</code> and passes that borrow into the pipe function. <a href="../../tap/pipe/trait.Pipe.html#method.pipe_ref_mut">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.pipe_borrow" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/tap/pipe.rs.html#145-149">source</a><a href="#method.pipe_borrow" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/pipe/trait.Pipe.html#method.pipe_borrow" class="fnname">pipe_borrow</a>&lt;'a, B, R&gt;(&amp;'a self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;'a </a>B) -&gt; R) -&gt; R<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;B&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;B: 'a + ?<a class="trait" href="https://doc.rust-lang.org/1.66.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: 'a,</span></h4></section></summary><div class='docblock'>Borrows <code>self</code>, then passes <code>self.borrow()</code> into the pipe function. <a href="../../tap/pipe/trait.Pipe.html#method.pipe_borrow">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.pipe_borrow_mut" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/tap/pipe.rs.html#169-176">source</a><a href="#method.pipe_borrow_mut" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/pipe/trait.Pipe.html#method.pipe_borrow_mut" class="fnname">pipe_borrow_mut</a>&lt;'a, B, R&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;'a mut self,<br>&nbsp;&nbsp;&nbsp;&nbsp;func: impl <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;'a mut </a>B) -&gt; R<br>) -&gt; R<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;B&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;B: 'a + ?<a class="trait" href="https://doc.rust-lang.org/1.66.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: 'a,</span></h4></section></summary><div class='docblock'>Mutably borrows <code>self</code>, then passes <code>self.borrow_mut()</code> into the pipe
function. <a href="../../tap/pipe/trait.Pipe.html#method.pipe_borrow_mut">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.pipe_as_ref" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/tap/pipe.rs.html#183-187">source</a><a href="#method.pipe_as_ref" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/pipe/trait.Pipe.html#method.pipe_as_ref" class="fnname">pipe_as_ref</a>&lt;'a, U, R&gt;(&amp;'a self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;'a </a>U) -&gt; R) -&gt; R<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;U&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;U: 'a + ?<a class="trait" href="https://doc.rust-lang.org/1.66.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: 'a,</span></h4></section></summary><div class='docblock'>Borrows <code>self</code>, then passes <code>self.as_ref()</code> into the pipe function.</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.pipe_as_mut" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/tap/pipe.rs.html#195-202">source</a><a href="#method.pipe_as_mut" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/pipe/trait.Pipe.html#method.pipe_as_mut" class="fnname">pipe_as_mut</a>&lt;'a, U, R&gt;(&amp;'a mut self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;'a mut </a>U) -&gt; R) -&gt; R<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/convert/trait.AsMut.html" title="trait core::convert::AsMut">AsMut</a>&lt;U&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;U: 'a + ?<a class="trait" href="https://doc.rust-lang.org/1.66.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: 'a,</span></h4></section></summary><div class='docblock'>Mutably borrows <code>self</code>, then passes <code>self.as_mut()</code> into the pipe
function. <a href="../../tap/pipe/trait.Pipe.html#method.pipe_as_mut">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.pipe_deref" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/tap/pipe.rs.html#209-213">source</a><a href="#method.pipe_deref" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/pipe/trait.Pipe.html#method.pipe_deref" class="fnname">pipe_deref</a>&lt;'a, T, R&gt;(&amp;'a self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;'a </a>T) -&gt; R) -&gt; R<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>&lt;Target = T&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + ?<a class="trait" href="https://doc.rust-lang.org/1.66.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: 'a,</span></h4></section></summary><div class='docblock'>Borrows <code>self</code>, then passes <code>self.deref()</code> into the pipe function.</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.pipe_deref_mut" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/tap/pipe.rs.html#221-228">source</a><a href="#method.pipe_deref_mut" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/pipe/trait.Pipe.html#method.pipe_deref_mut" class="fnname">pipe_deref_mut</a>&lt;'a, T, R&gt;(&amp;'a mut self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;'a mut </a>T) -&gt; R) -&gt; R<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/deref/trait.DerefMut.html" title="trait core::ops::deref::DerefMut">DerefMut</a>&lt;Target = T&gt; + <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + ?<a class="trait" href="https://doc.rust-lang.org/1.66.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: 'a,</span></h4></section></summary><div class='docblock'>Mutably borrows <code>self</code>, then passes <code>self.deref_mut()</code> into the pipe
function. <a href="../../tap/pipe/trait.Pipe.html#method.pipe_deref_mut">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Tap-for-BitSlice%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/tap/tap.rs.html#329">source</a><a href="#impl-Tap-for-BitSlice%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../tap/tap/trait.Tap.html" title="trait tap::tap::Tap">Tap</a> for T</h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.tap" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/tap/tap.rs.html#78">source</a><a href="#method.tap" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/tap/trait.Tap.html#method.tap" class="fnname">tap</a>(self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Self)) -&gt; Self</h4></section></summary><div class='docblock'>Immutable access to a value. <a href="../../tap/tap/trait.Tap.html#method.tap">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.tap_mut" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/tap/tap.rs.html#116">source</a><a href="#method.tap_mut" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/tap/trait.Tap.html#method.tap_mut" class="fnname">tap_mut</a>(self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;mut </a>Self)) -&gt; Self</h4></section></summary><div class='docblock'>Mutable access to a value. <a href="../../tap/tap/trait.Tap.html#method.tap_mut">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.tap_borrow" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/tap/tap.rs.html#129-132">source</a><a href="#method.tap_borrow" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/tap/trait.Tap.html#method.tap_borrow" class="fnname">tap_borrow</a>&lt;B&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>B)) -&gt; Self<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;B&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;B: ?<a class="trait" href="https://doc.rust-lang.org/1.66.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h4></section></summary><div class='docblock'>Immutable access to the <code>Borrow&lt;B&gt;</code> of a value. <a href="../../tap/tap/trait.Tap.html#method.tap_borrow">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.tap_borrow_mut" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/tap/tap.rs.html#146-149">source</a><a href="#method.tap_borrow_mut" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/tap/trait.Tap.html#method.tap_borrow_mut" class="fnname">tap_borrow_mut</a>&lt;B&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;mut </a>B)) -&gt; Self<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;B&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;B: ?<a class="trait" href="https://doc.rust-lang.org/1.66.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h4></section></summary><div class='docblock'>Mutable access to the <code>BorrowMut&lt;B&gt;</code> of a value. <a href="../../tap/tap/trait.Tap.html#method.tap_borrow_mut">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.tap_ref" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/tap/tap.rs.html#163-166">source</a><a href="#method.tap_ref" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/tap/trait.Tap.html#method.tap_ref" class="fnname">tap_ref</a>&lt;R&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>R)) -&gt; Self<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;R&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: ?<a class="trait" href="https://doc.rust-lang.org/1.66.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h4></section></summary><div class='docblock'>Immutable access to the <code>AsRef&lt;R&gt;</code> view of a value. <a href="../../tap/tap/trait.Tap.html#method.tap_ref">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.tap_ref_mut" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/tap/tap.rs.html#180-183">source</a><a href="#method.tap_ref_mut" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/tap/trait.Tap.html#method.tap_ref_mut" class="fnname">tap_ref_mut</a>&lt;R&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;mut </a>R)) -&gt; Self<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/convert/trait.AsMut.html" title="trait core::convert::AsMut">AsMut</a>&lt;R&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: ?<a class="trait" href="https://doc.rust-lang.org/1.66.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h4></section></summary><div class='docblock'>Mutable access to the <code>AsMut&lt;R&gt;</code> view of a value. <a href="../../tap/tap/trait.Tap.html#method.tap_ref_mut">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.tap_deref" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/tap/tap.rs.html#197-200">source</a><a href="#method.tap_deref" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/tap/trait.Tap.html#method.tap_deref" class="fnname">tap_deref</a>&lt;T&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>T)) -&gt; Self<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>&lt;Target = T&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/1.66.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h4></section></summary><div class='docblock'>Immutable access to the <code>Deref::Target</code> of a value. <a href="../../tap/tap/trait.Tap.html#method.tap_deref">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.tap_deref_mut" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/tap/tap.rs.html#214-217">source</a><a href="#method.tap_deref_mut" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/tap/trait.Tap.html#method.tap_deref_mut" class="fnname">tap_deref_mut</a>&lt;T&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;mut </a>T)) -&gt; Self<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/deref/trait.DerefMut.html" title="trait core::ops::deref::DerefMut">DerefMut</a>&lt;Target = T&gt; + <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/1.66.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h4></section></summary><div class='docblock'>Mutable access to the <code>Deref::Target</code> of a value. <a href="../../tap/tap/trait.Tap.html#method.tap_deref_mut">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.tap_dbg" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/tap/tap.rs.html#227">source</a><a href="#method.tap_dbg" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/tap/trait.Tap.html#method.tap_dbg" class="fnname">tap_dbg</a>(self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>Self)) -&gt; Self</h4></section></summary><div class='docblock'>Calls <code>.tap()</code> only in debug builds, and is erased in release builds.</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.tap_mut_dbg" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/tap/tap.rs.html#237">source</a><a href="#method.tap_mut_dbg" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/tap/trait.Tap.html#method.tap_mut_dbg" class="fnname">tap_mut_dbg</a>(self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;mut </a>Self)) -&gt; Self</h4></section></summary><div class='docblock'>Calls <code>.tap_mut()</code> only in debug builds, and is erased in release
builds. <a href="../../tap/tap/trait.Tap.html#method.tap_mut_dbg">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.tap_borrow_dbg" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/tap/tap.rs.html#247-250">source</a><a href="#method.tap_borrow_dbg" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/tap/trait.Tap.html#method.tap_borrow_dbg" class="fnname">tap_borrow_dbg</a>&lt;B&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>B)) -&gt; Self<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;B&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;B: ?<a class="trait" href="https://doc.rust-lang.org/1.66.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h4></section></summary><div class='docblock'>Calls <code>.tap_borrow()</code> only in debug builds, and is erased in release
builds. <a href="../../tap/tap/trait.Tap.html#method.tap_borrow_dbg">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.tap_borrow_mut_dbg" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/tap/tap.rs.html#261-264">source</a><a href="#method.tap_borrow_mut_dbg" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/tap/trait.Tap.html#method.tap_borrow_mut_dbg" class="fnname">tap_borrow_mut_dbg</a>&lt;B&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;mut </a>B)) -&gt; Self<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;B&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;B: ?<a class="trait" href="https://doc.rust-lang.org/1.66.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h4></section></summary><div class='docblock'>Calls <code>.tap_borrow_mut()</code> only in debug builds, and is erased in release
builds. <a href="../../tap/tap/trait.Tap.html#method.tap_borrow_mut_dbg">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.tap_ref_dbg" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/tap/tap.rs.html#275-278">source</a><a href="#method.tap_ref_dbg" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/tap/trait.Tap.html#method.tap_ref_dbg" class="fnname">tap_ref_dbg</a>&lt;R&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>R)) -&gt; Self<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;R&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: ?<a class="trait" href="https://doc.rust-lang.org/1.66.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h4></section></summary><div class='docblock'>Calls <code>.tap_ref()</code> only in debug builds, and is erased in release
builds. <a href="../../tap/tap/trait.Tap.html#method.tap_ref_dbg">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.tap_ref_mut_dbg" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/tap/tap.rs.html#289-292">source</a><a href="#method.tap_ref_mut_dbg" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/tap/trait.Tap.html#method.tap_ref_mut_dbg" class="fnname">tap_ref_mut_dbg</a>&lt;R&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;mut </a>R)) -&gt; Self<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/convert/trait.AsMut.html" title="trait core::convert::AsMut">AsMut</a>&lt;R&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: ?<a class="trait" href="https://doc.rust-lang.org/1.66.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h4></section></summary><div class='docblock'>Calls <code>.tap_ref_mut()</code> only in debug builds, and is erased in release
builds. <a href="../../tap/tap/trait.Tap.html#method.tap_ref_mut_dbg">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.tap_deref_dbg" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/tap/tap.rs.html#303-306">source</a><a href="#method.tap_deref_dbg" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/tap/trait.Tap.html#method.tap_deref_dbg" class="fnname">tap_deref_dbg</a>&lt;T&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>T)) -&gt; Self<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>&lt;Target = T&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/1.66.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h4></section></summary><div class='docblock'>Calls <code>.tap_deref()</code> only in debug builds, and is erased in release
builds. <a href="../../tap/tap/trait.Tap.html#method.tap_deref_dbg">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.tap_deref_mut_dbg" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/tap/tap.rs.html#317-320">source</a><a href="#method.tap_deref_mut_dbg" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/tap/trait.Tap.html#method.tap_deref_mut_dbg" class="fnname">tap_deref_mut_dbg</a>&lt;T&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;mut </a>T)) -&gt; Self<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/deref/trait.DerefMut.html" title="trait core::ops::deref::DerefMut">DerefMut</a>&lt;Target = T&gt; + <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/1.66.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h4></section></summary><div class='docblock'>Calls <code>.tap_deref_mut()</code> only in debug builds, and is erased in release
builds. <a href="../../tap/tap/trait.Tap.html#method.tap_deref_mut_dbg">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-ToString-for-BitSlice%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.66.1/src/alloc/string.rs.html#2526">source</a><a href="#impl-ToString-for-BitSlice%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/alloc/string/trait.ToString.html" title="trait alloc::string::ToString">ToString</a> for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/fmt/trait.Display.html" title="trait core::fmt::Display">Display</a> + ?<a class="trait" href="https://doc.rust-lang.org/1.66.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.to_string" class="method trait-impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.66.1/src/alloc/string.rs.html#2532">source</a><a href="#method.to_string" class="anchor"></a><h4 class="code-header">default fn <a href="https://doc.rust-lang.org/1.66.1/alloc/string/trait.ToString.html#tymethod.to_string" class="fnname">to_string</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.66.1/alloc/string/struct.String.html" title="struct alloc::string::String">String</a></h4></section></summary><div class='docblock'>Converts the given value to a <code>String</code>. <a href="https://doc.rust-lang.org/1.66.1/alloc/string/trait.ToString.html#tymethod.to_string">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-TryConv-for-BitSlice%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/tap/conv.rs.html#87">source</a><a href="#impl-TryConv-for-BitSlice%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../tap/conv/trait.TryConv.html" title="trait tap::conv::TryConv">TryConv</a> for T</h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.try_conv" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/tap/conv.rs.html#78-81">source</a><a href="#method.try_conv" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/conv/trait.TryConv.html#method.try_conv" class="fnname">try_conv</a>&lt;T&gt;(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.66.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.66.1/core/convert/trait.TryInto.html#associatedtype.Error" title="type core::convert::TryInto::Error">Error</a>&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;T&gt;,</span></h4></section></summary><div class='docblock'>Attempts to convert <code>self</code> into <code>T</code> using <code>TryInto&lt;T&gt;</code>. <a href="../../tap/conv/trait.TryConv.html#method.try_conv">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-BitSlice%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.66.1/src/core/convert/mod.rs.html#775">source</a><a href="#impl-TryFrom%3CU%3E-for-BitSlice%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Error-5" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Error-5" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.66.1/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.66.1/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.try_from-5" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/convert/mod.rs.html#781">source</a></span><a href="#method.try_from-5" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/convert/trait.TryFrom.html#tymethod.try_from" class="fnname">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.66.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.66.1/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-BitSlice%3CT%2C%20O%3E" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.66.1/src/core/convert/mod.rs.html#760">source</a><a href="#impl-TryInto%3CU%3E-for-BitSlice%3CT%2C%20O%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Error-6" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Error-6" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.66.1/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.66.1/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.1/src/core/convert/mod.rs.html#766">source</a></span><a href="#method.try_into" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.1/core/convert/trait.TryInto.html#tymethod.try_into" class="fnname">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.66.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.66.1/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main><div id="rustdoc-vars" data-root-path="../../" data-current-crate="bitvec" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.66.1 (90743e729 2023-01-10)" ></div></body></html>