<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A contiguous growable array of bits."><meta name="keywords" content="rust, rustlang, rust-lang, BitVec"><title>BitVec in bitvec::vec - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" href="../../normalize.css"><link rel="stylesheet" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" href="../../ayu.css" disabled><link rel="stylesheet" href="../../dark.css" disabled><link rel="stylesheet" href="../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../storage.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../main.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../favicon.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../bitvec/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div></a><h2 class="location"></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../../bitvec/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div></a><h2 class="location"><a href="#">BitVec</a></h2><div class="sidebar-elems"><section><div class="block"><h3 class="sidebar-title"><a href="#implementations">Methods</a></h3><ul><li><a href="#method.append">append</a></li><li><a href="#method.as_bitptr">as_bitptr</a></li><li><a href="#method.as_bitslice">as_bitslice</a></li><li><a href="#method.as_mut_bitptr">as_mut_bitptr</a></li><li><a href="#method.as_mut_bitslice">as_mut_bitslice</a></li><li><a href="#method.as_mut_raw_ptr">as_mut_raw_ptr</a></li><li><a href="#method.as_mut_raw_slice">as_mut_raw_slice</a></li><li><a href="#method.as_raw_ptr">as_raw_ptr</a></li><li><a href="#method.as_raw_slice">as_raw_slice</a></li><li><a href="#method.capacity">capacity</a></li><li><a href="#method.clear">clear</a></li><li><a href="#method.drain">drain</a></li><li><a href="#method.elements">elements</a></li><li><a href="#method.extend_from_bitslice">extend_from_bitslice</a></li><li><a href="#method.extend_from_raw_slice">extend_from_raw_slice</a></li><li><a href="#method.force_align">force_align</a></li><li><a href="#method.from_bitslice">from_bitslice</a></li><li><a href="#method.from_element">from_element</a></li><li><a href="#method.from_raw_parts">from_raw_parts</a></li><li><a href="#method.from_slice">from_slice</a></li><li><a href="#method.from_vec">from_vec</a></li><li><a href="#method.insert">insert</a></li><li><a href="#method.into_boxed_bitslice">into_boxed_bitslice</a></li><li><a href="#method.into_raw_parts">into_raw_parts</a></li><li><a href="#method.into_vec">into_vec</a></li><li><a href="#method.is_empty">is_empty</a></li><li><a href="#method.leak">leak</a></li><li><a href="#method.len">len</a></li><li><a href="#method.new">new</a></li><li><a href="#method.pop">pop</a></li><li><a href="#method.push">push</a></li><li><a href="#method.remove">remove</a></li><li><a href="#method.repeat">repeat</a></li><li><a href="#method.reserve">reserve</a></li><li><a href="#method.reserve_exact">reserve_exact</a></li><li><a href="#method.resize">resize</a></li><li><a href="#method.resize_default">resize_default</a></li><li><a href="#method.resize_with">resize_with</a></li><li><a href="#method.retain">retain</a></li><li><a href="#method.set_elements">set_elements</a></li><li><a href="#method.set_len">set_len</a></li><li><a href="#method.set_uninitialized">set_uninitialized</a></li><li><a href="#method.shrink_to_fit">shrink_to_fit</a></li><li><a href="#method.splice">splice</a></li><li><a href="#method.split_off">split_off</a></li><li><a href="#method.swap_remove">swap_remove</a></li><li><a href="#method.truncate">truncate</a></li><li><a href="#method.try_from_vec">try_from_vec</a></li><li><a href="#method.with_capacity">with_capacity</a></li></ul></div><div class="block"><h3 class="sidebar-title"><a href="#deref-methods-BitSlice%3CO%2C%20T%3E">Methods from Deref&lt;Target=BitSlice&lt;O, T&gt;&gt;</a></h3><ul><li><a href="#method.align_to">align_to</a></li><li><a href="#method.align_to_mut">align_to_mut</a></li><li><a href="#method.all">all</a></li><li><a href="#method.any">any</a></li><li><a href="#method.as_bitptr-1">as_bitptr</a></li><li><a href="#method.as_bitptr_range">as_bitptr_range</a></li><li><a href="#method.as_mut_bitptr-1">as_mut_bitptr</a></li><li><a href="#method.as_mut_bitptr_range">as_mut_bitptr_range</a></li><li><a href="#method.as_raw_slice-1">as_raw_slice</a></li><li><a href="#method.bit_domain">bit_domain</a></li><li><a href="#method.bit_domain_mut">bit_domain_mut</a></li><li><a href="#method.chunks">chunks</a></li><li><a href="#method.chunks_exact">chunks_exact</a></li><li><a href="#method.chunks_exact_mut">chunks_exact_mut</a></li><li><a href="#method.chunks_mut">chunks_mut</a></li><li><a href="#method.clone_from_bitslice">clone_from_bitslice</a></li><li><a href="#method.contains">contains</a></li><li><a href="#method.copy_from_bitslice">copy_from_bitslice</a></li><li><a href="#method.copy_within">copy_within</a></li><li><a href="#method.copy_within_unchecked">copy_within_unchecked</a></li><li><a href="#method.count_ones">count_ones</a></li><li><a href="#method.count_zeros">count_zeros</a></li><li><a href="#method.domain">domain</a></li><li><a href="#method.domain_mut">domain_mut</a></li><li><a href="#method.ends_with">ends_with</a></li><li><a href="#method.first">first</a></li><li><a href="#method.first_mut">first_mut</a></li><li><a href="#method.first_one">first_one</a></li><li><a href="#method.first_zero">first_zero</a></li><li><a href="#method.for_each">for_each</a></li><li><a href="#method.get">get</a></li><li><a href="#method.get_mut">get_mut</a></li><li><a href="#method.get_unchecked">get_unchecked</a></li><li><a href="#method.get_unchecked_mut">get_unchecked_mut</a></li><li><a href="#method.is_empty-1">is_empty</a></li><li><a href="#method.iter">iter</a></li><li><a href="#method.iter_mut">iter_mut</a></li><li><a href="#method.iter_ones">iter_ones</a></li><li><a href="#method.iter_zeros">iter_zeros</a></li><li><a href="#method.last">last</a></li><li><a href="#method.last_mut">last_mut</a></li><li><a href="#method.last_one">last_one</a></li><li><a href="#method.last_zero">last_zero</a></li><li><a href="#method.leading_ones">leading_ones</a></li><li><a href="#method.leading_zeros">leading_zeros</a></li><li><a href="#method.len-1">len</a></li><li><a href="#method.not_all">not_all</a></li><li><a href="#method.not_any">not_any</a></li><li><a href="#method.offset_from">offset_from</a></li><li><a href="#method.rchunks">rchunks</a></li><li><a href="#method.rchunks_exact">rchunks_exact</a></li><li><a href="#method.rchunks_exact_mut">rchunks_exact_mut</a></li><li><a href="#method.rchunks_mut">rchunks_mut</a></li><li><a href="#method.repeat-1">repeat</a></li><li><a href="#method.reverse">reverse</a></li><li><a href="#method.rotate_left">rotate_left</a></li><li><a href="#method.rotate_right">rotate_right</a></li><li><a href="#method.rsplit">rsplit</a></li><li><a href="#method.rsplit_mut">rsplit_mut</a></li><li><a href="#method.rsplitn">rsplitn</a></li><li><a href="#method.rsplitn_mut">rsplitn_mut</a></li><li><a href="#method.set">set</a></li><li><a href="#method.set_aliased">set_aliased</a></li><li><a href="#method.set_aliased_unchecked">set_aliased_unchecked</a></li><li><a href="#method.set_all">set_all</a></li><li><a href="#method.set_unchecked">set_unchecked</a></li><li><a href="#method.shift_left">shift_left</a></li><li><a href="#method.shift_right">shift_right</a></li><li><a href="#method.some">some</a></li><li><a href="#method.split">split</a></li><li><a href="#method.split_at">split_at</a></li><li><a href="#method.split_at_aliased_mut">split_at_aliased_mut</a></li><li><a href="#method.split_at_mut">split_at_mut</a></li><li><a href="#method.split_at_unchecked">split_at_unchecked</a></li><li><a href="#method.split_at_unchecked_mut">split_at_unchecked_mut</a></li><li><a href="#method.split_first">split_first</a></li><li><a href="#method.split_first_mut">split_first_mut</a></li><li><a href="#method.split_last">split_last</a></li><li><a href="#method.split_last_mut">split_last_mut</a></li><li><a href="#method.split_mut">split_mut</a></li><li><a href="#method.splitn">splitn</a></li><li><a href="#method.splitn_mut">splitn_mut</a></li><li><a href="#method.starts_with">starts_with</a></li><li><a href="#method.swap">swap</a></li><li><a href="#method.swap_unchecked">swap_unchecked</a></li><li><a href="#method.swap_with_bitslice">swap_with_bitslice</a></li><li><a href="#method.to_bitvec">to_bitvec</a></li><li><a href="#method.trailing_ones">trailing_ones</a></li><li><a href="#method.trailing_zeros">trailing_zeros</a></li><li><a href="#method.windows">windows</a></li></ul></div><div class="block"><h3 class="sidebar-title"><a href="#trait-implementations">Trait Implementations</a></h3><ul><li><a href="#impl-AsMut%3CBitSlice%3CO%2C%20T%3E%3E-for-BitVec%3CO%2C%20T%3E">AsMut&lt;BitSlice&lt;O, T&gt;&gt;</a></li><li><a href="#impl-AsRef%3CBitSlice%3CO%2C%20T%3E%3E-for-BitVec%3CO%2C%20T%3E">AsRef&lt;BitSlice&lt;O, T&gt;&gt;</a></li><li><a href="#impl-Binary-for-BitVec%3CO%2C%20T%3E">Binary</a></li><li><a href="#impl-BitAnd%3CRhs%3E-for-BitVec%3CO%2C%20T%3E">BitAnd&lt;Rhs&gt;</a></li><li><a href="#impl-BitAndAssign%3CRhs%3E-for-BitVec%3CO%2C%20T%3E">BitAndAssign&lt;Rhs&gt;</a></li><li><a href="#impl-BitField-for-BitVec%3CO%2C%20T%3E">BitField</a></li><li><a href="#impl-BitOr%3CRhs%3E-for-BitVec%3CO%2C%20T%3E">BitOr&lt;Rhs&gt;</a></li><li><a href="#impl-BitOrAssign%3CRhs%3E-for-BitVec%3CO%2C%20T%3E">BitOrAssign&lt;Rhs&gt;</a></li><li><a href="#impl-BitXor%3CRhs%3E-for-BitVec%3CO%2C%20T%3E">BitXor&lt;Rhs&gt;</a></li><li><a href="#impl-BitXorAssign%3CRhs%3E-for-BitVec%3CO%2C%20T%3E">BitXorAssign&lt;Rhs&gt;</a></li><li><a href="#impl-Borrow%3CBitSlice%3CO%2C%20T%3E%3E-for-BitVec%3CO%2C%20T%3E">Borrow&lt;BitSlice&lt;O, T&gt;&gt;</a></li><li><a href="#impl-BorrowMut%3CBitSlice%3CO%2C%20T%3E%3E-for-BitVec%3CO%2C%20T%3E">BorrowMut&lt;BitSlice&lt;O, T&gt;&gt;</a></li><li><a href="#impl-Clone-for-BitVec%3CO%2C%20T%3E">Clone</a></li><li><a href="#impl-Debug-for-BitVec%3CO%2C%20T%3E">Debug</a></li><li><a href="#impl-Default-for-BitVec%3CO%2C%20T%3E">Default</a></li><li><a href="#impl-Deref-for-BitVec%3CO%2C%20T%3E">Deref</a></li><li><a href="#impl-DerefMut-for-BitVec%3CO%2C%20T%3E">DerefMut</a></li><li><a href="#impl-Display-for-BitVec%3CO%2C%20T%3E">Display</a></li><li><a href="#impl-Drop-for-BitVec%3CO%2C%20T%3E">Drop</a></li><li><a href="#impl-Eq-for-BitVec%3CO%2C%20T%3E">Eq</a></li><li><a href="#impl-Extend%3C%26%27a%20T%3E-for-BitVec%3CO%2C%20T%3E">Extend&lt;&amp;&#39;a T&gt;</a></li><li><a href="#impl-Extend%3C%26%27a%20bool%3E-for-BitVec%3CO%2C%20T%3E">Extend&lt;&amp;&#39;a bool&gt;</a></li><li><a href="#impl-Extend%3CBitRef%3C%27a%2C%20M%2C%20O2%2C%20T2%3E%3E-for-BitVec%3CO1%2C%20T1%3E">Extend&lt;BitRef&lt;&#39;a, M, O2, T2&gt;&gt;</a></li><li><a href="#impl-Extend%3CT%3E-for-BitVec%3CO%2C%20T%3E">Extend&lt;T&gt;</a></li><li><a href="#impl-Extend%3Cbool%3E-for-BitVec%3CO%2C%20T%3E">Extend&lt;bool&gt;</a></li><li><a href="#impl-From%3C%26%27a%20BitSlice%3CO%2C%20T%3E%3E-for-BitVec%3CO%2C%20T%3E">From&lt;&amp;&#39;a BitSlice&lt;O, T&gt;&gt;</a></li><li><a href="#impl-From%3C%26%27a%20mut%20BitSlice%3CO%2C%20T%3E%3E-for-BitVec%3CO%2C%20T%3E">From&lt;&amp;&#39;a mut BitSlice&lt;O, T&gt;&gt;</a></li><li><a href="#impl-From%3CBitBox%3CO%2C%20T%3E%3E-for-BitVec%3CO%2C%20T%3E">From&lt;BitBox&lt;O, T&gt;&gt;</a></li><li><a href="#impl-From%3CBitVec%3CO%2C%20T%3E%3E-for-BitBox%3CO%2C%20T%3E">From&lt;BitVec&lt;O, T&gt;&gt;</a></li><li><a href="#impl-From%3CBitVec%3CO%2C%20T%3E%3E-for-Vec%3CT%3E">From&lt;BitVec&lt;O, T&gt;&gt;</a></li><li><a href="#impl-FromIterator%3C%26%27a%20T%3E-for-BitVec%3CO%2C%20T%3E">FromIterator&lt;&amp;&#39;a T&gt;</a></li><li><a href="#impl-FromIterator%3C%26%27a%20bool%3E-for-BitVec%3CO%2C%20T%3E">FromIterator&lt;&amp;&#39;a bool&gt;</a></li><li><a href="#impl-FromIterator%3CBitRef%3C%27a%2C%20M%2C%20O2%2C%20T2%3E%3E-for-BitVec%3CO1%2C%20T1%3E">FromIterator&lt;BitRef&lt;&#39;a, M, O2, T2&gt;&gt;</a></li><li><a href="#impl-FromIterator%3CT%3E-for-BitVec%3CO%2C%20T%3E">FromIterator&lt;T&gt;</a></li><li><a href="#impl-FromIterator%3Cbool%3E-for-BitVec%3CO%2C%20T%3E">FromIterator&lt;bool&gt;</a></li><li><a href="#impl-Hash-for-BitVec%3CO%2C%20T%3E">Hash</a></li><li><a href="#impl-Index%3CIdx%3E-for-BitVec%3CO%2C%20T%3E">Index&lt;Idx&gt;</a></li><li><a href="#impl-IndexMut%3CIdx%3E-for-BitVec%3CO%2C%20T%3E">IndexMut&lt;Idx&gt;</a></li><li><a href="#impl-IntoIterator-for-%26%27a%20BitVec%3CO%2C%20T%3E">IntoIterator</a></li><li><a href="#impl-IntoIterator-for-%26%27a%20mut%20BitVec%3CO%2C%20T%3E">IntoIterator</a></li><li><a href="#impl-IntoIterator-for-BitVec%3CO%2C%20T%3E">IntoIterator</a></li><li><a href="#impl-LowerHex-for-BitVec%3CO%2C%20T%3E">LowerHex</a></li><li><a href="#impl-Not-for-BitVec%3CO%2C%20T%3E">Not</a></li><li><a href="#impl-Octal-for-BitVec%3CO%2C%20T%3E">Octal</a></li><li><a href="#impl-Ord-for-BitVec%3CO%2C%20T%3E">Ord</a></li><li><a href="#impl-PartialEq%3CBitVec%3CO2%2C%20T2%3E%3E-for-%26BitSlice%3CO1%2C%20T1%3E">PartialEq&lt;BitVec&lt;O2, T2&gt;&gt;</a></li><li><a href="#impl-PartialEq%3CBitVec%3CO2%2C%20T2%3E%3E-for-%26mut%20BitSlice%3CO1%2C%20T1%3E">PartialEq&lt;BitVec&lt;O2, T2&gt;&gt;</a></li><li><a href="#impl-PartialEq%3CBitVec%3CO2%2C%20T2%3E%3E-for-BitSlice%3CO1%2C%20T1%3E">PartialEq&lt;BitVec&lt;O2, T2&gt;&gt;</a></li><li><a href="#impl-PartialEq%3CRhs%3E-for-BitVec%3CO%2C%20T%3E">PartialEq&lt;Rhs&gt;</a></li><li><a href="#impl-PartialOrd%3CBitVec%3CO2%2C%20T2%3E%3E-for-%26%27a%20BitSlice%3CO1%2C%20T1%3E">PartialOrd&lt;BitVec&lt;O2, T2&gt;&gt;</a></li><li><a href="#impl-PartialOrd%3CBitVec%3CO2%2C%20T2%3E%3E-for-%26%27a%20mut%20BitSlice%3CO1%2C%20T1%3E">PartialOrd&lt;BitVec&lt;O2, T2&gt;&gt;</a></li><li><a href="#impl-PartialOrd%3CBitVec%3CO2%2C%20T2%3E%3E-for-BitSlice%3CO1%2C%20T1%3E">PartialOrd&lt;BitVec&lt;O2, T2&gt;&gt;</a></li><li><a href="#impl-PartialOrd%3CRhs%3E-for-BitVec%3CO%2C%20T%3E">PartialOrd&lt;Rhs&gt;</a></li><li><a href="#impl-Send-for-BitVec%3CO%2C%20T%3E">Send</a></li><li><a href="#impl-Sync-for-BitVec%3CO%2C%20T%3E">Sync</a></li><li><a href="#impl-TryFrom%3CVec%3CT%2C%20Global%3E%3E-for-BitVec%3CO%2C%20T%3E">TryFrom&lt;Vec&lt;T, Global&gt;&gt;</a></li><li><a href="#impl-Unpin-for-BitVec%3CO%2C%20T%3E">Unpin</a></li><li><a href="#impl-UpperHex-for-BitVec%3CO%2C%20T%3E">UpperHex</a></li><li><a href="#impl-Write-for-BitVec%3CO%2C%20T%3E">Write</a></li></ul></div><div class="block"><h3 class="sidebar-title"><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul><li><a href="#impl-RefUnwindSafe-for-BitVec%3CO%2C%20T%3E">RefUnwindSafe</a></li><li><a href="#impl-UnwindSafe-for-BitVec%3CO%2C%20T%3E">UnwindSafe</a></li></ul></div><div class="block"><h3 class="sidebar-title"><a href="#blanket-implementations">Blanket Implementations</a></h3><ul><li><a href="#impl-Any-for-BitVec%3CO%2C%20T%3E">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-BitVec%3CO%2C%20T%3E">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-BitVec%3CO%2C%20T%3E">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-Conv-for-BitVec%3CO%2C%20T%3E">Conv</a></li><li><a href="#impl-FmtForward-for-BitVec%3CO%2C%20T%3E">FmtForward</a></li><li><a href="#impl-From%3CT%3E-for-BitVec%3CO%2C%20T%3E">From&lt;T&gt;</a></li><li><a href="#impl-Into%3CU%3E-for-BitVec%3CO%2C%20T%3E">Into&lt;U&gt;</a></li><li><a href="#impl-Pipe-for-BitVec%3CO%2C%20T%3E">Pipe</a></li><li><a href="#impl-Tap-for-BitVec%3CO%2C%20T%3E">Tap</a></li><li><a href="#impl-ToOwned-for-BitVec%3CO%2C%20T%3E">ToOwned</a></li><li><a href="#impl-ToString-for-BitVec%3CO%2C%20T%3E">ToString</a></li><li><a href="#impl-TryConv-for-BitVec%3CO%2C%20T%3E">TryConv</a></li><li><a href="#impl-TryFrom%3CU%3E-for-BitVec%3CO%2C%20T%3E">TryFrom&lt;U&gt;</a></li><li><a href="#impl-TryInto%3CU%3E-for-BitVec%3CO%2C%20T%3E">TryInto&lt;U&gt;</a></li></ul></div></section><h2 class="location"><a href="index.html">In bitvec::vec</a></h2></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../bitvec/index.html"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></a><nav class="sub"><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><button type="button">?</button></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../wheel.svg"></a></div></div></form></nav></div><section id="main-content" class="content"><div class="main-heading"><h1 class="fqn"><span class="in-band">Struct <a href="../index.html">bitvec</a>::<wbr><a href="index.html">vec</a>::<wbr><a class="struct" href="#">BitVec</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span></h1><span class="out-of-band"><a class="srclink" href="../../src/bitvec/vec.rs.html#263-272">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><div class="docblock item-decl"><pre class="rust struct"><code><div class="code-attribute">#[repr(C)]</div>pub struct BitVec&lt;O&nbsp;=&nbsp;<a class="struct" href="../order/struct.Lsb0.html" title="struct bitvec::order::Lsb0">Lsb0</a>, T&nbsp;=&nbsp;<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span>{ /* private fields */ }</code></pre></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A contiguous growable array of bits.</p>
<p>This is a managed, heap-allocated, buffer that contains a <a href="../slice/struct.BitSlice.html"><code>BitSlice</code></a> region.
It is analagous to <a href="https://doc.rust-lang.org/1.65.0/alloc/vec/struct.Vec.html"><code>Vec&lt;bool&gt;</code></a>, and is written to be very nearly a drop-in
replacement for it. This type contains little interesting behavior in its own
right; most of its behavior is provided by dereferencing to its managed
<a href="../slice/struct.BitSlice.html"><code>BitSlice</code></a> buffer. It instead serves primarily as an interface to the
allocator, and has some specialized behaviors for its fully-owned memory buffer.</p>
<h2 id="documentation"><a href="#documentation">Documentation</a></h2>
<p>All APIs that mirror something in the standard library will have an <code>Original</code>
section linking to the corresponding item. All APIs that have a different
signature or behavior than the original will have an <code>API Differences</code> section
explaining what has changed, and how to adapt your existing code to the change.</p>
<p>These sections look like this:</p>
<h2 id="original"><a href="#original">Original</a></h2>
<p><a href="https://doc.rust-lang.org/1.65.0/alloc/vec/struct.Vec.html"><code>Vec&lt;T&gt;</code></a></p>
<h2 id="api-differences"><a href="#api-differences">API Differences</a></h2>
<p>The buffer type <a href="https://doc.rust-lang.org/1.65.0/alloc/vec/struct.Vec.html"><code>Vec&lt;bool&gt;</code></a> has no type parameters. <code>BitVec&lt;O, T&gt;</code> has the
same two type parameters as <a href="../slice/struct.BitSlice.html"><code>BitSlice&lt;O, T&gt;</code></a>. Otherwise, <code>BitVec</code>
is able to implement the full API surface of <code>Vec&lt;bool&gt;</code>.</p>
<h2 id="examples"><a href="#examples">Examples</a></h2>
<p>Because <code>BitVec</code> takes type parameters, but has default type arguments for them,
you will need to specify its type parameters when using its associated
functions. The easiest way to do this is to declare bindings type as <code>: BitVec</code>,
which uses the default type arguments.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv: BitVec = BitVec::new();
bv.push(<span class="bool-val">false</span>);
bv.push(<span class="bool-val">true</span>);

<span class="macro">assert_eq!</span>(bv.len(), <span class="number">2</span>);
<span class="macro">assert_eq!</span>(bv[<span class="number">0</span>], <span class="bool-val">false</span>);

<span class="macro">assert_eq!</span>(bv.pop(), <span class="prelude-val">Some</span>(<span class="bool-val">true</span>));
<span class="macro">assert_eq!</span>(bv.len(), <span class="number">1</span>);

<span class="comment">// `BitVec` cannot yet support `[]=` write indexing.
</span><span class="kw-2">*</span>bv.get_mut(<span class="number">0</span>).unwrap() = <span class="bool-val">true</span>;
<span class="macro">assert_eq!</span>(bv[<span class="number">0</span>], <span class="bool-val">true</span>);

bv.extend(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]);

<span class="kw">for </span>bit <span class="kw">in </span><span class="kw-2">&amp;</span>bv {
  <span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, bit);
}
<span class="macro">assert_eq!</span>(bv, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]);</code></pre></div>
<p>The <a href="../macro.bitvec.html"><code>bitvec!</code></a> macro is provided to make initialization more convenient:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv = <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
bv.push(<span class="bool-val">true</span>);
<span class="macro">assert_eq!</span>(bv, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]);</code></pre></div>
<p>It has the same argument syntax as <a href="https://doc.rust-lang.org/1.65.0/alloc/macro.vec.html"><code>vec!</code></a>. In addition, it can take type
arguments for ordering and storage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bv = <span class="macro">bitvec!</span>[Msb0, u16; <span class="number">1</span>; <span class="number">30</span>];
<span class="macro">assert!</span>(bv.all());
<span class="macro">assert_eq!</span>(bv.len(), <span class="number">30</span>);</code></pre></div>
<h2 id="indexing"><a href="#indexing">Indexing</a></h2>
<p>The <code>BitVec</code> type allows you to access bits by index, because it implements the
<a href="https://doc.rust-lang.org/1.65.0/core/ops/index/trait.Index.html"><code>Index</code></a> trait. However, because <a href="https://doc.rust-lang.org/1.65.0/core/ops/index/trait.IndexMut.html"><code>IndexMut</code></a> requires producing an <code>&amp;mut bool</code>
reference, it cannot implement <code>[]=</code> index assignment syntax. Instead, you must
use <a href="../slice/struct.BitSlice.html#method.get_mut"><code>get_mut</code></a> or <a href="../slice/struct.BitSlice.html#method.get_unchecked_mut"><code>get_unchecked_mut</code></a> to produce proxy types that can serve
the same purpose.</p>
<h2 id="slicing"><a href="#slicing">Slicing</a></h2>
<p>A <code>BitVec</code> is resizable, while <a href="../slice/struct.BitSlice.html"><code>BitSlice</code></a> is a fixed-size view of a buffer.
Just as with ordinary <a href="https://doc.rust-lang.org/1.65.0/alloc/vec/struct.Vec.html"><code>Vec</code></a>s and slices, you can get a <code>BitSlice</code> from a
<code>BitVec</code> by borrowing it:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">fn </span>read_bitslice(slice: <span class="kw-2">&amp;</span>BitSlice) {
  <span class="comment">// …
</span>}

<span class="kw">let </span>bv = <span class="macro">bitvec!</span>[<span class="number">0</span>; <span class="number">30</span>];
read_bitslice(<span class="kw-2">&amp;</span>bv);

<span class="comment">// … and that’s all!
// you can also do it like this:
</span><span class="kw">let </span>x: <span class="kw-2">&amp;</span>BitSlice = <span class="kw-2">&amp;</span>bv;</code></pre></div>
<p>As with ordinary Rust types, you should prefer passing bit-slices rather than
buffers when you just want to inspect the data, and not manage the underlying
memory region.</p>
<h2 id="behavior"><a href="#behavior">Behavior</a></h2>
<p>Because <code>BitVec</code> is a fully-owned buffer, it is able to operate on its memory
without concern for any other views that may alias. This enables it to
specialize some <a href="../slice/struct.BitSlice.html"><code>BitSlice</code></a> behavior to be faster or more efficient. However,
<code>BitVec</code> is <em>not</em> restricted to only using unaliased integer storage, and
technically permits the construction of <code>BitVec&lt;_, AtomicType&gt;</code>.</p>
<p>This restriction is extremely awkward and constraining to write in the library,
and clients will probably never attempt to construct them, but the possibility
is still present. Be aware of this possibility when using generic code to
convert from <code>BitSlice</code> to <code>BitVec</code>. Fully-typed code does not need to be
concerned with this possibility.</p>
<h2 id="capacity-and-reällocation"><a href="#capacity-and-reällocation">Capacity and Reällocation</a></h2>
<p>The capacity of a bit-vector is the amount of space allocated for any future
bits that will be added onto the vector. This is not to be confused with the
<em>length</em> of a vector, which specifies the number of actual bits within the
vector. If a vector’s length exceeds its capacity, its capacity will
automatically be increased, but its buffer will have to be reällocated</p>
<p>For example, a bit-vector with capacity 64 and length 0 would be an empty vector
with space for 64 more bits. Pushing 64 or fewer bits onto the vector will not
change its capacity or cause reällocation to occur. However, if the vector’s
length is increased to 65, it <em>may</em> have to reällocate, which can be slow. For
this reason, it is recommended to use <a href="struct.BitVec.html#method.with_capacity"><code>BitVec::with_capacity</code></a> whenever
possible to specify how big the vector is expected to get.</p>
<h2 id="safety"><a href="#safety">Safety</a></h2>
<p>Like <a href="../slice/struct.BitSlice.html"><code>BitSlice</code></a>, <code>BitVec</code> is exactly equal in size to <a href="https://doc.rust-lang.org/1.65.0/alloc/vec/struct.Vec.html"><code>Vec</code></a>, and is also
absolutely representation-incompatible with it. You must never attempt to
type-cast between <code>Vec&lt;T&gt;</code> and <code>BitVec</code> in any way, nor attempt to modify the
memory value of a <code>BitVec</code> handle. Doing so will cause allocator and memory
errors in your program, likely inducing a panic.</p>
<p>Everything in the <code>BitVec</code> public API, even the <code>unsafe</code> parts, are guaranteed
to have no more unsafety than their equivalent items in the standard library.
All <code>unsafe</code> APIs will have documentation explicitly detailing what the API
requires you to uphold in order for it to function safely and correctly. All
safe APIs will do so themselves.</p>
<h2 id="performance"><a href="#performance">Performance</a></h2>
<p>The choice of <a href="../store/trait.BitStore.html"><code>BitStore</code></a> type parameter can impact your vector’s performance,
as the allocator operates in units of <code>T</code> rather than in bits. This means that
larger register types will increase the amount of memory reserved in each call
to the allocator, meaning fewer calls to <a href="struct.BitVec.html#method.push"><code>push</code></a> will actually cause a
reällocation. In addition, iteration over the vector is governed by the
<a href="../slice/struct.BitSlice.html"><code>BitSlice</code></a> characteristics on the type parameter. You are generally better off
using larger types when your vector is a data collection rather than a specific
I/O protocol buffer.</p>
<h2 id="macro-construction"><a href="#macro-construction">Macro Construction</a></h2>
<p>Heap allocation can only occur at runtime, but the <a href="../macro.bitvec.html"><code>bitvec!</code></a> macro will
construct an appropriate <a href="../slice/struct.BitSlice.html"><code>BitSlice</code></a> buffer at compile-time, and at run-time,
only copy the buffer into a heap allocation.</p>
</div></details><h2 id="implementations" class="small-section-header">Implementations<a href="#implementations" class="anchor"></a></h2><div id="implementations-list"><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BitVec%3CO%2C%20T%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/api.rs.html#38-1181">source</a><a href="#impl-BitVec%3CO%2C%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section></summary><div class="docblock"><p>Port of the <code>Vec&lt;T&gt;</code> inherent API.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.new" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/api.rs.html#59-64">source</a><h4 class="code-header">pub fn <a href="#method.new" class="fnname">new</a>() -&gt; Self</h4></section></summary><div class="docblock"><p>Constructs a new, empty, <code>BitVec&lt;O, T&gt;</code>.</p>
<p>The bit-vector will not allocate until bits are pushed onto it.</p>
<h5 id="original-1"><a href="#original-1">Original</a></h5>
<p><a href="https://doc.rust-lang.org/1.65.0/alloc/vec/struct.Vec.html#method.new"><code>Vec::new</code></a></p>
<h5 id="examples-1"><a href="#examples-1">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv: BitVec = BitVec::new();</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.with_capacity" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/api.rs.html#114-129">source</a><h4 class="code-header">pub fn <a href="#method.with_capacity" class="fnname">with_capacity</a>(capacity: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Constructs a new, empty, <code>BitVec&lt;O, T&gt;</code> with the specified capacity (in
bits).</p>
<p>The bit-vector will be able to hold at least <code>capacity</code> bits without
reällocating. If <code>capacity</code> is 0, the bit-vector will not allocate.</p>
<p>It is important to note that although the returned bit-vector has the
<em>capacity</em> specified, the bit-vector will have a zero <em>length</em>. For an
explanation of the difference between length and capacity, see
<em><a href="#capacity-and-reallocation">Capacity and reällocation</a></em>.</p>
<h5 id="original-2"><a href="#original-2">Original</a></h5>
<p><a href="https://doc.rust-lang.org/1.65.0/alloc/vec/struct.Vec.html#method.with_capacity"><code>Vec::with_capacity</code></a></p>
<h5 id="panics"><a href="#panics">Panics</a></h5>
<p>Panics if the requested capacity exceeds the bit-vector’s limits.</p>
<h5 id="examples-2"><a href="#examples-2">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv: BitVec = BitVec::with_capacity(<span class="number">128</span>);

<span class="comment">// The bit-vector contains no bits, even
// though it has the capacity for more.
</span><span class="macro">assert_eq!</span>(bv.len(), <span class="number">0</span>);
<span class="macro">assert!</span>(bv.capacity() &gt;= <span class="number">128</span>);

<span class="comment">// These are all done
// without reällocating…
</span><span class="kw">for </span>i <span class="kw">in </span><span class="number">0 </span>.. <span class="number">128 </span>{
  bv.push(i &amp; <span class="number">0xC0 </span>== i);
}
<span class="macro">assert_eq!</span>(bv.len(), <span class="number">128</span>);
<span class="macro">assert!</span>(bv.capacity() &gt;= <span class="number">128</span>);

<span class="comment">// …but this may make the
// bit-vector reällocate.
</span>bv.push(<span class="bool-val">false</span>);
<span class="macro">assert_eq!</span>(bv.len(), <span class="number">129</span>);
<span class="macro">assert!</span>(bv.capacity() &gt;= <span class="number">129</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.into_raw_parts" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/api.rs.html#175-179">source</a><h4 class="code-header">pub fn <a href="#method.into_raw_parts" class="fnname">into_raw_parts</a>(self) -&gt; (<a class="struct" href="../prelude/struct.BitPtr.html" title="struct bitvec::prelude::BitPtr">BitPtr</a>&lt;<a class="struct" href="../ptr/struct.Mut.html" title="struct bitvec::ptr::Mut">Mut</a>, O, T&gt;, <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>, <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Decomposes a <code>BitVec&lt;O, T&gt;</code> into its raw components.</p>
<p>Returns the raw bit-pointer to the underlying data, the length of the
bit-vector (in bits), and the allocated capacity of the buffer (in
bits). These are the same arguments in the same order as the arguments
to <a href="struct.BitVec.html#method.from_raw_parts"><code>from_raw_parts</code></a>.</p>
<p>After calling this function, the caller is responsible for the memory
previously managed by the <code>BitVec</code>. The only way to do this is to
convert the raw bit-pointer, length, and capacity back into a <code>BitVec</code>
with the <a href="struct.BitVec.html#method.from_raw_parts"><code>from_raw_parts</code></a> function, allowing the destructor to perform
the cleanup.</p>
<h5 id="original-3"><a href="#original-3">Original</a></h5>
<p><a href="https://doc.rust-lang.org/1.65.0/alloc/vec/struct.Vec.html#method.into_raw_parts"><code>Vec::into_raw_parts</code></a></p>
<h5 id="api-differences-1"><a href="#api-differences-1">API Differences</a></h5>
<p>This returns a <code>BitPtr</code>, rather than a <code>*mut T</code>. If you need the actual
memory address, <a href="../prelude/struct.BitPtr.html#method.pointer"><code>BitPtr::pointer</code></a> will produce it.</p>
<h5 id="examples-3"><a href="#examples-3">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;
<span class="kw">use </span>core::cell::Cell;

<span class="kw">let </span>bv: BitVec = <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];

<span class="kw">let </span>(ptr, len, cap) = bv.into_raw_parts();

<span class="kw">let </span>rebuilt = <span class="kw">unsafe </span>{
  <span class="comment">// We can now make changes to the components, such
  // as casting the pointer to a compatible type.
  </span><span class="kw">let </span>ptr = ptr.cast::&lt;Cell&lt;usize&gt;&gt;();
  BitVec::from_raw_parts(ptr, len, cap)
};
<span class="macro">assert_eq!</span>(rebuilt, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from_raw_parts" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/api.rs.html#253-265">source</a><h4 class="code-header">pub unsafe fn <a href="#method.from_raw_parts" class="fnname">from_raw_parts</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;bitptr: <a class="struct" href="../prelude/struct.BitPtr.html" title="struct bitvec::prelude::BitPtr">BitPtr</a>&lt;<a class="struct" href="../ptr/struct.Mut.html" title="struct bitvec::ptr::Mut">Mut</a>, O, T&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;length: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;capacity: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a><br>) -&gt; Self</h4></section></summary><div class="docblock"><p>Creates a <code>BitVec&lt;O, T&gt;</code> directly from the raw components of another
bit-vector.</p>
<h5 id="original-4"><a href="#original-4">Original</a></h5>
<p><a href="https://doc.rust-lang.org/1.65.0/alloc/vec/struct.Vec.html#method.from_raw_parts"><code>Vec::from_raw_parts</code></a></p>
<h5 id="api-differences-2"><a href="#api-differences-2">API Differences</a></h5>
<p>This takes a <code>BitPtr</code>, rather than a <code>*mut T</code>. If you only have a
pointer, you can construct a <code>BitPtr</code> to its zeroth bit before calling
this.</p>
<h5 id="safety-1"><a href="#safety-1">Safety</a></h5>
<p>This is highly unsafe, due to the number of invariants that aren’t
checked:</p>
<ul>
<li><code>bitptr</code> needs to have been previously allocated by <code>BitVec&lt;O, T&gt;</code>, or
constructed from a pointer allocated by <a href="https://doc.rust-lang.org/1.65.0/alloc/vec/struct.Vec.html"><code>Vec&lt;T&gt;</code></a>.</li>
<li><code>T</code> needs to have the same size and alignment as what <code>bitptr</code> was
allocated with. (<code>T</code> having a less strict alignment is not sufficient;
the alignment really needs to be equal to satisfy the <a href="https://doc.rust-lang.org/1.65.0/core/alloc/global/trait.GlobalAlloc.html#tymethod.dealloc"><code>dealloc</code></a>
requirement that memory must be allocated and deällocated with the
same layout.) However, you can safely cast between bare integers,
<code>BitSafe</code> integers, <code>Cell</code> wrappers, and atomic integers, as long as
they all have the same width.</li>
<li><code>length</code> needs to be less than or equal to capacity.</li>
<li><code>capacity</code> needs to be the capacity (in bits) that the bit-pointer was
allocated with (less any head offset in <code>bitptr</code>).</li>
</ul>
<p>Violating these <strong>will</strong> cause problems. For example, it is <strong>not</strong> safe
to build a <code>BitVec&lt;_, u8&gt;</code> from a pointer to a <code>u16</code> sequence and twice
its original length, because the allocator cares about the alignment,
and these two types have different alignments. The buffer was allocated
with alignment 2 (for <code>u16</code>), but after turning it into a <code>BitVec&lt;_, u8&gt;</code>, it’ll be deällocated with alignment 1.</p>
<p>The ownership of <code>bitptr</code>is effectively transferred to the <code>BitVec&lt;O, T&gt;</code> which may then deällocate, reällocate, or change the contents of
memory pointed to by the bit-pointer at will. Ensure that nothing else
uses the pointer after calling this function.</p>
<h5 id="examples-4"><a href="#examples-4">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;
<span class="kw">use </span>bitvec::ptr <span class="kw">as </span>bv_ptr;
<span class="kw">use </span>core::mem::ManuallyDrop;

<span class="kw">let </span>bv = <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let </span><span class="kw-2">mut </span>bv = ManuallyDrop::new(bv);
<span class="kw">let </span>bp = bv.as_mut_bitptr();
<span class="kw">let </span>len = bv.len();
<span class="kw">let </span>cap = bv.capacity();

<span class="kw">unsafe </span>{
  <span class="comment">// Overwrite memory with the inverse bits.
  </span><span class="kw">for </span>i <span class="kw">in </span><span class="number">0 </span>.. len {
    <span class="kw">let </span>bp = bp.add(i);
    bv_ptr::write(bp, !bv_ptr::read(bp.immut()));
  }

  <span class="comment">// Put everything back together into a `BitVec`.
  </span><span class="kw">let </span>rebuilt = BitVec::from_raw_parts(bp, len, cap);
  <span class="macro">assert_eq!</span>(rebuilt, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]);
}</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.capacity" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/api.rs.html#282-290">source</a><h4 class="code-header">pub fn <a href="#method.capacity" class="fnname">capacity</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the number of bits the bit-vector can hold without reällocating.</p>
<h5 id="original-5"><a href="#original-5">Original</a></h5>
<p><a href="https://doc.rust-lang.org/1.65.0/alloc/vec/struct.Vec.html#method.capacity"><code>Vec::capacity</code></a></p>
<h5 id="examples-5"><a href="#examples-5">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bv: BitVec = BitVec::with_capacity(<span class="number">100</span>);
<span class="macro">assert!</span>(bv.capacity() &gt;= <span class="number">100</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.reserve" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/api.rs.html#316-318">source</a><h4 class="code-header">pub fn <a href="#method.reserve" class="fnname">reserve</a>(&amp;mut self, additional: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Reserves capacity for at least <code>additional</code> more bits to be inserted in
the given <code>BitVec&lt;O, T&gt;</code>. The collection may reserve more space to avoid
frequent reällocations. After calling <code>reserve</code>, capacity will be
greater than or equal to <code>self.len() + additional</code>. Does nothing if
capacity is already sufficient.</p>
<h5 id="original-6"><a href="#original-6">Original</a></h5>
<p><a href="https://doc.rust-lang.org/1.65.0/alloc/vec/struct.Vec.html#method.reserve"><code>Vec::reserve</code></a></p>
<h5 id="panics-1"><a href="#panics-1">Panics</a></h5>
<p>Panics if the new capacity exceeds the bit-vector’s limits.</p>
<h5 id="examples-6"><a href="#examples-6">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv = <span class="macro">bitvec!</span>[<span class="number">1</span>];
bv.reserve(<span class="number">100</span>);
<span class="macro">assert!</span>(bv.capacity() &gt;= <span class="number">101</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.reserve_exact" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/api.rs.html#347-349">source</a><h4 class="code-header">pub fn <a href="#method.reserve_exact" class="fnname">reserve_exact</a>(&amp;mut self, additional: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Reserves the minimum capacity for exactly <code>additional</code> more bits to be
inserted in the given <code>BitVec&lt;O, T&gt;</code>. After calling <code>reserve_exact</code>,
capacity will be greater than or equal to <code>self.len() + additional</code>.
Does nothing if the capacity is already sufficient.</p>
<p>Note that the allocator may give the collection more space than it
requests. Therefore, capacity can not be relied upon to be precisely
minimal. Prefer <code>reserve</code> if future insertions are expected.</p>
<h5 id="original-7"><a href="#original-7">Original</a></h5>
<p><a href="https://doc.rust-lang.org/1.65.0/alloc/vec/struct.Vec.html#method.reserve_exact"><code>Vec::reserve_exact</code></a></p>
<h5 id="panics-2"><a href="#panics-2">Panics</a></h5>
<p>Panics if the new capacity exceeds the vector’s limits.</p>
<h5 id="examples-7"><a href="#examples-7">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv = <span class="macro">bitvec!</span>[<span class="number">1</span>];
bv.reserve_exact(<span class="number">100</span>);
<span class="macro">assert!</span>(bv.capacity() &gt;= <span class="number">101</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.shrink_to_fit" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/api.rs.html#372-374">source</a><h4 class="code-header">pub fn <a href="#method.shrink_to_fit" class="fnname">shrink_to_fit</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Shrinks the capacity of the bit-vector as much as possible.</p>
<p>It will drop down as close as possible to the length, but the allocator
may still inform the bit-vector that there is space for a few more bits.</p>
<h5 id="original-8"><a href="#original-8">Original</a></h5>
<p><a href="https://doc.rust-lang.org/1.65.0/alloc/vec/struct.Vec.html#method.shrink_to_fit"><code>Vec::shrink_to_fit</code></a></p>
<h5 id="examples-8"><a href="#examples-8">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv: BitVec = BitVec::with_capacity(<span class="number">100</span>);
bv.extend([<span class="bool-val">false</span>, <span class="bool-val">true</span>, <span class="bool-val">false</span>].iter().copied());
<span class="macro">assert!</span>(bv.capacity() &gt;= <span class="number">100</span>);
bv.shrink_to_fit();
<span class="macro">assert!</span>(bv.capacity() &gt;= <span class="number">3</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.truncate" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/api.rs.html#441-445">source</a><h4 class="code-header">pub fn <a href="#method.truncate" class="fnname">truncate</a>(&amp;mut self, len: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Shortens the bit-vector, keeping the first <code>len</code> bits and dropping the
rest.</p>
<p>If <code>len</code> is greater than the bit-vector’s current length, this has no
effect.</p>
<p>The <a href="struct.BitVec.html#method.drain"><code>drain</code></a> method can emulate <code>truncate</code>, but causes the excess bits
to be returned instead of dropped.</p>
<p>Note that this method has no effect on the allocated capacity of the
bit-vector, <strong>nor does it erase truncated memory</strong>. Bits in the
allocated memory that are outside of the <a href="struct.BitVec.html#method.as_bitslice"><code>as_bitslice</code></a> view always
have <strong>unspecified</strong> values, and cannot be relied upon to be zero.</p>
<h5 id="original-9"><a href="#original-9">Original</a></h5>
<p><a href="https://doc.rust-lang.org/1.65.0/alloc/vec/struct.Vec.html#method.truncate"><code>Vec::truncate</code></a></p>
<h5 id="examples-9"><a href="#examples-9">Examples</a></h5>
<p>Truncating a five-bit vector to two bits:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv = <span class="macro">bitvec!</span>[<span class="number">1</span>; <span class="number">5</span>];
bv.truncate(<span class="number">2</span>);
<span class="macro">assert_eq!</span>(bv.len(), <span class="number">2</span>);
<span class="macro">assert!</span>(bv.as_raw_slice()[<span class="number">0</span>].count_ones() &gt;= <span class="number">5</span>);</code></pre></div>
<p>No truncation occurs when <code>len</code> is greater than the vector’s current
length:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv = <span class="macro">bitvec!</span>[<span class="number">1</span>; <span class="number">3</span>];
bv.truncate(<span class="number">8</span>);
<span class="macro">assert_eq!</span>(bv.len(), <span class="number">3</span>);</code></pre></div>
<p>Truncating when <code>len == 0</code> is equivalent to calling the <a href="struct.BitVec.html#method.clear"><code>clear</code></a>
method.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv = <span class="macro">bitvec!</span>[<span class="number">0</span>; <span class="number">3</span>];
bv.truncate(<span class="number">0</span>);
<span class="macro">assert!</span>(bv.is_empty());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.set_len" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/api.rs.html#545-560">source</a><h4 class="code-header">pub unsafe fn <a href="#method.set_len" class="fnname">set_len</a>(&amp;mut self, new_len: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Forces the length of the bit-vector to <code>new_len</code>.</p>
<p>This is a low-level operation that maintains none of the normal
invariants of the type. Normally changing the length of a bit-vector is
done using one of the safe operations instead, such as <a href="struct.BitVec.html#method.truncate"><code>truncate</code></a>,
<a href="struct.BitVec.html#method.resize"><code>resize</code></a>, <a href="struct.BitVec.html#method.extend"><code>extend</code></a>, or <a href="struct.BitVec.html#method.clear"><code>clear</code></a>.</p>
<h5 id="original-10"><a href="#original-10">Original</a></h5>
<p><a href="https://doc.rust-lang.org/1.65.0/alloc/vec/struct.Vec.html#method.set_len"><code>Vec::set_len</code></a></p>
<h5 id="safety-2"><a href="#safety-2">Safety</a></h5>
<ul>
<li><code>new_len</code> must be less than or equal to <a href="struct.BitVec.html#method.capacity"><code>self.capacity()</code></a>.</li>
<li>The memory elements underlying <code>old_len .. new_len</code> must be
initialized.</li>
</ul>
<h5 id="examples-10"><a href="#examples-10">Examples</a></h5>
<p>This method can be useful for situations in which the bit-vector is
serving as a buffer for other code, particularly over FFI:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="comment">// `bitvec` could pair with `rustler` for a better bitstream
</span><span class="kw">type </span>ErlBitstring = BitVec&lt;Msb0, u8&gt;;
<span class="kw">let </span><span class="kw-2">mut </span>bits_read = <span class="number">0</span>;
<span class="comment">// An imaginary Erlang function wants a large bit buffer.
</span><span class="kw">let </span><span class="kw-2">mut </span>buf = ErlBitstring::with_capacity(<span class="number">32_768</span>);
<span class="comment">// SAFETY: When `erl_read_bits` returns `ERL_OK`, it holds that:
// 1. `bits_read` bits were initialized.
// 2. `bits_read` &lt;= the capacity (32_768)
// which makes `set_len` safe to call.
</span><span class="kw">unsafe </span>{
  <span class="comment">// Make the FFI call…
  </span><span class="kw">let </span>status = erl_read_bits(<span class="kw-2">&amp;mut </span>buf, <span class="number">10</span>, <span class="kw-2">&amp;mut </span>bits_read);
  <span class="kw">if </span>status == ERL_OK {
    <span class="comment">// …and update the length to what was read in.
    </span>buf.set_len(bits_read);
  }
}</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.swap_remove" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/api.rs.html#589-597">source</a><h4 class="code-header">pub fn <a href="#method.swap_remove" class="fnname">swap_remove</a>(&amp;mut self, index: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Removes a bit from the bit-vector and returns it.</p>
<p>The removed bit is replaced by the last bit of the bit-vector.</p>
<p>This does not preserve ordering, but is O(1).</p>
<h5 id="original-11"><a href="#original-11">Original</a></h5>
<p><a href="https://doc.rust-lang.org/1.65.0/alloc/vec/struct.Vec.html#method.swap_remove"><code>Vec::swap_remove</code></a></p>
<h5 id="panics-3"><a href="#panics-3">Panics</a></h5>
<p>Panics if <code>index</code> is out of bounds.</p>
<h5 id="examples-11"><a href="#examples-11">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv = <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="macro">assert!</span>(!bv.swap_remove(<span class="number">1</span>));
<span class="macro">assert_eq!</span>(bv, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]);

<span class="macro">assert!</span>(!bv.swap_remove(<span class="number">0</span>));
<span class="macro">assert_eq!</span>(bv, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.insert" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/api.rs.html#622-626">source</a><h4 class="code-header">pub fn <a href="#method.insert" class="fnname">insert</a>(&amp;mut self, index: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>, value: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a>)</h4></section></summary><div class="docblock"><p>Inserts a bit at position <code>index</code> within the bit-vector, shifting all
bits after it to the right.</p>
<h5 id="original-12"><a href="#original-12">Original</a></h5>
<p><a href="https://doc.rust-lang.org/1.65.0/alloc/vec/struct.Vec.html#method.insert"><code>Vec::insert</code></a></p>
<h5 id="panics-4"><a href="#panics-4">Panics</a></h5>
<p>Panics if <code>index &gt; len</code>.</p>
<h5 id="examples-12"><a href="#examples-12">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv = <span class="macro">bitvec!</span>[<span class="number">0</span>; <span class="number">5</span>];
bv.insert(<span class="number">5</span>, <span class="bool-val">true</span>);
<span class="macro">assert_eq!</span>(bv, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]);
bv.insert(<span class="number">2</span>, <span class="bool-val">true</span>);
<span class="macro">assert_eq!</span>(bv, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.remove" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/api.rs.html#649-657">source</a><h4 class="code-header">pub fn <a href="#method.remove" class="fnname">remove</a>(&amp;mut self, index: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Removes and returns the bit at position <code>index</code> within the bit-vector,
shifting all bits after it to the left.</p>
<h5 id="original-13"><a href="#original-13">Original</a></h5>
<p><a href="https://doc.rust-lang.org/1.65.0/alloc/vec/struct.Vec.html#method.remove"><code>Vec::remove</code></a></p>
<h5 id="panics-5"><a href="#panics-5">Panics</a></h5>
<p>Panics if <code>index</code> is out of bounds.</p>
<h5 id="examples-13"><a href="#examples-13">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv = <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="macro">assert!</span>(bv.remove(<span class="number">1</span>));
<span class="macro">assert_eq!</span>(bv, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.retain" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/api.rs.html#685-707">source</a><h4 class="code-header">pub fn <a href="#method.retain" class="fnname">retain</a>&lt;F&gt;(&amp;mut self, func: F)<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a>,</span></h4></section></summary><div class="docblock"><p>Retains only the bits specified by the predicate.</p>
<p>In other words, remove all bits <code>b</code> such that <code>func(idx(b), &amp;b)</code> returns
<code>false</code>. This method operates in place, visiting each bit exactly once
in the original order, and preserves the order of the retained bits.</p>
<h5 id="original-14"><a href="#original-14">Original</a></h5>
<p><a href="https://doc.rust-lang.org/1.65.0/alloc/vec/struct.Vec.html#method.retain"><code>Vec::retain</code></a></p>
<h5 id="api-differences-3"><a href="#api-differences-3">API Differences</a></h5>
<p>In order to allow more than one bit of information for the retention
decision, the predicate receives the index of each bit, as well as its
value.</p>
<h5 id="examples-14"><a href="#examples-14">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv = <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
bv.retain(|i, b| (i % <span class="number">2 </span>== <span class="number">0</span>) ^ b);
<span class="macro">assert_eq!</span>(bv, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.push" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/api.rs.html#730-747">source</a><h4 class="code-header">pub fn <a href="#method.push" class="fnname">push</a>(&amp;mut self, value: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a>)</h4></section></summary><div class="docblock"><p>Appends a bit to the back of a collection.</p>
<h5 id="original-15"><a href="#original-15">Original</a></h5>
<p><a href="https://doc.rust-lang.org/1.65.0/alloc/vec/struct.Vec.html#method.push"><code>Vec::push</code></a></p>
<h5 id="panics-6"><a href="#panics-6">Panics</a></h5>
<p>Panics if the number of bits in the bit-vector exceeds the maximum
bit-vector capacity.</p>
<h5 id="examples-15"><a href="#examples-15">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv = <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">0</span>];
bv.push(<span class="bool-val">true</span>);
<span class="macro">assert_eq!</span>(bv.count_ones(), <span class="number">1</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.pop" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/api.rs.html#768-777">source</a><h4 class="code-header">pub fn <a href="#method.pop" class="fnname">pop</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.65.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a>&gt;</h4></section></summary><div class="docblock"><p>Removes the last bit from a bit-vector and returns it, or <a href="https://doc.rust-lang.org/1.65.0/core/option/enum.Option.html#variant.None"><code>None</code></a> if it
is empty.</p>
<h5 id="original-16"><a href="#original-16">Original</a></h5>
<p><a href="https://doc.rust-lang.org/1.65.0/alloc/vec/struct.Vec.html#method.pop"><code>Vec::pop</code></a></p>
<h5 id="examples-16"><a href="#examples-16">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv = <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="macro">assert_eq!</span>(bv.pop(), <span class="prelude-val">Some</span>(<span class="bool-val">true</span>));
<span class="macro">assert_eq!</span>(bv, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.append" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/api.rs.html#808-819">source</a><h4 class="code-header">pub fn <a href="#method.append" class="fnname">append</a>&lt;O2, T2&gt;(&amp;mut self, other: &amp;mut <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O2, T2&gt;)<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h4></section></summary><div class="docblock"><p>Moves all the bits of <code>other</code> into <code>self</code>, leaving <code>other</code> empty.</p>
<h5 id="original-17"><a href="#original-17">Original</a></h5>
<p><a href="https://doc.rust-lang.org/1.65.0/alloc/vec/struct.Vec.html#method.append"><code>Vec::append</code></a></p>
<h5 id="api-differences-4"><a href="#api-differences-4">API Differences</a></h5>
<p>This permits <code>other</code> to have different type parameters than <code>self</code>, and
does not require that it be of literally <code>Self</code>.</p>
<h5 id="panics-7"><a href="#panics-7">Panics</a></h5>
<p>Panics if the number of bits overflows the maximum bit-vector capacity.</p>
<h5 id="examples-17"><a href="#examples-17">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv1 = <span class="macro">bitvec!</span>[Msb0, u16; <span class="number">0</span>; <span class="number">10</span>];
<span class="kw">let </span><span class="kw-2">mut </span>bv2 = <span class="macro">bitvec!</span>[Lsb0, u32; <span class="number">1</span>; <span class="number">10</span>];

bv1.append(<span class="kw-2">&amp;mut </span>bv2);

<span class="macro">assert_eq!</span>(bv1.count_ones(), <span class="number">10</span>);
<span class="macro">assert!</span>(bv2.is_empty());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.drain" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/api.rs.html#854-857">source</a><h4 class="code-header">pub fn <a href="#method.drain" class="fnname">drain</a>&lt;R&gt;(&amp;mut self, range: R) -&gt; <a class="struct" href="struct.Drain.html" title="struct bitvec::vec::Drain">Drain</a>&lt;'_, O, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="struct.Drain.html" title="struct bitvec::vec::Drain">Drain</a>&lt;'_, O, T&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="struct.Drain.html" title="struct bitvec::vec::Drain">Drain</a>&lt;'_, O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a>;</span></code></span></span></span></span><span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;R: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/range/trait.RangeBounds.html" title="trait core::ops::range::RangeBounds">RangeBounds</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>&gt;,</span></h4></section></summary><div class="docblock"><p>Creates a draining iterator that removes the specified range in the
bit-vector and yields the removed bits.</p>
<p>When the iterator <strong>is</strong> dropped, all bits in the range are removed from
the bit-vector, even if the iterator was not fully consumed. If the
iterator <strong>is not</strong> dropped (with <a href="https://doc.rust-lang.org/1.65.0/core/mem/fn.forget.html"><code>mem::forget</code></a> for example), it is
unspecified how many bits are removed.</p>
<h5 id="original-18"><a href="#original-18">Original</a></h5>
<p><a href="https://doc.rust-lang.org/1.65.0/alloc/vec/struct.Vec.html#method.drain"><code>Vec::drain</code></a></p>
<h5 id="panics-8"><a href="#panics-8">Panics</a></h5>
<p>Panics if the starting point is greater than the end point or if the end
point is greater than the length of the bit-vector.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv = <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="kw">let </span>bv2: BitVec = bv.drain(<span class="number">1 </span>..).collect();
<span class="macro">assert_eq!</span>(bv, <span class="macro">bits!</span>[<span class="number">0</span>]);
<span class="macro">assert_eq!</span>(bv2, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">1</span>]);

<span class="comment">// A full range clears the vector
</span>bv.drain(..);
<span class="macro">assert_eq!</span>(bv, <span class="macro">bits!</span>[]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.clear" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/api.rs.html#873-875">source</a><h4 class="code-header">pub fn <a href="#method.clear" class="fnname">clear</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Clears the bit-vector, removing all values.</p>
<p>Note that this method has no effect on the allocated capacity of the
bit-vector.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv = <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];
bv.clear();
<span class="macro">assert!</span>(bv.is_empty());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.len" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/api.rs.html#894-896">source</a><h4 class="code-header">pub fn <a href="#method.len" class="fnname">len</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the number of bits in the bit-vector, also referred to as its
‘length’.</p>
<h5 id="original-19"><a href="#original-19">Original</a></h5>
<p><a href="https://doc.rust-lang.org/1.65.0/alloc/vec/struct.Vec.html#method.len"><code>Vec::len</code></a></p>
<h5 id="examples-18"><a href="#examples-18">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bv = <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="macro">assert_eq!</span>(bv.len(), <span class="number">3</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.is_empty" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/api.rs.html#917-919">source</a><h4 class="code-header">pub fn <a href="#method.is_empty" class="fnname">is_empty</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns <code>true</code> if the bit-vector contains no bits.</p>
<h5 id="original-20"><a href="#original-20">Original</a></h5>
<p><a href="https://doc.rust-lang.org/1.65.0/alloc/vec/struct.Vec.html#method.is_empty"><code>Vec::is_empty</code></a></p>
<h5 id="examples-19"><a href="#examples-19">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv: BitVec = BitVec::new();
<span class="macro">assert!</span>(bv.is_empty());

bv.push(<span class="bool-val">true</span>);
<span class="macro">assert!</span>(!bv.is_empty());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.split_off" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/api.rs.html#947-960">source</a><h4 class="code-header">pub fn <a href="#method.split_off" class="fnname">split_off</a>(&amp;mut self, at: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Splits the collection into two at the given index.</p>
<p>Returns a newly allocated bit-vector containing the bits in range <code>[at, len)</code>. After the call, the original bit-vector will be left containing
the bits <code>[0, at)</code> with its previous capacity unchanged.</p>
<h5 id="original-21"><a href="#original-21">Original</a></h5>
<p><a href="https://doc.rust-lang.org/1.65.0/alloc/vec/struct.Vec.html#method.split_off"><code>Vec::split_off</code></a></p>
<h5 id="panics-9"><a href="#panics-9">Panics</a></h5>
<p>Panics if <code>at &gt; len</code>.</p>
<h5 id="examples-20"><a href="#examples-20">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv = <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let </span>bv2 = bv.split_off(<span class="number">1</span>);
<span class="macro">assert_eq!</span>(bv, <span class="macro">bits!</span>[<span class="number">0</span>]);
<span class="macro">assert_eq!</span>(bv2, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.resize_with" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/api.rs.html#1000-1009">source</a><h4 class="code-header">pub fn <a href="#method.resize_with" class="fnname">resize_with</a>&lt;F&gt;(&amp;mut self, new_len: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>, func: F)<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>() -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a>,</span></h4></section></summary><div class="docblock"><p>Resizes the <code>BitVec</code> in-place so that <code>len</code> is equal to <code>new_len</code>.</p>
<p>If <code>new_len</code> is greater than <code>len</code>, the <code>BitVec</code> is extended by the
difference, with each additional slot filled with the result of calling
the closure <code>func</code>. The return values from <code>func</code> will end up in the
<code>BitVec</code> in the order they have been generated.</p>
<p>If <code>new_len</code> is less than <code>len</code>, the <code>BitVec</code> is simply truncated.</p>
<p>This method uses a closure to create new values on every push. If you’d
rather <a href="https://doc.rust-lang.org/1.65.0/core/clone/trait.Clone.html"><code>Clone</code></a> a given value, use <a href="struct.BitVec.html#method.resize"><code>resize</code></a>. If you want to use the
<a href="https://doc.rust-lang.org/1.65.0/core/default/trait.Default.html"><code>Default</code></a> trait to generate values, you can pass
<a href="https://doc.rust-lang.org/1.65.0/core/default/trait.Default.html#tymethod.default"><code>Default::default()</code></a> as the second argument.</p>
<h5 id="original-22"><a href="#original-22">Original</a></h5>
<p><a href="https://doc.rust-lang.org/1.65.0/alloc/vec/struct.Vec.html#method.resize_with"><code>Vec::resize_with</code></a></p>
<h5 id="examples-21"><a href="#examples-21">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv = <span class="macro">bitvec!</span>[<span class="number">1</span>; <span class="number">3</span>];
bv.resize_with(<span class="number">5</span>, Default::default);
<span class="macro">assert_eq!</span>(bv, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]);

<span class="kw">let </span><span class="kw-2">mut </span>bv = <span class="macro">bitvec!</span>[];
<span class="kw">let </span><span class="kw-2">mut </span>p = <span class="number">0</span>;
bv.resize_with(<span class="number">4</span>, || { p += <span class="number">1</span>; p % <span class="number">2 </span>== <span class="number">0 </span>});
<span class="macro">assert_eq!</span>(bv, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.leak" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/api.rs.html#1041-1043">source</a><h4 class="code-header">pub fn <a href="#method.leak" class="fnname">leak</a>&lt;'a&gt;(self) -&gt; &amp;'a mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for &amp;'a <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/std/io/trait.Read.html" title="trait std::io::Read">Read</a> for &amp;'a <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,</span></span><span class="where fmt-newline">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/std/io/trait.Write.html" title="trait std::io::Write">Write</a> for &amp;'a mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,</span></span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Consumes and leaks the <code>BitVec</code>, returning a mutable reference to the
contents, <code>&amp;'a mut BitSlice&lt;O, T&gt;</code>. This lifetime may be chosen to be
<code>'static</code>.</p>
<p>This function is similar to the <a href="../boxed/struct.BitBox.html#method.leak"><code>leak</code></a> function on <a href="../boxed/struct.BitBox.html"><code>BitBox</code></a>.</p>
<p>This function is mainly useful for data that lives for the remainder of
the program’s life. Dropping the returned reference will cause a memory
leak.</p>
<h5 id="original-23"><a href="#original-23">Original</a></h5>
<p><a href="https://doc.rust-lang.org/1.65.0/alloc/vec/struct.Vec.html#method.leak"><code>Vec::leak</code></a></p>
<h5 id="examples-22"><a href="#examples-22">Examples</a></h5>
<p>Simple usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>x = <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let </span>static_ref: <span class="kw-2">&amp;</span><span class="lifetime">&#39;static </span><span class="kw-2">mut </span>BitSlice = x.leak();
static_ref.set(<span class="number">0</span>, <span class="bool-val">true</span>);
<span class="macro">assert_eq!</span>(static_ref, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.resize" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/api.rs.html#1074-1082">source</a><h4 class="code-header">pub fn <a href="#method.resize" class="fnname">resize</a>(&amp;mut self, new_len: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>, value: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a>)</h4></section></summary><div class="docblock"><p>Resizes the <code>BitVec</code> in-place so that <code>len</code> is equal to <code>new_len</code>.</p>
<p>If <code>new_len</code> is greater than <code>len</code>, the <code>BitVec</code> is extended by the
difference, with each additional slot filled with <code>value</code>. If <code>new_len</code>
is less than <code>len</code>, the <code>BitVec</code> is simply truncated.</p>
<p>This method requires a single <code>bool</code> value. If you need more
flexibility, use <a href="struct.BitVec.html#method.resize_with"><code>resize_with</code></a>.</p>
<h5 id="original-24"><a href="#original-24">Original</a></h5>
<p><a href="https://doc.rust-lang.org/1.65.0/alloc/vec/struct.Vec.html#method.resize"><code>Vec::resize</code></a></p>
<h5 id="examples-23"><a href="#examples-23">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv = <span class="macro">bitvec!</span>[<span class="number">1</span>];
bv.resize(<span class="number">3</span>, <span class="bool-val">false</span>);
<span class="macro">assert_eq!</span>(bv, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]);

<span class="kw">let </span><span class="kw-2">mut </span>bv = <span class="macro">bitvec!</span>[<span class="number">1</span>; <span class="number">4</span>];
bv.resize(<span class="number">2</span>, <span class="bool-val">false</span>);
<span class="macro">assert_eq!</span>(bv, <span class="macro">bits!</span>[<span class="number">1</span>; <span class="number">2</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.resize_default" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/api.rs.html#1100-1108">source</a><h4 class="code-header">pub fn <a href="#method.resize_default" class="fnname">resize_default</a>(&amp;mut self, new_len: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>)</h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated: <p><code>Vec::resize_default</code> is deprecated</p>
</span></div></span></summary><div class="docblock"><p>Resizes the <code>BitVec</code> in-place so that <code>len</code> is equal to <code>new_len</code>.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.splice" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/api.rs.html#1156-1166">source</a><h4 class="code-header">pub fn <a href="#method.splice" class="fnname">splice</a>&lt;R, I&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self,<br>&nbsp;&nbsp;&nbsp;&nbsp;range: R,<br>&nbsp;&nbsp;&nbsp;&nbsp;replace_with: I<br>) -&gt; <a class="struct" href="struct.Splice.html" title="struct bitvec::vec::Splice">Splice</a>&lt;'_, O, T, I::<a class="associatedtype" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" title="type core::iter::traits::collect::IntoIterator::IntoIter">IntoIter</a>&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="struct.Splice.html" title="struct bitvec::vec::Splice">Splice</a>&lt;'_, O, T, I&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;O, T, I&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="struct.Splice.html" title="struct bitvec::vec::Splice">Splice</a>&lt;'_, O, T, I&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&lt;Item = <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a>&gt;,</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a>;</span></code></span></span></span></span><span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;R: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/range/trait.RangeBounds.html" title="trait core::ops::range::RangeBounds">RangeBounds</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a>&gt;,</span></h4></section></summary><div class="docblock"><p>Creates a splicing iterator that replaces the specified range in the
bit-vector with the given <code>replace_with</code> iterator and yields the removed
items. <code>replace_with</code> does not need to be the same length as <code>range</code>.</p>
<p><code>range</code> is removed even if the iterator is not consumed until the end.</p>
<p>It is unspecified how many bits are removed from the vector if the
<a href="struct.Splice.html"><code>Splice</code></a> value is leaked.</p>
<p>The input iterator <code>replace_with</code> is only consumed when the <a href="struct.Splice.html"><code>Splice</code></a>
value is dropped.</p>
<p>This is optimal if:</p>
<ul>
<li>the tail (bits in the vector after <code>range</code>) is empty</li>
<li>or <code>replace_with</code> yields fewer bits than <code>range</code>’s length</li>
<li>or the lower bound of its <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html#method.size_hint"><code>size_hint</code></a> is exact.</li>
</ul>
<p>Otherwise, a temporary bit-vector is allocated and the tail is moved
twice.</p>
<h5 id="original-25"><a href="#original-25">Original</a></h5>
<p><a href="https://doc.rust-lang.org/1.65.0/alloc/vec/struct.Vec.html#method.splice"><code>Vec::splice</code></a></p>
<h5 id="panics-10"><a href="#panics-10">Panics</a></h5>
<p>Panics if the starting point is greater than the end point or if the end
point is greater than the length of the bit-vector.</p>
<h5 id="examples-24"><a href="#examples-24">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv = <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="kw">let </span>new = <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>];
<span class="kw">let </span>old: BitVec = bv.splice(.. <span class="number">2</span>, new.iter().by_val()).collect();
<span class="macro">assert_eq!</span>(bv, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]);
<span class="macro">assert_eq!</span>(old, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>]);</code></pre></div>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BitVec%3CO%2C%20T%3E-1" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec.rs.html#275-1120">source</a><a href="#impl-BitVec%3CO%2C%20T%3E-1" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section></summary><div class="docblock"><p>General-purpose functions not present on <code>Vec&lt;T&gt;</code>.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.repeat" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec.rs.html#305-312">source</a><h4 class="code-header">pub fn <a href="#method.repeat" class="fnname">repeat</a>(bit: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a>, len: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Constructs a <code>BitVec</code> from a value repeated many times.</p>
<p>This function is equivalent to the <code>bitvec![O, T; bit; len]</code> <a href="../macro.bitvec.html">macro</a>
call, and is in fact the implementation of that macro syntax.</p>
<h5 id="parameters"><a href="#parameters">Parameters</a></h5>
<ul>
<li><code>bit</code>: The bit value to which all <code>len</code> allocated bits will be set.</li>
<li><code>len</code>: The number of live bits in the constructed <code>BitVec</code>.</li>
</ul>
<h5 id="returns"><a href="#returns">Returns</a></h5>
<p>A <code>BitVec</code> with <code>len</code> live bits, all set to <code>bit</code>.</p>
<h5 id="examples-25"><a href="#examples-25">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bv = BitVec::&lt;Msb0, u8&gt;::repeat(<span class="bool-val">true</span>, <span class="number">20</span>);
<span class="macro">assert_eq!</span>(bv, <span class="macro">bits!</span>[<span class="number">1</span>; <span class="number">20</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from_bitslice" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec.rs.html#338-377">source</a><h4 class="code-header">pub fn <a href="#method.from_bitslice" class="fnname">from_bitslice</a>(slice: &amp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;) -&gt; Self</h4></section></summary><div class="docblock"><p>Copies the contents of a <a href="../slice/struct.BitSlice.html"><code>BitSlice</code></a> into a new allocation.</p>
<p>This is an exact copy: the newly-created bit-vector is initialized with
a direct copy of the <code>slice</code>’s underlying contents, and its handle is
set to use <code>slice</code>’s head index. Slices that do not begin at the zeroth
bit of the base element will thus create misaligned vectors.</p>
<p>You can move the bit-vector contents down to begin at the zero index of
the bit-vector’s buffer with <a href="struct.BitVec.html#method.force_align"><code>force_align</code></a>.</p>
<h5 id="examples-26"><a href="#examples-26">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="kw">let </span>bv = BitVec::from_bitslice(<span class="kw-2">&amp;</span>bits[<span class="number">2 </span>..]);
<span class="macro">assert_eq!</span>(bv, bits[<span class="number">2 </span>..]);
<span class="macro">assert_eq!</span>(bits.as_raw_slice(), bv.as_raw_slice());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from_element" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec.rs.html#392-394">source</a><h4 class="code-header">pub fn <a href="#method.from_element" class="fnname">from_element</a>(elem: T) -&gt; Self</h4></section></summary><div class="docblock"><p>Constructs a new <code>BitVec</code> from the bit-pattern of a single element.</p>
<p>This function copies <code>elem</code> into a new vector, then views that vector as
bits.</p>
<h5 id="examples-27"><a href="#examples-27">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="macro">assert_eq!</span>(BitVec::&lt;Msb0, <span class="kw">_</span>&gt;::from_element(<span class="number">0xABBAu16</span>).count_ones(), <span class="number">10</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from_slice" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec.rs.html#425-427">source</a><h4 class="code-header">pub fn <a href="#method.from_slice" class="fnname">from_slice</a>(slice: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.slice.html">[T]</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.65.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;Self, <a class="enum" href="../ptr/enum.BitSpanError.html" title="enum bitvec::ptr::BitSpanError">BitSpanError</a>&lt;T&gt;&gt;</h4></section></summary><div class="docblock"><p>Constructs a new <code>BitVec</code> from the bit-pattern of an element slice.</p>
<p>This function copies <code>slice</code> into a new vector, then views that vector
as bits.</p>
<h5 id="parameters-1"><a href="#parameters-1">Parameters</a></h5>
<ul>
<li><code>slice</code>: A slice of elements. It should not exceed <a href="../slice/struct.BitSlice.html#associatedconstant.MAX_ELTS"><code>BitSlice::&lt;O, T&gt;::MAX_ELTS</code></a>.</li>
</ul>
<h5 id="returns-1"><a href="#returns-1">Returns</a></h5>
<p>This returns an error if <a href="../slice/struct.BitSlice.html#method.from_slice"><code>BitSlice::&lt;O, T&gt;::from_slice</code></a> fails;
otherwise, it returns the newly allocated and initialized bit-vector.</p>
<h5 id="examples-28"><a href="#examples-28">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>slice = <span class="kw-2">&amp;</span>[<span class="number">0u8</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="kw">let </span>bv = BitVec::&lt;Lsb0, <span class="kw">_</span>&gt;::from_slice(slice);
<span class="macro">assert!</span>(bv.is_ok());
<span class="macro">assert_eq!</span>(bv.unwrap().len(), <span class="number">32</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from_vec" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec.rs.html#457-460">source</a><h4 class="code-header">pub fn <a href="#method.from_vec" class="fnname">from_vec</a>(vec: <a class="struct" href="https://doc.rust-lang.org/1.65.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T&gt;) -&gt; Self</h4></section></summary><div class="docblock"><p>Converts a <a href="https://doc.rust-lang.org/1.65.0/alloc/vec/struct.Vec.html"><code>Vec&lt;T&gt;</code></a> into a <code>BitVec&lt;O, T&gt;</code> without copying its buffer.</p>
<h5 id="parameters-2"><a href="#parameters-2">Parameters</a></h5>
<ul>
<li><code>vec</code>: A vector to view as bits.</li>
</ul>
<h5 id="returns-2"><a href="#returns-2">Returns</a></h5>
<p>A <code>BitVec</code> over the <code>vec</code> buffer.</p>
<h5 id="panics-11"><a href="#panics-11">Panics</a></h5>
<p>This panics if <code>vec</code> is too long to convert into a <code>BitVec</code>. See
<a href="../slice/struct.BitSlice.html#associatedconstant.MAX_ELTS"><code>BitSlice::MAX_ELTS</code></a>.</p>
<h5 id="examples-29"><a href="#examples-29">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>vec = <span class="macro">vec!</span>[<span class="number">0u8</span>; <span class="number">4</span>];
<span class="kw">let </span>bv = BitVec::&lt;LocalBits, <span class="kw">_</span>&gt;::from_vec(vec);
<span class="macro">assert_eq!</span>(bv, <span class="macro">bits!</span>[<span class="number">0</span>; <span class="number">32</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.try_from_vec" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec.rs.html#495-503">source</a><h4 class="code-header">pub fn <a href="#method.try_from_vec" class="fnname">try_from_vec</a>(vec: <a class="struct" href="https://doc.rust-lang.org/1.65.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.65.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;Self, <a class="struct" href="https://doc.rust-lang.org/1.65.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T&gt;&gt;</h4></section></summary><div class="docblock"><p>Converts a <a href="https://doc.rust-lang.org/1.65.0/alloc/vec/struct.Vec.html"><code>Vec&lt;T&gt;</code></a> into a <code>BitVec&lt;O, T&gt;</code> without copying its buffer.</p>
<p>This method takes ownership of a memory buffer and enables it to be used
as a bit-vector. Because <a href="https://doc.rust-lang.org/1.65.0/alloc/vec/struct.Vec.html"><code>Vec</code></a> can be longer than <code>BitVec</code>s, this is a
fallible method, and the original vector will be returned if it cannot
be converted.</p>
<h5 id="parameters-3"><a href="#parameters-3">Parameters</a></h5>
<ul>
<li><code>vec</code>: Some vector of memory, to be viewed as bits.</li>
</ul>
<h5 id="returns-3"><a href="#returns-3">Returns</a></h5>
<p>If <code>vec</code> is short enough to be viewed as a <code>BitVec</code>, then this returns
a <code>BitVec</code> over the <code>vec</code> buffer. If <code>vec</code> is too long, then this
returns <code>vec</code> unmodified.</p>
<h5 id="examples-30"><a href="#examples-30">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>vec = <span class="macro">vec!</span>[<span class="number">0u8</span>; <span class="number">4</span>];
<span class="kw">let </span>bv = BitVec::&lt;LocalBits, <span class="kw">_</span>&gt;::try_from_vec(vec).unwrap();
<span class="macro">assert_eq!</span>(bv, <span class="macro">bits!</span>[<span class="number">0</span>; <span class="number">32</span>]);</code></pre></div>
<p>An example showing this function failing would require an allocation
exceeding <code>!0usize &gt;&gt; 3</code> bytes in size, which is infeasible to produce.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.extend_from_bitslice" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec.rs.html#537-546">source</a><h4 class="code-header">pub fn <a href="#method.extend_from_bitslice" class="fnname">extend_from_bitslice</a>&lt;O2, T2&gt;(&amp;mut self, other: &amp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O2, T2&gt;)<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h4></section></summary><div class="docblock"><p>Copies all bits in a <a href="../slice/struct.BitSlice.html"><code>BitSlice</code></a> into the <code>BitVec</code>.</p>
<h5 id="original-26"><a href="#original-26">Original</a></h5>
<p><a href="https://doc.rust-lang.org/1.65.0/alloc/vec/struct.Vec.html#method.extend_from_slice"><code>Vec::extend_from_slice</code></a></p>
<h5 id="type-parameters"><a href="#type-parameters">Type Parameters</a></h5>
<p>This can extend from a <a href="../slice/struct.BitSlice.html"><code>BitSlice</code></a> of any type arguments. Where the
source <code>&amp;BitSlice</code> matches <code>self</code>’s type parameters, the implementation
is able to attempt to accelerate the copy; however, if the type
parameters do not match, then the implementation falls back to a
bit-by-bit iteration and is equivalent to the <code>Extend</code> implementation.</p>
<p>You should only use this method when the type parameters match and there
is a possibility of copy acceleration. Otherwise, <code>.extend()</code> is the
correct API.</p>
<h5 id="examples-31"><a href="#examples-31">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv = <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">1</span>];
bv.extend_from_bitslice(<span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]);

<span class="macro">assert_eq!</span>(bv, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.extend_from_raw_slice" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec.rs.html#557-562">source</a><h4 class="code-header">pub fn <a href="#method.extend_from_raw_slice" class="fnname">extend_from_raw_slice</a>(&amp;mut self, slice: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.slice.html">[T]</a>)</h4></section></summary><div class="docblock"><p>Appends a slice of elements <code>T</code> to the <code>BitVec</code>.</p>
<p>The <code>slice</code> is interpreted as a <code>BitSlice&lt;O, T&gt;</code>, then appended directly
to the bit-vector.</p>
<h5 id="original-27"><a href="#original-27">Original</a></h5>
<p><a href="https://doc.rust-lang.org/1.65.0/alloc/vec/struct.Vec.html#method.extend_from_slice"><code>Vec::extend_from_slice</code></a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.elements" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec.rs.html#576-578">source</a><h4 class="code-header">pub fn <a href="#method.elements" class="fnname">elements</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Gets the number of elements <code>T</code> that contain live bits of the
bit-vector.</p>
<h5 id="examples-32"><a href="#examples-32">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bv = <span class="macro">bitvec!</span>[LocalBits, u16; <span class="number">1</span>; <span class="number">50</span>];
<span class="macro">assert_eq!</span>(bv.elements(), <span class="number">4</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.into_boxed_bitslice" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec.rs.html#618-626">source</a><h4 class="code-header">pub fn <a href="#method.into_boxed_bitslice" class="fnname">into_boxed_bitslice</a>(self) -&gt; <a class="struct" href="../boxed/struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;O, T&gt;</h4></section></summary><div class="docblock"><p>Converts the bit-vector into <a href="../boxed/struct.BitBox.html"><code>BitBox&lt;O, T&gt;</code></a>.</p>
<p>Note that this will drop any excess capacity.</p>
<h5 id="original-28"><a href="#original-28">Original</a></h5>
<p><a href="https://doc.rust-lang.org/1.65.0/alloc/vec/struct.Vec.html#method.into_boxed_slice"><code>Vec::into_boxed_slice</code></a></p>
<h5 id="api-differences-5"><a href="#api-differences-5">API Differences</a></h5>
<p>This returns a <code>bitvec</code> boxed bit-slice, not a standard boxed slice. To
convert the underlying buffer into a boxed element slice, use
<code>.into_boxed_bitslice().into_boxed_slice()</code>.</p>
<h5 id="examples-33"><a href="#examples-33">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bv = <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let </span>bitslice = bv.into_boxed_slice();</code></pre></div>
<p>Any excess capacity is removed:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv: BitVec = BitVec::with_capacity(<span class="number">100</span>);
bv.extend([<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>].iter().copied());

<span class="macro">assert!</span>(bv.capacity() &gt;= <span class="number">100</span>);
<span class="kw">let </span>bs = bv.into_boxed_bitslice();
<span class="macro">assert!</span>(bs.into_bitvec().capacity() &gt;= <span class="number">5</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.into_vec" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec.rs.html#642-652">source</a><h4 class="code-header">pub fn <a href="#method.into_vec" class="fnname">into_vec</a>(self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.65.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T&gt;</h4></section></summary><div class="docblock"><p>Removes the bit-precision view, returning the underlying <a href="https://doc.rust-lang.org/1.65.0/alloc/vec/struct.Vec.html"><code>Vec</code></a>.</p>
<h5 id="examples-34"><a href="#examples-34">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bv = <span class="macro">bitvec!</span>[Lsb0, u8; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let </span>vec = bv.into_vec();
<span class="macro">assert_eq!</span>(vec, <span class="kw-2">&amp;</span>[<span class="number">18</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.set_elements" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec.rs.html#680-684">source</a><h4 class="code-header">pub fn <a href="#method.set_elements" class="fnname">set_elements</a>(&amp;mut self, element: T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Mem" title="type bitvec::store::BitStore::Mem">Mem</a>)</h4></section></summary><div class="docblock"><p>Writes a value into every element that the bit-vector considers live.</p>
<p>This unconditionally writes <code>element</code> into each live location in the
backing buffer, without altering the <code>BitVec</code>’s length or capacity.</p>
<p>It is unspecified what effects this has on the allocated but dead
elements in the buffer. You may not rely on them being zeroed <em>or</em> being
set to the <code>value</code> integer.</p>
<h5 id="parameters-4"><a href="#parameters-4">Parameters</a></h5>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>element</code>: The value which will be written to each live location in
the bit-vector’s buffer.</li>
</ul>
<h5 id="examples-35"><a href="#examples-35">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv = <span class="macro">bitvec!</span>[LocalBits, u8; <span class="number">0</span>; <span class="number">10</span>];
<span class="macro">assert_eq!</span>(bv.as_raw_slice(), [<span class="number">0</span>, <span class="number">0</span>]);
bv.set_elements(<span class="number">0xA5</span>);
<span class="macro">assert_eq!</span>(bv.as_raw_slice(), [<span class="number">0xA5</span>, <span class="number">0xA5</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.set_uninitialized" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec.rs.html#714-726">source</a><h4 class="code-header">pub fn <a href="#method.set_uninitialized" class="fnname">set_uninitialized</a>(&amp;mut self, value: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a>)</h4></section></summary><div class="docblock"><p>Sets the uninitialized bits of the bit-vector to a fixed value.</p>
<p>This method modifies all bits in the allocated buffer that are outside
the <a href="struct.BitVec.html#method.as_bitslice"><code>as_bitslice</code></a> view so that they have a consistent value. This can
be used to zero the uninitialized memory so that when viewed as a raw
memory slice, bits outside the live region have a predictable value.</p>
<h5 id="examples-36"><a href="#examples-36">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv = <span class="number">220u8</span>.view_bits::&lt;Lsb0&gt;().to_bitvec();
<span class="macro">assert_eq!</span>(bv.as_raw_slice(), <span class="kw-2">&amp;</span>[<span class="number">220u8</span>]);

bv.truncate(<span class="number">4</span>);
<span class="macro">assert_eq!</span>(bv.count_ones(), <span class="number">2</span>);
<span class="macro">assert_eq!</span>(bv.as_raw_slice(), <span class="kw-2">&amp;</span>[<span class="number">220u8</span>]);

bv.set_uninitialized(<span class="bool-val">false</span>);
<span class="macro">assert_eq!</span>(bv.as_raw_slice(), <span class="kw-2">&amp;</span>[<span class="number">12u8</span>]);

bv.set_uninitialized(<span class="bool-val">true</span>);
<span class="macro">assert_eq!</span>(bv.as_raw_slice(), <span class="kw-2">&amp;</span>[!<span class="number">3u8</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.force_align" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec.rs.html#750-761">source</a><h4 class="code-header">pub fn <a href="#method.force_align" class="fnname">force_align</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Ensures that the live region of the bit-vector’s contents begins at the
leading edge of the buffer.</p>
<h5 id="examples-37"><a href="#examples-37">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>data = <span class="number">0x3Cu8</span>;
<span class="kw">let </span>bits = data.view_bits::&lt;Msb0&gt;();

<span class="kw">let </span><span class="kw-2">mut </span>bv = bits[<span class="number">2 </span>.. <span class="number">6</span>].to_bitvec();
<span class="macro">assert_eq!</span>(bv, bits[<span class="number">2 </span>.. <span class="number">6</span>]);
<span class="macro">assert_eq!</span>(bv.as_raw_slice()[<span class="number">0</span>], data);

bv.force_align();
<span class="macro">assert_eq!</span>(bv, bits[<span class="number">2 </span>.. <span class="number">6</span>]);
<span class="comment">// It is not specified what happens
// to bits that are no longer used.
</span><span class="macro">assert_eq!</span>(bv.as_raw_slice()[<span class="number">0</span>] &amp; <span class="number">0xF0</span>, <span class="number">0xF0</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_bitslice" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec.rs.html#797-799">source</a><h4 class="code-header">pub fn <a href="#method.as_bitslice" class="fnname">as_bitslice</a>(&amp;self) -&gt; &amp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for &amp;'a <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/std/io/trait.Read.html" title="trait std::io::Read">Read</a> for &amp;'a <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,</span></span><span class="where fmt-newline">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/std/io/trait.Write.html" title="trait std::io::Write">Write</a> for &amp;'a mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,</span></span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Extracts a bit-slice containing the entire bit-vector.</p>
<p>Equivalent to <code>&amp;bv[..]</code>.</p>
<h5 id="original-29"><a href="#original-29">Original</a></h5>
<p><a href="https://doc.rust-lang.org/1.65.0/alloc/vec/struct.Vec.html#method.as_slice"><code>Vec::as_slice</code></a></p>
<h5 id="api-differences-6"><a href="#api-differences-6">API Differences</a></h5>
<p>This returns a <code>bitvec</code> bit-slice, not a standard slice. To view the
underlying element buffer, use <a href="struct.BitVec.html#method.as_raw_slice"><code>as_raw_slice</code></a>.</p>
<h5 id="examples-38"><a href="#examples-38">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bv = <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let </span>bits = bv.as_bitslice();</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_mut_bitslice" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec.rs.html#825-827">source</a><h4 class="code-header">pub fn <a href="#method.as_mut_bitslice" class="fnname">as_mut_bitslice</a>(&amp;mut self) -&gt; &amp;mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for &amp;'a <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/std/io/trait.Read.html" title="trait std::io::Read">Read</a> for &amp;'a <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,</span></span><span class="where fmt-newline">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/std/io/trait.Write.html" title="trait std::io::Write">Write</a> for &amp;'a mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,</span></span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Extracts a mutable bit-slice of the entire bit-vector.</p>
<p>Equivalent to <code>&amp;mut bv[..]</code>.</p>
<h5 id="original-30"><a href="#original-30">Original</a></h5>
<p><a href="https://doc.rust-lang.org/1.65.0/alloc/vec/struct.Vec.html#method.as_mut_slice"><code>Vec::as_mut_slice</code></a></p>
<h5 id="api-differences-7"><a href="#api-differences-7">API Differences</a></h5>
<p>This returns a <code>bitvec</code> bit-slice, not a standard slice. To view the
underlying element buffer, use <a href="struct.BitVec.html#method.as_mut_raw_slice"><code>as_mut_raw_slice</code></a>.</p>
<h5 id="examples-39"><a href="#examples-39">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv = <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let </span>bits = bv.as_mut_bitslice();</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_bitptr" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec.rs.html#870-872">source</a><h4 class="code-header">pub fn <a href="#method.as_bitptr" class="fnname">as_bitptr</a>(&amp;self) -&gt; <a class="struct" href="../prelude/struct.BitPtr.html" title="struct bitvec::prelude::BitPtr">BitPtr</a>&lt;<a class="struct" href="../ptr/struct.Const.html" title="struct bitvec::ptr::Const">Const</a>, O, T&gt;</h4></section></summary><div class="docblock"><p>Returns a raw pointer to the bit-vector’s buffer.</p>
<p>The caller must ensure that the bit-vector outlives the bit-pointer this
function returns, or else it will end up pointing to garbage. Modifying
the bit-vector may cause its buffer to be reällocated, which would also
make any bit-pointers to it invalid.</p>
<p>The caller must also ensure that the memory the bit-pointer
(non-transitively) points to is never written to (except inside an
<a href="https://doc.rust-lang.org/1.65.0/core/cell/struct.UnsafeCell.html"><code>UnsafeCell</code></a>) using this bit-pointer or any bit-pointer derived from
it. If you need to mutate the contents of the buffer, use
<a href="struct.BitVec.html#method.as_mut_bitptr"><code>as_mut_bitptr</code></a>.</p>
<h5 id="original-31"><a href="#original-31">Original</a></h5>
<p><a href="https://doc.rust-lang.org/1.65.0/alloc/vec/struct.Vec.html#method.as_ptr"><code>Vec::as_ptr</code></a></p>
<h5 id="api-differences-8"><a href="#api-differences-8">API Differences</a></h5>
<p>This returns a <code>bitvec</code> bit-pointer, not a standard pointer. To take the
address of the underlying element buffer, use <a href="struct.BitVec.html#method.as_raw_ptr"><code>as_raw_ptr</code></a>.</p>
<h5 id="examples-40"><a href="#examples-40">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bv = <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let </span>bp = bv.as_bitptr();

<span class="kw">unsafe </span>{
  <span class="kw">for </span>i <span class="kw">in </span><span class="number">0 </span>.. bv.len() {
    <span class="macro">assert_eq!</span>(bp.add(i).read(), bv[i]);
  }
}</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_mut_bitptr" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec.rs.html#908-910">source</a><h4 class="code-header">pub fn <a href="#method.as_mut_bitptr" class="fnname">as_mut_bitptr</a>(&amp;mut self) -&gt; <a class="struct" href="../prelude/struct.BitPtr.html" title="struct bitvec::prelude::BitPtr">BitPtr</a>&lt;<a class="struct" href="../ptr/struct.Mut.html" title="struct bitvec::ptr::Mut">Mut</a>, O, T&gt;</h4></section></summary><div class="docblock"><p>Returns an unsafe mutable bit-pointer to the bit-vector’s region.</p>
<p>The caller must ensure that the bit-vector outlives the bit-pointer this
function returns, or else it will end up pointing to garbage. Modifying
the bit-vector may cause its buffer to be reällocated, which would also
make any bit-pointers to it invalid.</p>
<h5 id="original-32"><a href="#original-32">Original</a></h5>
<p><a href="https://doc.rust-lang.org/1.65.0/alloc/vec/struct.Vec.html#method.as_mut_ptr"><code>Vec::as_mut_ptr</code></a></p>
<h5 id="api-differences-9"><a href="#api-differences-9">API Differences</a></h5>
<p>This returns a <code>bitvec</code> bit-pointer, not a standard pointer. To take the
address of the underlying element buffer, use <a href="struct.BitVec.html#method.as_mut_raw_ptr"><code>as_mut_raw_ptr</code></a>.</p>
<h5 id="examples-41"><a href="#examples-41">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv = BitVec::&lt;Msb0, u8&gt;::with_capacity(<span class="number">4</span>);
<span class="kw">let </span>bp = bv.as_mut_bitptr();
<span class="kw">unsafe </span>{
  <span class="kw">for </span>i <span class="kw">in </span><span class="number">0 </span>.. <span class="number">4 </span>{
    bp.add(i).write(<span class="bool-val">true</span>);
  }
  bv.set_len(<span class="number">4</span>);
}
<span class="macro">assert_eq!</span>(bv, <span class="macro">bits!</span>[<span class="number">1</span>; <span class="number">4</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_raw_slice" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec.rs.html#934-941">source</a><h4 class="code-header">pub fn <a href="#method.as_raw_slice" class="fnname">as_raw_slice</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.slice.html">[T]</a><span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for &amp;mut [<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.u8.html">u8</a>]</span><code class="content"><span class="where fmt-newline">impl <a class="trait" href="https://doc.rust-lang.org/1.65.0/std/io/trait.Write.html" title="trait std::io::Write">Write</a> for &amp;mut [<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.u8.html">u8</a>]</span><span class="where fmt-newline">impl <a class="trait" href="https://doc.rust-lang.org/1.65.0/std/io/trait.Read.html" title="trait std::io::Read">Read</a> for &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.u8.html">u8</a>]</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Views the underlying buffer as a shared element slice.</p>
<h5 id="original-33"><a href="#original-33">Original</a></h5>
<p><a href="https://doc.rust-lang.org/1.65.0/alloc/vec/struct.Vec.html#method.as_slice"><code>Vec::as_slice</code></a></p>
<h5 id="api-differences-10"><a href="#api-differences-10">API Differences</a></h5>
<p>This method is renamed in order to emphasize the semantic distinction
between borrowing the bit-vector contents, and borrowing the memory that
implements the collection contents.</p>
<h5 id="examples-42"><a href="#examples-42">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bv = <span class="macro">bitvec!</span>[Msb0, u8; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let </span>raw = bv.as_raw_slice();
<span class="macro">assert_eq!</span>(raw, <span class="kw-2">&amp;</span>[<span class="number">0x4D</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_mut_raw_slice" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec.rs.html#967-974">source</a><h4 class="code-header">pub fn <a href="#method.as_mut_raw_slice" class="fnname">as_mut_raw_slice</a>(&amp;mut self) -&gt; &amp;mut <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.slice.html">[T]</a><span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for &amp;mut [<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.u8.html">u8</a>]</span><code class="content"><span class="where fmt-newline">impl <a class="trait" href="https://doc.rust-lang.org/1.65.0/std/io/trait.Write.html" title="trait std::io::Write">Write</a> for &amp;mut [<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.u8.html">u8</a>]</span><span class="where fmt-newline">impl <a class="trait" href="https://doc.rust-lang.org/1.65.0/std/io/trait.Read.html" title="trait std::io::Read">Read</a> for &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.u8.html">u8</a>]</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Views the underlying buffer as an exclusive element slice.</p>
<h5 id="original-34"><a href="#original-34">Original</a></h5>
<p><a href="https://doc.rust-lang.org/1.65.0/alloc/vec/struct.Vec.html#method.as_mut_slice"><code>Vec::as_mut_slice</code></a></p>
<h5 id="api-differences-11"><a href="#api-differences-11">API Differences</a></h5>
<p>This method is renamed in order to emphasize the semantic distinction
between borrowing the bit-vector contents, and borrowing the memory that
implements the collection contents.</p>
<h5 id="examples-43"><a href="#examples-43">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv = <span class="macro">bitvec!</span>[Msb0, u8; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let </span>raw = bv.as_mut_raw_slice();
<span class="macro">assert_eq!</span>(raw, <span class="kw-2">&amp;</span>[<span class="number">0x4D</span>]);
raw[<span class="number">0</span>] = <span class="number">0xD4</span>;
<span class="macro">assert_eq!</span>(bv, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_raw_ptr" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec.rs.html#998-1000">source</a><h4 class="code-header">pub fn <a href="#method.as_raw_ptr" class="fnname">as_raw_ptr</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.pointer.html">*const T</a></h4></section></summary><div class="docblock"><p>Returns a raw pointer to the bit-vector’s buffer.</p>
<h5 id="original-35"><a href="#original-35">Original</a></h5>
<p><a href="https://doc.rust-lang.org/1.65.0/alloc/vec/struct.Vec.html#method.as_ptr"><code>Vec::as_ptr</code></a></p>
<h5 id="api-differences-12"><a href="#api-differences-12">API Differences</a></h5>
<p>This method is renamed in order to emphasize the semantic distinction
between taking a pointer to the start of the bit-vector contents, and
taking a pointer to the underlying memory that implements the collection
contents.</p>
<h5 id="examples-44"><a href="#examples-44">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bv = <span class="macro">bitvec!</span>[Msb0, u8; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let </span>addr = bv.as_raw_ptr();</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_mut_raw_ptr" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec.rs.html#1024-1026">source</a><h4 class="code-header">pub fn <a href="#method.as_mut_raw_ptr" class="fnname">as_mut_raw_ptr</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.pointer.html">*mut T</a></h4></section></summary><div class="docblock"><p>Returns an unsafe mutable pointer to the bit-vector’s buffer.</p>
<h5 id="original-36"><a href="#original-36">Original</a></h5>
<p><a href="https://doc.rust-lang.org/1.65.0/alloc/vec/struct.Vec.html#method.as_mut_ptr"><code>Vec::as_mut_ptr</code></a></p>
<h5 id="api-differences-13"><a href="#api-differences-13">API Differences</a></h5>
<p>This method is renamed in order to emphasize the semantic distinction
between taking a pointer to the start of the bit-vector contents, and
taking a pointer to the underlying memory that implements the collection
contents.</p>
<h5 id="examples-45"><a href="#examples-45">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>bv = <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let </span>addr = bv.as_mut_raw_ptr();</code></pre></div>
</div></details></div></details></div><h2 id="deref-methods-BitSlice%3CO%2C%20T%3E" class="small-section-header"><span>Methods from <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>&lt;Target = <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;&gt;</span><a href="#deref-methods-BitSlice%3CO%2C%20T%3E" class="anchor"></a></h2><div id="deref-methods-BitSlice%3CO%2C%20T%3E-1"><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.len-1" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#81-83">source</a><h4 class="code-header">pub fn <a href="#method.len-1" class="fnname">len</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the number of bits in the slice.</p>
<h5 id="original-37"><a href="#original-37">Original</a></h5>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.len"><code>slice::len</code></a></p>
<h5 id="examples-46"><a href="#examples-46">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>a = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="macro">assert_eq!</span>(a.len(), <span class="number">3</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.is_empty-1" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#100-102">source</a><h4 class="code-header">pub fn <a href="#method.is_empty-1" class="fnname">is_empty</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns <code>true</code> if the slice has a length of 0.</p>
<h5 id="original-38"><a href="#original-38">Original</a></h5>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.is_empty"><code>slice::is_empty</code></a></p>
<h5 id="examples-47"><a href="#examples-47">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>a = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="macro">assert!</span>(!a.is_empty());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.first" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#120-122">source</a><h4 class="code-header">pub fn <a href="#method.first" class="fnname">first</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.65.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../prelude/struct.BitRef.html" title="struct bitvec::prelude::BitRef">BitRef</a>&lt;'_, <a class="struct" href="../ptr/struct.Const.html" title="struct bitvec::ptr::Const">Const</a>, O, T&gt;&gt;</h4></section></summary><div class="docblock"><p>Returns the first bit of the slice, or <code>None</code> if it is empty.</p>
<h5 id="original-39"><a href="#original-39">Original</a></h5><h5 id="examples-48"><a href="#examples-48">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>v = <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="bool-val">true</span>), v.first().as_deref());

<span class="kw">let </span>w = <span class="macro">bits!</span>[];
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, w.first());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.first_mut" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#153-155">source</a><h4 class="code-header">pub fn <a href="#method.first_mut" class="fnname">first_mut</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.65.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../prelude/struct.BitRef.html" title="struct bitvec::prelude::BitRef">BitRef</a>&lt;'_, <a class="struct" href="../ptr/struct.Mut.html" title="struct bitvec::ptr::Mut">Mut</a>, O, T&gt;&gt;</h4></section></summary><div class="docblock"><p>Returns a mutable pointer to the first bit of the slice, or <code>None</code>
if it is empty.</p>
<h5 id="original-40"><a href="#original-40">Original</a></h5>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.first_mut"><code>slice::first_mut</code></a></p>
<h5 id="api-differences-14"><a href="#api-differences-14">API Differences</a></h5>
<p>This crate cannot manifest <code>&amp;mut bool</code> references, and must use the
<a href="../prelude/struct.BitRef.html"><code>BitRef</code></a> proxy type where <code>&amp;mut bool</code> exists in the standard library
API. The proxy value must be bound as <code>mut</code> in order to write through
it.</p>
<h5 id="examples-49"><a href="#examples-49">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>x = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];

<span class="kw">if let </span><span class="prelude-val">Some</span>(<span class="kw-2">mut </span>first) = x.first_mut() {
  <span class="kw-2">*</span>first = <span class="bool-val">true</span>;
}
<span class="macro">assert_eq!</span>(x, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.split_first" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#178-186">source</a><h4 class="code-header">pub fn <a href="#method.split_first" class="fnname">split_first</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.65.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;(<a class="struct" href="../prelude/struct.BitRef.html" title="struct bitvec::prelude::BitRef">BitRef</a>&lt;'_, <a class="struct" href="../ptr/struct.Const.html" title="struct bitvec::ptr::Const">Const</a>, O, T&gt;, <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;</a>Self)&gt;</h4></section></summary><div class="docblock"><p>Returns the first and all the rest of the bits of the slice, or
<code>None</code> if it is empty.</p>
<h5 id="original-41"><a href="#original-41">Original</a></h5>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#split_first"><code>slice::split_first</code></a></p>
<h5 id="examples-50"><a href="#examples-50">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>x = <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>];

<span class="kw">if let </span><span class="prelude-val">Some</span>((first, rest)) = x.split_first() {
  <span class="macro">assert_eq!</span>(first, <span class="kw-2">&amp;</span><span class="bool-val">true</span>);
  <span class="macro">assert_eq!</span>(rest, <span class="macro">bits!</span>[<span class="number">0</span>; <span class="number">2</span>]);
}</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.split_first_mut" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#226-236">source</a><h4 class="code-header">pub fn <a href="#method.split_first_mut" class="fnname">split_first_mut</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self<br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.65.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;(<a class="struct" href="../prelude/struct.BitRef.html" title="struct bitvec::prelude::BitRef">BitRef</a>&lt;'_, <a class="struct" href="../ptr/struct.Mut.html" title="struct bitvec::ptr::Mut">Mut</a>, O, T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>&gt;, &amp;mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>&gt;)&gt;</h4></section></summary><div class="docblock"><p>Returns the first and all the rest of the bits of the slice, or
<code>None</code> if it is empty.</p>
<h5 id="original-42"><a href="#original-42">Original</a></h5>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#split_first_mut"><code>slice::split_first_mut</code></a></p>
<h5 id="api-differences-15"><a href="#api-differences-15">API Differences</a></h5>
<p>This crate cannot manifest <code>&amp;mut bool</code> references, and must use the
<a href="../prelude/struct.BitRef.html"><code>BitRef</code></a> proxy type where <code>&amp;mut bool</code> exists in the standard library
API. The proxy value must be bound as <code>mut</code> in order to write through
it.</p>
<p>Because the references are permitted to use the same memory address,
they are marked as aliasing in order to satisfy Rust’s requirements
about freedom from data races.</p>
<h5 id="examples-51"><a href="#examples-51">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>x = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];

<span class="kw">if let </span><span class="prelude-val">Some</span>((<span class="kw-2">mut </span>first, rest)) = x.split_first_mut() {
  <span class="kw-2">*</span>first = <span class="bool-val">true</span>;
  rest.set(<span class="number">0</span>, <span class="bool-val">true</span>);
  rest.set(<span class="number">1</span>, <span class="bool-val">false</span>);
}
<span class="macro">assert_eq!</span>(x, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.split_last" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#259-267">source</a><h4 class="code-header">pub fn <a href="#method.split_last" class="fnname">split_last</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.65.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;(<a class="struct" href="../prelude/struct.BitRef.html" title="struct bitvec::prelude::BitRef">BitRef</a>&lt;'_, <a class="struct" href="../ptr/struct.Const.html" title="struct bitvec::ptr::Const">Const</a>, O, T&gt;, <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;</a>Self)&gt;</h4></section></summary><div class="docblock"><p>Returns the last and all the rest of the bits of the slice, or
<code>None</code> if it is empty.</p>
<h5 id="original-43"><a href="#original-43">Original</a></h5>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.split_last"><code>slice::split_last</code></a></p>
<h5 id="examples-52"><a href="#examples-52">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>x = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];

<span class="kw">if let </span><span class="prelude-val">Some</span>((last, rest)) = x.split_last() {
  <span class="macro">assert_eq!</span>(last, <span class="kw-2">&amp;</span><span class="bool-val">true</span>);
  <span class="macro">assert_eq!</span>(rest, <span class="macro">bits!</span>[<span class="number">0</span>; <span class="number">2</span>]);
}</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.split_last_mut" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#307-317">source</a><h4 class="code-header">pub fn <a href="#method.split_last_mut" class="fnname">split_last_mut</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self<br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.65.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;(<a class="struct" href="../prelude/struct.BitRef.html" title="struct bitvec::prelude::BitRef">BitRef</a>&lt;'_, <a class="struct" href="../ptr/struct.Mut.html" title="struct bitvec::ptr::Mut">Mut</a>, O, T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>&gt;, &amp;mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>&gt;)&gt;</h4></section></summary><div class="docblock"><p>Returns the last and all the rest of the bits of the slice, or
<code>None</code> if it is empty.</p>
<h5 id="original-44"><a href="#original-44">Original</a></h5>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.split_last_mut"><code>slice::split_last_mut</code></a></p>
<h5 id="api-differences-16"><a href="#api-differences-16">API Differences</a></h5>
<p>This crate cannot manifest <code>&amp;mut bool</code> references, and must use the
<a href="../slice/struct.BitSlice.html"><code>BitRef</code></a> proxy type where <code>&amp;mut bool</code> exists in the standard library
API. The proxy value must be bound as <code>mut</code> in order to write through
it.</p>
<p>Because the references are permitted to use the same memory address,
they are marked as aliasing in order to satisfy Rust’s requirements
about freedom from data races.</p>
<h5 id="examples-53"><a href="#examples-53">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>x = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>];

<span class="kw">if let </span><span class="prelude-val">Some</span>((<span class="kw-2">mut </span>last, rest)) = x.split_last_mut() {
  <span class="kw-2">*</span>last = <span class="bool-val">true</span>;
  rest.set(<span class="number">0</span>, <span class="bool-val">false</span>);
  rest.set(<span class="number">1</span>, <span class="bool-val">true</span>);
}
<span class="macro">assert_eq!</span>(x, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.last" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#337-342">source</a><h4 class="code-header">pub fn <a href="#method.last" class="fnname">last</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.65.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../prelude/struct.BitRef.html" title="struct bitvec::prelude::BitRef">BitRef</a>&lt;'_, <a class="struct" href="../ptr/struct.Const.html" title="struct bitvec::ptr::Const">Const</a>, O, T&gt;&gt;</h4></section></summary><div class="docblock"><p>Returns the last bit of the slice, or <code>None</code> if it is empty.</p>
<h5 id="original-45"><a href="#original-45">Original</a></h5>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.last"><code>slice::last</code></a></p>
<h5 id="examples-54"><a href="#examples-54">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>v = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="bool-val">true</span>), v.last().as_deref());

<span class="kw">let </span>w = <span class="macro">bits!</span>[];
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, w.last());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.last_mut" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#372-377">source</a><h4 class="code-header">pub fn <a href="#method.last_mut" class="fnname">last_mut</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.65.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../prelude/struct.BitRef.html" title="struct bitvec::prelude::BitRef">BitRef</a>&lt;'_, <a class="struct" href="../ptr/struct.Mut.html" title="struct bitvec::ptr::Mut">Mut</a>, O, T&gt;&gt;</h4></section></summary><div class="docblock"><p>Returns a mutable pointer to the last bit in the slice.</p>
<h5 id="original-46"><a href="#original-46">Original</a></h5>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.last_mut"><code>slice::last_mut</code></a></p>
<h5 id="api-differences-17"><a href="#api-differences-17">API Differences</a></h5>
<p>This crate cannot manifest <code>&amp;mut bool</code> references, and must use the
<a href="../prelude/struct.BitRef.html"><code>BitRef</code></a> proxy type where <code>&amp;mut bool</code> exists in the standard library
API. The proxy value must be bound as <code>mut</code> in order to write through
it.</p>
<h5 id="examples-55"><a href="#examples-55">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>x = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];

<span class="kw">if let </span><span class="prelude-val">Some</span>(<span class="kw-2">mut </span>last) = x.last_mut() {
  <span class="kw-2">*</span>last = <span class="bool-val">true</span>;
}
<span class="macro">assert_eq!</span>(x, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.get" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#402-405">source</a><h4 class="code-header">pub fn <a href="#method.get" class="fnname">get</a>&lt;'a, I&gt;(&amp;'a self, index: I) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.65.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;I::<a class="associatedtype" href="../slice/trait.BitSliceIndex.html#associatedtype.Immut" title="type bitvec::slice::BitSliceIndex::Immut">Immut</a>&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="../slice/trait.BitSliceIndex.html" title="trait bitvec::slice::BitSliceIndex">BitSliceIndex</a>&lt;'a, O, T&gt;,</span></h4></section></summary><div class="docblock"><p>Returns a reference to a bit or subslice depending on the type of index.</p>
<ul>
<li>If given a position, returns a reference to the bit at that position
or <code>None</code> if out of bounds.</li>
<li>If given a range, returns the subslice corresponding to that range, or
<code>None</code> if out of bounds.</li>
</ul>
<h5 id="original-47"><a href="#original-47">Original</a></h5>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.get"><code>slice::get</code></a></p>
<h5 id="examples-56"><a href="#examples-56">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>v = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="bool-val">true</span>), v.get(<span class="number">1</span>).as_deref());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>]), v.get(<span class="number">0 </span>.. <span class="number">2</span>));
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, v.get(<span class="number">3</span>));
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, v.get(<span class="number">0 </span>.. <span class="number">4</span>));</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.get_mut" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#437-440">source</a><h4 class="code-header">pub fn <a href="#method.get_mut" class="fnname">get_mut</a>&lt;'a, I&gt;(&amp;'a mut self, index: I) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.65.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;I::<a class="associatedtype" href="../slice/trait.BitSliceIndex.html#associatedtype.Mut" title="type bitvec::slice::BitSliceIndex::Mut">Mut</a>&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="../slice/trait.BitSliceIndex.html" title="trait bitvec::slice::BitSliceIndex">BitSliceIndex</a>&lt;'a, O, T&gt;,</span></h4></section></summary><div class="docblock"><p>Returns a mutable reference to a bit or subslice depending on the type
of index (see <a href="../slice/struct.BitSlice.html#method.get"><code>.get()</code></a>) or <code>None</code> if the index is out of bounds.</p>
<h5 id="original-48"><a href="#original-48">Original</a></h5>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.get_mut"><code>slice::get_mut</code></a></p>
<h5 id="api-differences-18"><a href="#api-differences-18">API Differences</a></h5>
<p>This crate cannot manifest <code>&amp;mut bool</code> references, and must use the
<a href="../prelude/struct.BitRef.html"><code>BitRef</code></a> proxy type where <code>&amp;mut bool</code> exists in the standard library
API. The proxy value must be bound as <code>mut</code> in order to write through
it.</p>
<h5 id="examples-57"><a href="#examples-57">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>x = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];

<span class="kw">if let </span><span class="prelude-val">Some</span>(<span class="kw-2">mut </span>bit) = x.get_mut(<span class="number">1</span>) {
  <span class="kw-2">*</span>bit = <span class="bool-val">true</span>;
}
<span class="macro">assert_eq!</span>(x, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.get_unchecked" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#468-471">source</a><h4 class="code-header">pub unsafe fn <a href="#method.get_unchecked" class="fnname">get_unchecked</a>&lt;'a, I&gt;(&amp;'a self, index: I) -&gt; I::<a class="associatedtype" href="../slice/trait.BitSliceIndex.html#associatedtype.Immut" title="type bitvec::slice::BitSliceIndex::Immut">Immut</a><span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="../slice/trait.BitSliceIndex.html" title="trait bitvec::slice::BitSliceIndex">BitSliceIndex</a>&lt;'a, O, T&gt;,</span></h4></section></summary><div class="docblock"><p>Returns a reference to a bit or subslice, without doing bounds checking.</p>
<p>This is generally not recommended; use with caution! Calling this method
with an out-of-bounds index is <em><a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behavior</a></em> even if the
resulting reference is not used. For a safe alternative, see <a href="../slice/struct.BitSlice.html#method.get"><code>.get()</code></a>.</p>
<h5 id="original-49"><a href="#original-49">Original</a></h5>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.get_unchecked"><code>slice::get_unchecked</code></a></p>
<h5 id="examples-58"><a href="#examples-58">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>x = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];

<span class="kw">unsafe </span>{
  <span class="macro">assert_eq!</span>(x.get_unchecked(<span class="number">1</span>), <span class="kw-2">&amp;</span><span class="bool-val">true</span>);
}</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.get_unchecked_mut" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#510-513">source</a><h4 class="code-header">pub unsafe fn <a href="#method.get_unchecked_mut" class="fnname">get_unchecked_mut</a>&lt;'a, I&gt;(&amp;'a mut self, index: I) -&gt; I::<a class="associatedtype" href="../slice/trait.BitSliceIndex.html#associatedtype.Mut" title="type bitvec::slice::BitSliceIndex::Mut">Mut</a><span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="../slice/trait.BitSliceIndex.html" title="trait bitvec::slice::BitSliceIndex">BitSliceIndex</a>&lt;'a, O, T&gt;,</span></h4></section></summary><div class="docblock"><p>Returns a mutable reference to a bit or subslice, without doing bounds
checking.</p>
<p>This is generally not recommended; use with caution! Calling this method
with an out-of-bounds index is <em><a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behavior</a></em> even if the
resulting reference is not used. For a safe alternative, see
[<code>.get_mut()</code>].</p>
<h5 id="original-50"><a href="#original-50">Original</a></h5>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.get_unchecked_mut"><code>slice::get_unchecked_mut</code></a></p>
<h5 id="api-differences-19"><a href="#api-differences-19">API Differences</a></h5>
<p>This crate cannot manifest <code>&amp;mut bool</code> references, and must use the
<a href="../prelude/struct.BitRef.html"><code>BitRef</code></a> proxy type where <code>&amp;mut bool</code> exists in the standard library
API. The proxy value must be bound as <code>mut</code> in order to write through
it.</p>
<h5 id="examples-59"><a href="#examples-59">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>x = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>; <span class="number">3</span>];
<span class="kw">unsafe </span>{
  <span class="kw">let </span><span class="kw-2">mut </span>bit = x.get_unchecked_mut(<span class="number">1</span>);
  <span class="kw-2">*</span>bit = <span class="bool-val">true</span>;
}
<span class="macro">assert_eq!</span>(x, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.swap" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#572-578">source</a><h4 class="code-header">pub fn <a href="#method.swap" class="fnname">swap</a>(&amp;mut self, a: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>, b: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Swaps two bits in the slice.</p>
<h5 id="original-51"><a href="#original-51">Original</a></h5>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.swap"><code>slice::swap</code></a></p>
<h5 id="arguments"><a href="#arguments">Arguments</a></h5>
<ul>
<li><code>a</code>: The index of the first bit</li>
<li><code>b</code>: The index of the second bit</li>
</ul>
<h5 id="panics-12"><a href="#panics-12">Panics</a></h5>
<p>Panics if <code>a</code> or <code>b</code> are out of bounds.</p>
<h5 id="examples-60"><a href="#examples-60">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>v = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>];
v.swap(<span class="number">1</span>, <span class="number">3</span>);
<span class="macro">assert_eq!</span>(v, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.reverse" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#596-626">source</a><h4 class="code-header">pub fn <a href="#method.reverse" class="fnname">reverse</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Reverses the order of bits in the slice, in place.</p>
<h5 id="original-52"><a href="#original-52">Original</a></h5>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.reverse"><code>slice::reverse</code></a></p>
<h5 id="examples-61"><a href="#examples-61">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>v = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>];
v.reverse();
<span class="macro">assert_eq!</span>(v, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.iter" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#665-667">source</a><h4 class="code-header">pub fn <a href="#method.iter" class="fnname">iter</a>(&amp;self) -&gt; <a class="struct" href="../slice/struct.Iter.html" title="struct bitvec::slice::Iter">Iter</a>&lt;'_, O, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../slice/struct.Iter.html" title="struct bitvec::slice::Iter">Iter</a>&lt;'a, O, T&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../slice/struct.Iter.html" title="struct bitvec::slice::Iter">Iter</a>&lt;'a, O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &lt;<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a> as <a class="trait" href="../slice/trait.BitSliceIndex.html" title="trait bitvec::slice::BitSliceIndex">BitSliceIndex</a>&lt;'a, O, T&gt;&gt;::<a class="associatedtype" href="../slice/trait.BitSliceIndex.html#associatedtype.Immut" title="type bitvec::slice::BitSliceIndex::Immut">Immut</a>;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Returns an iterator over the slice.</p>
<h5 id="original-53"><a href="#original-53">Original</a></h5>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.iter"><code>slice::iter</code></a></p>
<h5 id="api-differences-20"><a href="#api-differences-20">API Differences</a></h5>
<p>This iterator yields <a href="../prelude/struct.BitRef.html"><code>BitRef</code></a> proxy references, rather than <code>&amp;bool</code>
ordinary references. It does so in order to promote consistency in the
crate, and make switching between immutable and mutable single-bit
access easier.</p>
<p>The produced iterator has a <a href="../slice/struct.Iter.html#method.by_ref"><code>by_ref</code></a> adapter that yields <code>&amp;bool</code>
references, and a <a href="../slice/struct.Iter.html#method.by_val"><code>by_val</code></a> adapter that yields <code>bool</code> values. Use
these methods to fit this iterator into APIs that expect ordinary <code>bool</code>
inputs.</p>
<h5 id="examples-62"><a href="#examples-62">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>x = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let </span><span class="kw-2">mut </span>iterator = x.iter();

<span class="macro">assert_eq!</span>(iterator.next().as_deref(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="bool-val">false</span>));
<span class="macro">assert_eq!</span>(iterator.next().as_deref(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="bool-val">false</span>));
<span class="macro">assert_eq!</span>(iterator.next().as_deref(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="bool-val">true</span>));
<span class="macro">assert_eq!</span>(iterator.next().as_deref(), <span class="prelude-val">None</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.iter_mut" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#705-707">source</a><h4 class="code-header">pub fn <a href="#method.iter_mut" class="fnname">iter_mut</a>(&amp;mut self) -&gt; <a class="struct" href="../slice/struct.IterMut.html" title="struct bitvec::slice::IterMut">IterMut</a>&lt;'_, O, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../slice/struct.IterMut.html" title="struct bitvec::slice::IterMut">IterMut</a>&lt;'a, O, T&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../slice/struct.IterMut.html" title="struct bitvec::slice::IterMut">IterMut</a>&lt;'a, O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &lt;<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a> as <a class="trait" href="../slice/trait.BitSliceIndex.html" title="trait bitvec::slice::BitSliceIndex">BitSliceIndex</a>&lt;'a, O, T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>&gt;&gt;::<a class="associatedtype" href="../slice/trait.BitSliceIndex.html#associatedtype.Mut" title="type bitvec::slice::BitSliceIndex::Mut">Mut</a>;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Returns an iterator that allows modifying each bit.</p>
<h5 id="original-54"><a href="#original-54">Original</a></h5>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.iter_mut"><code>slice::iter_mut</code></a></p>
<h5 id="api-differences-21"><a href="#api-differences-21">API Differences</a></h5>
<p>This crate cannot manifest <code>&amp;mut bool</code> references, and must use the
<a href="../prelude/struct.BitRef.html"><code>BitRef</code></a> proxy type where <code>&amp;mut bool</code> exists in the standard library
API. The proxy value must be bound as <code>mut</code> in order to write through
it.</p>
<p>This iterator marks each yielded item as aliased, as iterators can be
used to yield multiple items into the same scope. If you are using
the iterator in a manner that ensures that all yielded items have
disjoint lifetimes, you can use the <a href="../slice/struct.IterMut.html#method.remove_alias"><code>.remove_alias()</code></a> adapter on it to
remove the alias marker from the yielded subslices.</p>
<h5 id="examples-63"><a href="#examples-63">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>x = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">for </span><span class="kw-2">mut </span>bit <span class="kw">in </span>x.iter_mut() {
  <span class="kw-2">*</span>bit = !<span class="kw-2">*</span>bit;
}
<span class="macro">assert_eq!</span>(x, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.windows" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#744-747">source</a><h4 class="code-header">pub fn <a href="#method.windows" class="fnname">windows</a>(&amp;self, size: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../slice/struct.Windows.html" title="struct bitvec::slice::Windows">Windows</a>&lt;'_, O, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../slice/struct.Windows.html" title="struct bitvec::slice::Windows">Windows</a>&lt;'a, O, T&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../slice/struct.Windows.html" title="struct bitvec::slice::Windows">Windows</a>&lt;'a, O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Returns an iterator over all contiguous windows of length <code>size</code>. The
windows overlap. If the slice is shorter than <code>size</code>, the iterator
returns no values.</p>
<h5 id="original-55"><a href="#original-55">Original</a></h5>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.windows"><code>slice::windows</code></a></p>
<h5 id="panics-13"><a href="#panics-13">Panics</a></h5>
<p>Panics if <code>size</code> is 0.</p>
<h5 id="examples-64"><a href="#examples-64">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>slice = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="kw">let </span><span class="kw-2">mut </span>iter = slice.windows(<span class="number">2</span>);
<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[<span class="number">0</span>; <span class="number">2</span>]);
<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>]);
<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[<span class="number">1</span>; <span class="number">2</span>]);
<span class="macro">assert!</span>(iter.next().is_none());</code></pre></div>
<p>If the slice is shorter than <code>size</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>slice = <span class="macro">bits!</span>[<span class="number">0</span>; <span class="number">3</span>];
<span class="kw">let </span><span class="kw-2">mut </span>iter = slice.windows(<span class="number">4</span>);
<span class="macro">assert!</span>(iter.next().is_none());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.chunks" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#784-787">source</a><h4 class="code-header">pub fn <a href="#method.chunks" class="fnname">chunks</a>(&amp;self, chunk_size: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../slice/struct.Chunks.html" title="struct bitvec::slice::Chunks">Chunks</a>&lt;'_, O, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../slice/struct.Chunks.html" title="struct bitvec::slice::Chunks">Chunks</a>&lt;'a, O, T&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../slice/struct.Chunks.html" title="struct bitvec::slice::Chunks">Chunks</a>&lt;'a, O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Returns an iterator over <code>chunk_size</code> bits of the slice at a time,
starting at the beginning of the slice.</p>
<p>The chunks are slices and do not overlap. If <code>chunk_size</code> does not
divide the length of the slice, then the last chunk will not have length
<code>chunk_size</code>.</p>
<p>See <a href="../slice/struct.BitSlice.html#method.chunks_exact"><code>.chunks_exact()</code></a> for a variant of this iterator that returns
chunks of always exactly <code>chunk_size</code> bits, and <a href="../slice/struct.BitSlice.html#method.rchunks"><code>.rchunks()</code></a> for the
same iterator but starting at the end of the slice.</p>
<h5 id="original-56"><a href="#original-56">Original</a></h5>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.chunks"><code>slice::chunks</code></a></p>
<h5 id="panics-14"><a href="#panics-14">Panics</a></h5>
<p>Panics if <code>chunk_size</code> is 0.</p>
<h5 id="examples-65"><a href="#examples-65">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>slice = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let </span><span class="kw-2">mut </span>iter = slice.chunks(<span class="number">2</span>);
<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>]);
<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>]);
<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[<span class="number">1</span>]);
<span class="macro">assert!</span>(iter.next().is_none());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.chunks_mut" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#837-840">source</a><h4 class="code-header">pub fn <a href="#method.chunks_mut" class="fnname">chunks_mut</a>(&amp;mut self, chunk_size: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../slice/struct.ChunksMut.html" title="struct bitvec::slice::ChunksMut">ChunksMut</a>&lt;'_, O, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../slice/struct.ChunksMut.html" title="struct bitvec::slice::ChunksMut">ChunksMut</a>&lt;'a, O, T&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../slice/struct.ChunksMut.html" title="struct bitvec::slice::ChunksMut">ChunksMut</a>&lt;'a, O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>&gt;;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Returns an iterator over <code>chunk_size</code> bits of the slice at a time,
starting at the beginning of the slice.</p>
<p>The chunks are mutable slices, and do not overlap. If <code>chunk_size</code> does
not divide the length of the slice, then the last chunk will not have
length <code>chunk_size</code>.</p>
<p>See <a href="../slice/struct.BitSlice.html#method.chunks_exact_mut"><code>.chunks_exact_mut()</code></a> for a variant of this iterator that returns
chunks of always exactly <code>chunk_size</code> bits, and <a href="../slice/struct.BitSlice.html#method.rchunks_mut"><code>.rchunks_mut()</code></a> for
the same iterator but starting at the end of the slice.</p>
<h5 id="original-57"><a href="#original-57">Original</a></h5>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.chunks_mut"><code>slice::chunks_mut</code></a></p>
<h5 id="api-differences-22"><a href="#api-differences-22">API Differences</a></h5>
<p>This iterator marks each yielded item as aliased, as iterators can be
used to yield multiple items into the same scope. If you are using
the iterator in a manner that ensures that all yielded items have
disjoint lifetimes, you can use the <a href="../slice/struct.ChunksMut.html#method.remove_alias"><code>.remove_alias()</code></a> adapter on it to
remove the alias marker from the yielded subslices.</p>
<h5 id="panics-15"><a href="#panics-15">Panics</a></h5>
<p>Panics if <code>chunk_size</code> is 0.</p>
<h5 id="examples-66"><a href="#examples-66">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>v = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>; <span class="number">5</span>];
<span class="kw">let </span><span class="kw-2">mut </span>count = <span class="number">1</span>;

<span class="kw">for </span>chunk <span class="kw">in </span>v.chunks_mut(<span class="number">2</span>) {
  <span class="kw">for </span><span class="kw-2">mut </span>bit <span class="kw">in </span>chunk.iter_mut() {
    <span class="kw-2">*</span>bit = count % <span class="number">2 </span>== <span class="number">0</span>;
  }
  count += <span class="number">1</span>;
}
<span class="macro">assert_eq!</span>(v, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.chunks_exact" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#883-886">source</a><h4 class="code-header">pub fn <a href="#method.chunks_exact" class="fnname">chunks_exact</a>(&amp;self, chunk_size: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../slice/struct.ChunksExact.html" title="struct bitvec::slice::ChunksExact">ChunksExact</a>&lt;'_, O, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../slice/struct.ChunksExact.html" title="struct bitvec::slice::ChunksExact">ChunksExact</a>&lt;'a, O, T&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../slice/struct.ChunksExact.html" title="struct bitvec::slice::ChunksExact">ChunksExact</a>&lt;'a, O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Returns an iterator over <code>chunk_size</code> bits of the slice at a time,
starting at the beginning of the slice.</p>
<p>The chunks are slices and do not overlap. If <code>chunk_size</code> does not
divide the length of the slice, then the last up to <code>chunk_size-1</code> bits
will be omitted and can be retrieved from the <a href="../slice/struct.ChunksExact.html#method.remainder"><code>.remainder()</code></a> method of
the iterator.</p>
<p>Due to each chunk having exactly <code>chunk_size</code> bits, the compiler may be
able to optimize the resulting code better than in the case of
<a href="../slice/struct.BitSlice.html#method.chunks"><code>.chunks()</code></a>.</p>
<p>See <a href="../slice/struct.BitSlice.html#method.chunks"><code>.chunks()</code></a> for a variant of this iterator that also returns the
remainder as a smaller chunk, and <a href="../slice/struct.BitSlice.html#method.rchunks_exact"><code>.rchunks_exact()</code></a> for the same
iterator but starting at the end of the slice.</p>
<h5 id="original-58"><a href="#original-58">Original</a></h5>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.chunks_exact"><code>slice::chunks_exact</code></a></p>
<h5 id="panics-16"><a href="#panics-16">Panics</a></h5>
<p>Panics if <code>chunk_size</code> is 0.</p>
<h5 id="examples-67"><a href="#examples-67">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>slice = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="kw">let </span><span class="kw-2">mut </span>iter = slice.chunks_exact(<span class="number">2</span>);
<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>]);
<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>]);
<span class="macro">assert!</span>(iter.next().is_none());
<span class="macro">assert_eq!</span>(iter.remainder(), <span class="macro">bits!</span>[<span class="number">0</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.chunks_exact_mut" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#938-944">source</a><h4 class="code-header">pub fn <a href="#method.chunks_exact_mut" class="fnname">chunks_exact_mut</a>(&amp;mut self, chunk_size: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../slice/struct.ChunksExactMut.html" title="struct bitvec::slice::ChunksExactMut">ChunksExactMut</a>&lt;'_, O, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../slice/struct.ChunksExactMut.html" title="struct bitvec::slice::ChunksExactMut">ChunksExactMut</a>&lt;'a, O, T&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../slice/struct.ChunksExactMut.html" title="struct bitvec::slice::ChunksExactMut">ChunksExactMut</a>&lt;'a, O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>&gt;;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Returns an iterator over <code>chunk_size</code> bits of the slice at a time,
starting at the beginning of the slice.</p>
<p>The chunks are mutable slices, and do not overlap. If <code>chunk_size</code> does
not divide the length of the slice, then the last up to <code>chunk_size-1</code>
bits will be omitted and can be retrieved from the <a href="../slice/struct.ChunksExactMut.html#method.into_remainder"><code>.into_remainder()</code></a>
method of the iterator.</p>
<p>Due to each chunk having exactly <code>chunk_size</code> bits, the compiler may be
able to optimize the resulting code better than in the case of
<a href="../slice/struct.BitSlice.html#method.chunks_mut"><code>.chunks_mut()</code></a>.</p>
<p>See <a href="../slice/struct.BitSlice.html#method.chunks_mut"><code>.chunks_mut()</code></a> for a variant of this iterator that also returns
the remainder as a smaller chunk, and <a href="../slice/struct.BitSlice.html#method.rchunks_exact_mut"><code>.rchunks_exact_mut()</code></a> for the
same iterator but starting at the end of the slice.</p>
<h5 id="original-59"><a href="#original-59">Original</a></h5>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.chunks_exact_mut"><code>slice::chunks_exact_mut</code></a></p>
<h5 id="api-differences-23"><a href="#api-differences-23">API Differences</a></h5>
<p>This iterator marks each yielded item as aliased, as iterators can be
used to yield multiple items into the same scope. If you are using
the iterator in a manner that ensures that all yielded items have
disjoint lifetimes, you can use the <a href="../slice/struct.ChunksExactMut.html#method.remove_alias"><code>.remove_alias()</code></a> adapter on it to
remove the alias marker from the yielded subslices.</p>
<h5 id="panics-17"><a href="#panics-17">Panics</a></h5>
<p>Panics if <code>chunk_size</code> is 0.</p>
<h5 id="examples-68"><a href="#examples-68">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>v = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>; <span class="number">5</span>];

<span class="kw">for </span>chunk <span class="kw">in </span>v.chunks_exact_mut(<span class="number">2</span>) {
  chunk.set_all(<span class="bool-val">true</span>);
}
<span class="macro">assert_eq!</span>(v, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.rchunks" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#981-984">source</a><h4 class="code-header">pub fn <a href="#method.rchunks" class="fnname">rchunks</a>(&amp;self, chunk_size: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../slice/struct.RChunks.html" title="struct bitvec::slice::RChunks">RChunks</a>&lt;'_, O, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../slice/struct.RChunks.html" title="struct bitvec::slice::RChunks">RChunks</a>&lt;'a, O, T&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../slice/struct.RChunks.html" title="struct bitvec::slice::RChunks">RChunks</a>&lt;'a, O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Returns an iterator over <code>chunk_size</code> bits of the slice at a time,
starting at the end of the slice.</p>
<p>The chunks are slices and do not overlap. If <code>chunk_size</code> does not
divide the length of the slice, then the last chunk will not have length
<code>chunk_size</code>.</p>
<p>See <a href="../slice/struct.BitSlice.html#method.rchunks_exact"><code>.rchunks_exact()</code></a> for a variant of this iterator that returns
chunks of always exactly <code>chunk_size</code> bits, and <a href="../slice/struct.BitSlice.html#method.chunks"><code>.chunks()</code></a> for the
same iterator but starting at the beginning of the slice.</p>
<h5 id="original-60"><a href="#original-60">Original</a></h5>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.rchunks"><code>slice::rchunks</code></a></p>
<h5 id="panics-18"><a href="#panics-18">Panics</a></h5>
<p>Panics if <code>chunk_size</code> is 0.</p>
<h5 id="examples-69"><a href="#examples-69">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>slice = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let </span><span class="kw-2">mut </span>iter = slice.rchunks(<span class="number">2</span>);
<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>]);
<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>]);
<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[<span class="number">0</span>]);
<span class="macro">assert!</span>(iter.next().is_none());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.rchunks_mut" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#1034-1037">source</a><h4 class="code-header">pub fn <a href="#method.rchunks_mut" class="fnname">rchunks_mut</a>(&amp;mut self, chunk_size: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../slice/struct.RChunksMut.html" title="struct bitvec::slice::RChunksMut">RChunksMut</a>&lt;'_, O, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../slice/struct.RChunksMut.html" title="struct bitvec::slice::RChunksMut">RChunksMut</a>&lt;'a, O, T&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../slice/struct.RChunksMut.html" title="struct bitvec::slice::RChunksMut">RChunksMut</a>&lt;'a, O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>&gt;;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Returns an iterator over <code>chunk_size</code> bits of the slice at a time,
starting at the end of the slice.</p>
<p>The chunks are mutable slices, and do not overlap. If <code>chunk_size</code> does
not divide the length of the slice, then the last chunk will not have
length <code>chunk_size</code>.</p>
<p>See <a href="../slice/struct.BitSlice.html#method.rchunks_exact_mut"><code>.rchunks_exact_mut()</code></a> for a variant of this iterator that returns
chunks of always exactly <code>chunk_size</code> bits, and <a href="../slice/struct.BitSlice.html#method.chunks_mut"><code>.chunks_mut()</code></a> for
the same iterator but starting at the beginning of the slice.</p>
<h5 id="original-61"><a href="#original-61">Original</a></h5>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.rchunks_mut"><code>slice::rchunks_mut</code></a></p>
<h5 id="api-differences-24"><a href="#api-differences-24">API Differences</a></h5>
<p>This iterator marks each yielded item as aliased, as iterators can be
used to yield multiple items into the same scope. If you are using
the iterator in a manner that ensures that all yielded items have
disjoint lifetimes, you can use the <a href="../slice/struct.RChunksMut.html#method.remove_alias"><code>.remove_alias()</code></a> adapter on it to
remove the alias marker from the yielded subslices.</p>
<h5 id="panics-19"><a href="#panics-19">Panics</a></h5>
<p>Panics if <code>chunk_size</code> is 0.</p>
<h5 id="examples-70"><a href="#examples-70">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>v = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>; <span class="number">5</span>];
<span class="kw">let </span><span class="kw-2">mut </span>count = <span class="number">1</span>;

<span class="kw">for </span>chunk <span class="kw">in </span>v.rchunks_mut(<span class="number">2</span>) {
  <span class="kw">for </span><span class="kw-2">mut </span>bit <span class="kw">in </span>chunk.iter_mut() {
    <span class="kw-2">*</span>bit = count % <span class="number">2 </span>== <span class="number">0</span>;
  }
  count += <span class="number">1</span>;
}
<span class="macro">assert_eq!</span>(v, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.rchunks_exact" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#1080-1083">source</a><h4 class="code-header">pub fn <a href="#method.rchunks_exact" class="fnname">rchunks_exact</a>(&amp;self, chunk_size: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../slice/struct.RChunksExact.html" title="struct bitvec::slice::RChunksExact">RChunksExact</a>&lt;'_, O, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../slice/struct.RChunksExact.html" title="struct bitvec::slice::RChunksExact">RChunksExact</a>&lt;'a, O, T&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../slice/struct.RChunksExact.html" title="struct bitvec::slice::RChunksExact">RChunksExact</a>&lt;'a, O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Returns an iterator over <code>chunk_size</code> bits of the slice at a time,
starting at the end of the slice.</p>
<p>The chunks are slices and do not overlap. If <code>chunk_size</code> does not
divide the length of the slice, then the last up to <code>chunk_size-1</code> bits
will be omitted and can be retrieved from the <a href="../slice/struct.ChunksExact.html#method.remainder"><code>.remainder()</code></a> method of
the iterator.</p>
<p>Due to each chunk having exactly <code>chunk_size</code> bits, the compiler may be
able to optimize the resulting code better than in the case of
<a href="../slice/struct.BitSlice.html#method.rchunks"><code>.rchunks()</code></a>.</p>
<p>See <a href="../slice/struct.BitSlice.html#method.rchunks"><code>.rchunks()</code></a> for a variant of this iterator that also returns the
remainder as a smaller chunk, and <a href="../slice/struct.BitSlice.html#method.chunks_exact"><code>.chunks_exact()</code></a> for the same
iterator but starting at the beginning of the slice.</p>
<h5 id="original-62"><a href="#original-62">Original</a></h5>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.rchunks_exact"><code>slice::rchunks_exact</code></a></p>
<h5 id="panics-20"><a href="#panics-20">Panics</a></h5>
<p>Panics if <code>chunk_size</code> is 0.</p>
<h5 id="examples-71"><a href="#examples-71">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>slice = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="kw">let </span><span class="kw-2">mut </span>iter = slice.rchunks_exact(<span class="number">2</span>);
<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>]);
<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>]);
<span class="macro">assert!</span>(iter.next().is_none());
<span class="macro">assert_eq!</span>(iter.remainder(), <span class="macro">bits!</span>[<span class="number">0</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.rchunks_exact_mut" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#1135-1141">source</a><h4 class="code-header">pub fn <a href="#method.rchunks_exact_mut" class="fnname">rchunks_exact_mut</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self,<br>&nbsp;&nbsp;&nbsp;&nbsp;chunk_size: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a><br>) -&gt; <a class="struct" href="../slice/struct.RChunksExactMut.html" title="struct bitvec::slice::RChunksExactMut">RChunksExactMut</a>&lt;'_, O, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../slice/struct.RChunksExactMut.html" title="struct bitvec::slice::RChunksExactMut">RChunksExactMut</a>&lt;'a, O, T&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../slice/struct.RChunksExactMut.html" title="struct bitvec::slice::RChunksExactMut">RChunksExactMut</a>&lt;'a, O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>&gt;;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Returns an iterator over <code>chunk_size</code> bits of the slice at a time,
starting at the end of the slice.</p>
<p>The chunks are mutable slices, and do not overlap. If <code>chunk_size</code> does
not divide the length of the slice, then the last up to <code>chunk_size-1</code>
bits will be omitted and can be retrieved from the <a href="../slice/struct.ChunksExactMut.html#method.into_remainder"><code>.into_remainder()</code></a>
method of the iterator.</p>
<p>Due to each chunk having exactly <code>chunk_size</code> bits, the compiler may be
able to optimize the resulting code better than in the case of
<a href="../slice/struct.BitSlice.html#method.rchunks_mut"><code>.rchunks_mut()</code></a>.</p>
<p>See <a href="../slice/struct.BitSlice.html#method.rchunks_mut"><code>.rchunks_mut()</code></a> for a variant of this iterator that also returns
the remainder as a smaller chunk, and <a href="../slice/struct.BitSlice.html#method.chunks_exact_mut"><code>.chunks_exact_mut()</code></a> for the
same iterator but starting at the beginning of the slice.</p>
<h5 id="original-63"><a href="#original-63">Original</a></h5>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.rchunks_exact_mut"><code>slice::rchunks_exact_mut</code></a></p>
<h5 id="api-differences-25"><a href="#api-differences-25">API Differences</a></h5>
<p>This iterator marks each yielded item as aliased, as iterators can be
used to yield multiple items into the same scope. If you are using
the iterator in a manner that ensures that all yielded items have
disjoint lifetimes, you can use the <a href="../slice/struct.ChunksExactMut.html#method.remove_alias"><code>.remove_alias()</code></a> adapter on it to
remove the alias marker from the yielded subslices.</p>
<h5 id="panics-21"><a href="#panics-21">Panics</a></h5>
<p>Panics if <code>chunk_size</code> is 0.</p>
<h5 id="examples-72"><a href="#examples-72">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>v = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>; <span class="number">5</span>];

<span class="kw">for </span>chunk <span class="kw">in </span>v.rchunks_exact_mut(<span class="number">2</span>) {
  chunk.set_all(<span class="bool-val">true</span>);
}
<span class="macro">assert_eq!</span>(v, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.split_at" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#1191-1195">source</a><h4 class="code-header">pub fn <a href="#method.split_at" class="fnname">split_at</a>(&amp;self, mid: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>) -&gt; (<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;</a>Self, <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;</a>Self)</h4></section></summary><div class="docblock"><p>Divides one slice into two at an index.</p>
<p>The first will contain all indices from <code>[0, mid)</code> (excluding the index
<code>mid</code> itself) and the second will contain all indices from <code>[mid, len)</code>
(excluding the index <code>len</code> itself).</p>
<h5 id="original-64"><a href="#original-64">Original</a></h5>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.split_at"><code>slice::split_at</code></a></p>
<h5 id="panics-22"><a href="#panics-22">Panics</a></h5>
<p>Panics if <code>mid &gt; len</code>.</p>
<h5 id="behavior-1"><a href="#behavior-1">Behavior</a></h5>
<p>When <code>mid</code> is <code>0</code> or <code>self.len()</code>, then the left or right return values,
respectively, are empty slices. Empty slice references produced by this
method are specified to have the address information you would expect:
a left empty slice has the same base address and start bit as <code>self</code>,
and a right empty slice will have its address raised by <code>self.len()</code>.</p>
<h5 id="examples-73"><a href="#examples-73">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>v = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>];

{
  <span class="kw">let </span>(left, right) = v.split_at(<span class="number">0</span>);
  <span class="macro">assert_eq!</span>(left, <span class="macro">bits!</span>[]);
  <span class="macro">assert_eq!</span>(right, v);
}

{
  <span class="kw">let </span>(left, right) = v.split_at(<span class="number">2</span>);
  <span class="macro">assert_eq!</span>(left, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>]);
  <span class="macro">assert_eq!</span>(right, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]);
}

{
  <span class="kw">let </span>(left, right) = v.split_at(<span class="number">6</span>);
  <span class="macro">assert_eq!</span>(left, v);
  <span class="macro">assert_eq!</span>(right, <span class="macro">bits!</span>[]);
}</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.split_at_mut" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#1264-1270">source</a><h4 class="code-header">pub fn <a href="#method.split_at_mut" class="fnname">split_at_mut</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self,<br>&nbsp;&nbsp;&nbsp;&nbsp;mid: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a><br>) -&gt; (&amp;mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>&gt;, &amp;mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>&gt;)</h4></section></summary><div class="docblock"><p>Divides one mutable slice into two at an index.</p>
<p>The first will contain all indices from <code>[0, mid)</code> (excluding the index
<code>mid</code> itself) and the second will contain all indices from <code>[mid, len)</code>
(excluding the index <code>len</code> itself).</p>
<h5 id="original-65"><a href="#original-65">Original</a></h5>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.split_at_mut"><code>slice::split_at_mut</code></a></p>
<h5 id="api-differences-26"><a href="#api-differences-26">API Differences</a></h5>
<p>The partition index <code>mid</code> may occur anywhere in the slice, and as a
result the two returned slices may both have write access to the memory
address containing <code>mid</code>. As such, the returned slices must be marked
with <a href="../store/trait.BitStore.html#associatedtype.Alias"><code>T::Alias</code></a> in order to correctly manage memory access going
forward.</p>
<p>This marking is applied to all memory accesses in both slices,
regardless of whether any future accesses actually require it. To limit
the alias marking to only the addresses that need it, use
[<code>.bit_domain()</code>] or [<code>.bit_domain_mut()</code>] to split either slice into
its aliased and unaliased subslices.</p>
<h5 id="panics-23"><a href="#panics-23">Panics</a></h5>
<p>Panics if <code>mid &gt; len</code>.</p>
<h5 id="behavior-2"><a href="#behavior-2">Behavior</a></h5>
<p>When <code>mid</code> is <code>0</code> or <code>self.len()</code>, then the left or right return values,
respectively, are empty slices. Empty slice references produced by this
method are specified to have the address information you would expect:
a left empty slice has the same base address and start bit as <code>self</code>,
and a right empty slice will have its address raised by <code>self.len()</code>.</p>
<h5 id="examples-74"><a href="#examples-74">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>v = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="comment">// scoped to restrict the lifetime of the borrows
</span>{
  <span class="kw">let </span>(left, right) = v.split_at_mut(<span class="number">2</span>);
  <span class="macro">assert_eq!</span>(left, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>]);
  <span class="macro">assert_eq!</span>(right, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]);

  left.set(<span class="number">1</span>, <span class="bool-val">true</span>);
  right.set(<span class="number">1</span>, <span class="bool-val">false</span>);
}
{
  <span class="kw">let </span><span class="kw-2">mut </span>v = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>; <span class="number">0</span>];
  <span class="kw">let </span>(left, right) = v.split_at_mut(<span class="number">0</span>);
  <span class="macro">assert!</span>(left.is_empty());
  <span class="macro">assert!</span>(right.is_empty());
}
<span class="macro">assert_eq!</span>(v, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.split" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#1329-1332">source</a><h4 class="code-header">pub fn <a href="#method.split" class="fnname">split</a>&lt;F&gt;(&amp;self, pred: F) -&gt; <a class="struct" href="../slice/struct.Split.html" title="struct bitvec::slice::Split">Split</a>&lt;'_, O, T, F&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../slice/struct.Split.html" title="struct bitvec::slice::Split">Split</a>&lt;'a, O, T, P&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T, P&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../slice/struct.Split.html" title="struct bitvec::slice::Split">Split</a>&lt;'a, O, T, P&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a>,</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;;</span></code></span></span></span></span><span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a>,</span></h4></section></summary><div class="docblock"><p>Returns an iterator over subslices separated by bits that match <code>pred</code>.
The matched bit is not contained in the subslices.</p>
<h5 id="original-66"><a href="#original-66">Original</a></h5>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.split"><code>slice::split</code></a></p>
<h5 id="api-differences-27"><a href="#api-differences-27">API Differences</a></h5>
<p>In order to allow more than one bit of information for the split
decision, the predicate receives the index of each bit, as well as its
value.</p>
<h5 id="examples-75"><a href="#examples-75">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>slice = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="kw">let </span><span class="kw-2">mut </span>iter = slice.split(|pos, _bit| pos % <span class="number">3 </span>== <span class="number">2</span>);

<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>]);
<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[<span class="number">0</span>]);
<span class="macro">assert!</span>(iter.next().is_none());</code></pre></div>
<p>If the first bit is matched, an empty slice will be the first item
returned by the iterator. Similarly, if the last bit in the slice is
matched, an empty slice will be the last item returned by the iterator:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>slice = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let </span><span class="kw-2">mut </span>iter = slice.split(|_pos, bit| <span class="kw-2">*</span>bit);

<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>]);
<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[]);
<span class="macro">assert!</span>(iter.next().is_none());</code></pre></div>
<p>If two matched bits are directly adjacent, an empty slice will be
present between them:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>slice = <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let </span><span class="kw-2">mut </span>iter = slice.split(|_pos, bit| !<span class="kw-2">*</span>bit);

<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[<span class="number">1</span>]);
<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[]);
<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[<span class="number">1</span>]);
<span class="macro">assert!</span>(iter.next().is_none());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.split_mut" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#1368-1371">source</a><h4 class="code-header">pub fn <a href="#method.split_mut" class="fnname">split_mut</a>&lt;F&gt;(&amp;mut self, pred: F) -&gt; <a class="struct" href="../slice/struct.SplitMut.html" title="struct bitvec::slice::SplitMut">SplitMut</a>&lt;'_, O, T, F&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../slice/struct.SplitMut.html" title="struct bitvec::slice::SplitMut">SplitMut</a>&lt;'a, O, T, P&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T, P&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../slice/struct.SplitMut.html" title="struct bitvec::slice::SplitMut">SplitMut</a>&lt;'a, O, T, P&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a>,</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>&gt;;</span></code></span></span></span></span><span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a>,</span></h4></section></summary><div class="docblock"><p>Returns an iterator over mutable subslices separated by bits that match
<code>pred</code>. The matched bit is not contained in the subslices.</p>
<h5 id="original-67"><a href="#original-67">Original</a></h5>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.split_mut"><code>slice::split_mut</code></a></p>
<h5 id="api-differences-28"><a href="#api-differences-28">API Differences</a></h5>
<p>In order to allow more than one bit of information for the split
decision, the predicate receives the index of each bit, as well as its
value.</p>
<p>This iterator marks each yielded item as aliased, as iterators can be
used to yield multiple items into the same scope. If you are using
the iterator in a manner that ensures that all yielded items have
disjoint lifetimes, you can use the <a href="../slice/struct.SplitMut.html#method.remove_alias"><code>.remove_alias()</code></a> adapter on it to
remove the alias marker from the yielded subslices.</p>
<h5 id="examples-76"><a href="#examples-76">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>v = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="kw">for </span>group <span class="kw">in </span>v.split_mut(|_pos, bit| <span class="kw-2">*</span>bit) {
  group.set(<span class="number">0</span>, <span class="bool-val">true</span>);
}
<span class="macro">assert_eq!</span>(v, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.rsplit" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#1418-1421">source</a><h4 class="code-header">pub fn <a href="#method.rsplit" class="fnname">rsplit</a>&lt;F&gt;(&amp;self, pred: F) -&gt; <a class="struct" href="../slice/struct.RSplit.html" title="struct bitvec::slice::RSplit">RSplit</a>&lt;'_, O, T, F&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../slice/struct.RSplit.html" title="struct bitvec::slice::RSplit">RSplit</a>&lt;'a, O, T, P&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T, P&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../slice/struct.RSplit.html" title="struct bitvec::slice::RSplit">RSplit</a>&lt;'a, O, T, P&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a>,</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;;</span></code></span></span></span></span><span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a>,</span></h4></section></summary><div class="docblock"><p>Returns an iterator over subslices separated by bits that match <code>pred</code>,
starting at the end of the slice and working backwards. The matched bit
is not contained in the subslices.</p>
<h5 id="original-68"><a href="#original-68">Original</a></h5>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.rsplit"><code>slice::rsplit</code></a></p>
<h5 id="api-differences-29"><a href="#api-differences-29">API Differences</a></h5>
<p>In order to allow more than one bit of information for the split
decision, the predicate receives the index of each bit, as well as its
value.</p>
<h5 id="examples-77"><a href="#examples-77">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>slice = <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="kw">let </span><span class="kw-2">mut </span>iter = slice.rsplit(|_pos, bit| !<span class="kw-2">*</span>bit);

<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[<span class="number">1</span>; <span class="number">2</span>]);
<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[<span class="number">1</span>; <span class="number">3</span>]);
<span class="macro">assert!</span>(iter.next().is_none());</code></pre></div>
<p>As with <a href="../slice/struct.BitSlice.html#method.split"><code>.split()</code></a>, if the first or last bit is matched, an empty
slice will be the first (or last) item returned by the iterator.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>v = <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let </span><span class="kw-2">mut </span>it = v.rsplit(|_pos, bit| <span class="kw-2">*</span>bit);
<span class="macro">assert_eq!</span>(it.next().unwrap(), <span class="macro">bits!</span>[]);
<span class="macro">assert_eq!</span>(it.next().unwrap(), <span class="macro">bits!</span>[<span class="number">0</span>; <span class="number">2</span>]);
<span class="macro">assert_eq!</span>(it.next().unwrap(), <span class="macro">bits!</span>[<span class="number">0</span>; <span class="number">2</span>]);
<span class="macro">assert_eq!</span>(it.next().unwrap(), <span class="macro">bits!</span>[]);
<span class="macro">assert!</span>(it.next().is_none());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.rsplit_mut" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#1458-1461">source</a><h4 class="code-header">pub fn <a href="#method.rsplit_mut" class="fnname">rsplit_mut</a>&lt;F&gt;(&amp;mut self, pred: F) -&gt; <a class="struct" href="../slice/struct.RSplitMut.html" title="struct bitvec::slice::RSplitMut">RSplitMut</a>&lt;'_, O, T, F&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../slice/struct.RSplitMut.html" title="struct bitvec::slice::RSplitMut">RSplitMut</a>&lt;'a, O, T, P&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T, P&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../slice/struct.RSplitMut.html" title="struct bitvec::slice::RSplitMut">RSplitMut</a>&lt;'a, O, T, P&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a>,</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>&gt;;</span></code></span></span></span></span><span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a>,</span></h4></section></summary><div class="docblock"><p>Returns an iterator over mutable subslices separated by bits that match
<code>pred</code>, starting at the end of the slice and working backwards. The
matched bit is not contained in the subslices.</p>
<h5 id="original-69"><a href="#original-69">Original</a></h5>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.rsplit_mut"><code>slice::rsplit_mut</code></a></p>
<h5 id="api-differences-30"><a href="#api-differences-30">API Differences</a></h5>
<p>In order to allow more than one bit of information for the split
decision, the predicate receives the index of each bit, as well as its
value.</p>
<p>This iterator marks each yielded item as aliased, as iterators can be
used to yield multiple items into the same scope. If you are using
the iterator in a manner that ensures that all yielded items have
disjoint lifetimes, you can use the <a href="../slice/struct.RSplitMut.html#method.remove_alias"><code>.remove_alias()</code></a> adapter on it to
remove the alias marker from the yielded subslices.</p>
<h5 id="examples-78"><a href="#examples-78">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>v = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="kw">for </span>group <span class="kw">in </span>v.rsplit_mut(|_pos, bit| <span class="kw-2">*</span>bit) {
  group.set(<span class="number">0</span>, <span class="bool-val">true</span>);
}
<span class="macro">assert_eq!</span>(v, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.splitn" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#1496-1499">source</a><h4 class="code-header">pub fn <a href="#method.splitn" class="fnname">splitn</a>&lt;F&gt;(&amp;self, n: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>, pred: F) -&gt; <a class="struct" href="../slice/struct.SplitN.html" title="struct bitvec::slice::SplitN">SplitN</a>&lt;'_, O, T, F&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../slice/struct.SplitN.html" title="struct bitvec::slice::SplitN">SplitN</a>&lt;'a, O, T, P&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T, P&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../slice/struct.SplitN.html" title="struct bitvec::slice::SplitN">SplitN</a>&lt;'a, O, T, P&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a>,</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &lt;<a class="struct" href="../slice/struct.Split.html" title="struct bitvec::slice::Split">Split</a>&lt;'a, O, T, P&gt; as <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>;</span></code></span></span></span></span><span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a>,</span></h4></section></summary><div class="docblock"><p>Returns an iterator over subslices separated by bits that match <code>pred</code>,
limited to returning at most <code>n</code> items. The matched bit is not contained
in the subslices.</p>
<p>The last item returned, if any, will contain the remainder of the slice.</p>
<h5 id="original-70"><a href="#original-70">Original</a></h5>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.splitn"><code>slice::splitn</code></a></p>
<h5 id="api-differences-31"><a href="#api-differences-31">API Differences</a></h5>
<p>In order to allow more than one bit of information for the split
decision, the predicate receives the index of each bit, as well as its
value.</p>
<h5 id="examples-79"><a href="#examples-79">Examples</a></h5>
<p>Print the slice split once by set bits (i.e., <code>[0, 0,]</code>, <code>[0, 1, 0]</code>):</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>v = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];

<span class="kw">for </span>group <span class="kw">in </span>v.splitn(<span class="number">2</span>, |_pos, bit| <span class="kw-2">*</span>bit) {
  <span class="macro">println!</span>(<span class="string">&quot;{:b}&quot;</span>, group);
}</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.splitn_mut" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#1539-1542">source</a><h4 class="code-header">pub fn <a href="#method.splitn_mut" class="fnname">splitn_mut</a>&lt;F&gt;(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>, pred: F) -&gt; <a class="struct" href="../slice/struct.SplitNMut.html" title="struct bitvec::slice::SplitNMut">SplitNMut</a>&lt;'_, O, T, F&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../slice/struct.SplitNMut.html" title="struct bitvec::slice::SplitNMut">SplitNMut</a>&lt;'a, O, T, P&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T, P&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../slice/struct.SplitNMut.html" title="struct bitvec::slice::SplitNMut">SplitNMut</a>&lt;'a, O, T, P&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a>,</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &lt;<a class="struct" href="../slice/struct.SplitMut.html" title="struct bitvec::slice::SplitMut">SplitMut</a>&lt;'a, O, T, P&gt; as <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>;</span></code></span></span></span></span><span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a>,</span></h4></section></summary><div class="docblock"><p>Returns an iterator over subslices separated by bits that match <code>pred</code>,
limited to returning at most <code>n</code> items. The matched bit is not contained
in the subslices.</p>
<p>The last item returned, if any, will contain the remainder of the slice.</p>
<h5 id="original-71"><a href="#original-71">Original</a></h5>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.splitn_mut"><code>slice::splitn_mut</code></a></p>
<h5 id="api-differences-32"><a href="#api-differences-32">API Differences</a></h5>
<p>In order to allow more than one bit of information for the split
decision, the predicate receives the index of each bit, as well as its
value.</p>
<p>This iterator marks each yielded item as aliased, as iterators can be
used to yield multiple items into the same scope. If you are using
the iterator in a manner that ensures that all yielded items have
disjoint lifetimes, you can use the <a href="../slice/struct.SplitNMut.html#method.remove_alias"><code>.remove_alias()</code></a> adapter on it to
remove the alias marker from the yielded subslices.</p>
<h5 id="examples-80"><a href="#examples-80">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>v = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];

<span class="kw">for </span>group <span class="kw">in </span>v.splitn_mut(<span class="number">2</span>, |_pos, bit| <span class="kw-2">*</span>bit) {
  group.set(<span class="number">0</span>, <span class="bool-val">true</span>);
}
<span class="macro">assert_eq!</span>(v, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.rsplitn" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#1579-1582">source</a><h4 class="code-header">pub fn <a href="#method.rsplitn" class="fnname">rsplitn</a>&lt;F&gt;(&amp;self, n: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>, pred: F) -&gt; <a class="struct" href="../slice/struct.RSplitN.html" title="struct bitvec::slice::RSplitN">RSplitN</a>&lt;'_, O, T, F&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../slice/struct.RSplitN.html" title="struct bitvec::slice::RSplitN">RSplitN</a>&lt;'a, O, T, P&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T, P&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../slice/struct.RSplitN.html" title="struct bitvec::slice::RSplitN">RSplitN</a>&lt;'a, O, T, P&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a>,</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &lt;<a class="struct" href="../slice/struct.RSplit.html" title="struct bitvec::slice::RSplit">RSplit</a>&lt;'a, O, T, P&gt; as <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>;</span></code></span></span></span></span><span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a>,</span></h4></section></summary><div class="docblock"><p>Returns an iterator over subslices separated by bits that match <code>pred</code>,
limited to returning at most <code>n</code> items. This starts at the end of the
slice and works backwards. The matched bit is not contained in the
subslices.</p>
<p>The last item returned, if any, will contain the remainder of the slice.</p>
<h5 id="original-72"><a href="#original-72">Original</a></h5>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.rsplitn"><code>slice::rsplitn</code></a></p>
<h5 id="api-differences-33"><a href="#api-differences-33">API Differences</a></h5>
<p>In order to allow more than one bit of information for the split
decision, the predicate receives the index of each bit, as well as its
value.</p>
<h5 id="examples-81"><a href="#examples-81">Examples</a></h5>
<p>Print the slice split once, starting from the end, by set bits (i.e.,
<code>[0]</code>, <code>[0, 0, 1, 0]</code>):</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>v = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];

<span class="kw">for </span>group <span class="kw">in </span>v.rsplitn(<span class="number">2</span>, |_pos, bit| <span class="kw-2">*</span>bit) {
  <span class="macro">println!</span>(<span class="string">&quot;{:b}&quot;</span>, group);
}</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.rsplitn_mut" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#1623-1626">source</a><h4 class="code-header">pub fn <a href="#method.rsplitn_mut" class="fnname">rsplitn_mut</a>&lt;F&gt;(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>, pred: F) -&gt; <a class="struct" href="../slice/struct.RSplitNMut.html" title="struct bitvec::slice::RSplitNMut">RSplitNMut</a>&lt;'_, O, T, F&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../slice/struct.RSplitNMut.html" title="struct bitvec::slice::RSplitNMut">RSplitNMut</a>&lt;'a, O, T, P&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T, P&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../slice/struct.RSplitNMut.html" title="struct bitvec::slice::RSplitNMut">RSplitNMut</a>&lt;'a, O, T, P&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a>,</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &lt;<a class="struct" href="../slice/struct.RSplitMut.html" title="struct bitvec::slice::RSplitMut">RSplitMut</a>&lt;'a, O, T, P&gt; as <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>;</span></code></span></span></span></span><span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a>,</span></h4></section></summary><div class="docblock"><p>Returns an iterator over subslices separated by bits that match <code>pred</code>,
limited to returning at most <code>n</code> items. This starts at the end of the
slice and works backwards. The matched bit is not contained in the
subslices.</p>
<p>The last item returned, if any, will contain the remainder of the slice.</p>
<h5 id="original-73"><a href="#original-73">Original</a></h5>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.rsplitn_mut"><code>slice::rsplitn_mut</code></a></p>
<h5 id="api-differences-34"><a href="#api-differences-34">API Differences</a></h5>
<p>In order to allow more than one bit of information for the split
decision, the predicate receives the index of each bit, as well as its
value.</p>
<p>This iterator marks each yielded item as aliased, as iterators can be
used to yield multiple items into the same scope. If you are using
the iterator in a manner that ensures that all yielded items have
disjoint lifetimes, you can use the <a href="../slice/struct.RSplitNMut.html#method.remove_alias"><code>.remove_alias()</code></a> adapter on it to
remove the alias marker from the yielded subslices.</p>
<h5 id="examples-82"><a href="#examples-82">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>v = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];

<span class="kw">for </span>group <span class="kw">in </span>v.rsplitn_mut(<span class="number">2</span>, |_pos, bit| <span class="kw-2">*</span>bit) {
  group.set(<span class="number">0</span>, <span class="bool-val">true</span>);
}
<span class="macro">assert_eq!</span>(v, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.contains" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#1663-1673">source</a><h4 class="code-header">pub fn <a href="#method.contains" class="fnname">contains</a>&lt;O2, T2&gt;(&amp;self, x: &amp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O2, T2&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a><span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h4></section></summary><div class="docblock"><p>Returns <code>true</code> if the slice contains a subslice that matches the given
span.</p>
<h5 id="original-74"><a href="#original-74">Original</a></h5>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.contains"><code>slice::contains</code></a></p>
<h5 id="api-differences-35"><a href="#api-differences-35">API Differences</a></h5>
<p>This searches for a matching subslice (allowing different type
parameters) rather than for a specific bit. Searching for a contained
element with a given value is not as useful on a collection of <code>bool</code>.</p>
<p>Furthermore, <code>BitSlice</code> defines <a href="../slice/struct.BitSlice.html#method.any"><code>any</code></a> and <a href="../slice/struct.BitSlice.html#method.not_all"><code>not_all</code></a>, which are
optimized searchers for any <code>true</code> or <code>false</code> bit, respectively, in a
sequence.</p>
<h5 id="examples-83"><a href="#examples-83">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>data = <span class="number">0b0101_1010u8</span>;
<span class="kw">let </span>bits_msb = data.view_bits::&lt;Msb0&gt;();
<span class="kw">let </span>bits_lsb = data.view_bits::&lt;Lsb0&gt;();
<span class="macro">assert!</span>(bits_msb.contains(<span class="kw-2">&amp;</span>bits_lsb[<span class="number">1 </span>.. <span class="number">5</span>]));</code></pre></div>
<p>This example uses a palindrome pattern to demonstrate that the slice
being searched for does not need to have the same type parameters as the
slice being searched.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.starts_with" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#1704-1711">source</a><h4 class="code-header">pub fn <a href="#method.starts_with" class="fnname">starts_with</a>&lt;O2, T2&gt;(&amp;self, needle: &amp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O2, T2&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a><span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h4></section></summary><div class="docblock"><p>Returns <code>true</code> if <code>needle</code> is a prefix of the slice.</p>
<h5 id="original-75"><a href="#original-75">Original</a></h5>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.starts_with"><code>slice::starts_with</code></a></p>
<h5 id="examples-84"><a href="#examples-84">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>v = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="macro">assert!</span>(v.starts_with(<span class="macro">bits!</span>[<span class="number">0</span>]));
<span class="macro">assert!</span>(v.starts_with(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>]));
<span class="macro">assert!</span>(!v.starts_with(<span class="macro">bits!</span>[<span class="number">1</span>]));
<span class="macro">assert!</span>(!v.starts_with(<span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>]));</code></pre></div>
<p>Always returns <code>true</code> if <code>needle</code> is an empty slice:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>v = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="macro">assert!</span>(v.starts_with(<span class="macro">bits!</span>[]));
<span class="kw">let </span>v = <span class="macro">bits!</span>[];
<span class="macro">assert!</span>(v.starts_with(<span class="macro">bits!</span>[]));</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.ends_with" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#1742-1750">source</a><h4 class="code-header">pub fn <a href="#method.ends_with" class="fnname">ends_with</a>&lt;O2, T2&gt;(&amp;self, needle: &amp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O2, T2&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a><span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h4></section></summary><div class="docblock"><p>Returns <code>true</code> if <code>needle</code> is a suffix of the slice.</p>
<h5 id="original-76"><a href="#original-76">Original</a></h5>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.ends_with"><code>slice::ends_with</code></a></p>
<h5 id="examples-85"><a href="#examples-85">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>v = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="macro">assert!</span>(v.ends_with(<span class="macro">bits!</span>[<span class="number">0</span>]));
<span class="macro">assert!</span>(v.ends_with(<span class="macro">bits!</span>[<span class="number">0</span>; <span class="number">2</span>]));
<span class="macro">assert!</span>(!v.ends_with(<span class="macro">bits!</span>[<span class="number">1</span>]));
<span class="macro">assert!</span>(!v.ends_with(<span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>]));</code></pre></div>
<p>Always returns <code>true</code> if <code>needle</code> is an empty slice:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>v = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="macro">assert!</span>(v.ends_with(<span class="macro">bits!</span>[]));
<span class="kw">let </span>v = <span class="macro">bits!</span>[];
<span class="macro">assert!</span>(v.ends_with(<span class="macro">bits!</span>[]));</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.rotate_left" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#1792-1825">source</a><h4 class="code-header">pub fn <a href="#method.rotate_left" class="fnname">rotate_left</a>(&amp;mut self, by: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Rotates the slice in-place such that the first <code>by</code> bits of the slice
move to the end while the last <code>self.len() - by</code> bits move to the
front. After calling <code>.rotate_left()</code>, the bit previously at index <code>by</code>
will become the first bit in the slice.</p>
<h5 id="original-77"><a href="#original-77">Original</a></h5>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#rotate_left"><code>slice::rotate_left</code></a></p>
<h5 id="panics-24"><a href="#panics-24">Panics</a></h5>
<p>This function will panic if <code>by</code> is greater than the length of the
slice. Note that <code>by == self.len()</code> does <em>not</em> panic and is a noöp.</p>
<h5 id="complexity"><a href="#complexity">Complexity</a></h5>
<p>Takes linear (in <a href="../slice/struct.BitSlice.html#method.len"><code>self.len()</code></a>) time.</p>
<h5 id="examples-86"><a href="#examples-86">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>a = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];
a.rotate_left(<span class="number">2</span>);
<span class="macro">assert_eq!</span>(a, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]);</code></pre></div>
<p>Rotating a subslice:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>a = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>];
a[<span class="number">1 </span>.. <span class="number">5</span>].rotate_left(<span class="number">1</span>);
<span class="macro">assert_eq!</span>(a, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.rotate_right" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#1867-1889">source</a><h4 class="code-header">pub fn <a href="#method.rotate_right" class="fnname">rotate_right</a>(&amp;mut self, by: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Rotates the slice in-place such that the first <code>self.len() - by</code> bits of
the slice move to the end while the last <code>by</code> bits move to the front.
After calling <code>.rotate_right()</code>, the bit previously at index `self.len()</p>
<ul>
<li>by` will become the first bit in the slice.</li>
</ul>
<h5 id="original-78"><a href="#original-78">Original</a></h5>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#rotate_right"><code>slice::rotate_right</code></a></p>
<h5 id="panics-25"><a href="#panics-25">Panics</a></h5>
<p>This function will panic if <code>by</code> is greater than the length of the
slice. Note that <code>by == self.len()</code> does <em>not</em> panic and is a noöp.</p>
<h5 id="complexity-1"><a href="#complexity-1">Complexity</a></h5>
<p>Takes linear (in <a href="../slice/struct.BitSlice.html#method.len"><code>self.len()</code></a>) time.</p>
<h5 id="examples-87"><a href="#examples-87">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>a = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>];
a.rotate_right(<span class="number">2</span>);
<span class="macro">assert_eq!</span>(a, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]);</code></pre></div>
<p>Rotating a subslice:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>a = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>];
a[<span class="number">1 </span>.. <span class="number">5</span>].rotate_right(<span class="number">1</span>);
<span class="macro">assert_eq!</span>(a, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.copy_within" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#1943-1954">source</a><h4 class="code-header">pub fn <a href="#method.copy_within" class="fnname">copy_within</a>&lt;R&gt;(&amp;mut self, src: R, dest: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>)<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;R: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/range/trait.RangeBounds.html" title="trait core::ops::range::RangeBounds">RangeBounds</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>&gt;,</span></h4></section></summary><div class="docblock"><p>Copies bits from one part of the slice to another part of itself.</p>
<p><code>src</code> is the range within <code>self</code> to copy from. <code>dest</code> is the starting
index of the range within <code>self</code> to copy to, which will have the same
length as <code>src</code>. The two ranges may overlap. The ends of the two ranges
must be less than or equal to <a href="../slice/struct.BitSlice.html#method.len"><code>self.len()</code></a>.</p>
<h5 id="original-79"><a href="#original-79">Original</a></h5>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.copy_within"><code>slice::copy_within</code></a></p>
<h5 id="panics-26"><a href="#panics-26">Panics</a></h5>
<p>This function will panic if either range exceeds the end of the slice,
or if the end of <code>src</code> is before the start.</p>
<h5 id="examples-88"><a href="#examples-88">Examples</a></h5>
<p>Copying four bits within a slice:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>];

bits.copy_within(<span class="number">1 </span>.. <span class="number">5</span>, <span class="number">8</span>);

<span class="macro">assert_eq!</span>(bits, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.align_to" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#2037-2045">source</a><h4 class="code-header">pub unsafe fn <a href="#method.align_to" class="fnname">align_to</a>&lt;U&gt;(&amp;self) -&gt; (<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;</a>Self, &amp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, U&gt;, <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;</a>Self)<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h4></section></summary><div class="docblock"><p>Transmute the bit-slice to a bit-slice of another type, ensuring
alignment of the types is maintained.</p>
<h5 id="original-80"><a href="#original-80">Original</a></h5>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.align_to"><code>slice::align_to</code></a></p>
<h5 id="api-differences-36"><a href="#api-differences-36">API Differences</a></h5>
<p>Type <code>U</code> is <strong>required</strong> to have the same <a href="../store/trait.BitStore.html"><code>BitStore</code></a> type family as
type <code>T</code>. If <code>T</code> is a fundamental integer, so must <code>U</code> be; if <code>T</code> is an
<a href="../store/trait.BitStore.html#associatedtype.Alias"><code>::Alias</code></a> type, then so must <code>U</code>. Changing the type family with this
method is <strong>unsound</strong> and strictly forbidden. Unfortunately, this cannot
be encoded in the type system, so you are required to abide by this
limitation yourself.</p>
<h5 id="implementation"><a href="#implementation">Implementation</a></h5>
<p>The algorithm used to implement this function attempts to create the
widest possible span for the middle slice. However, the slice divisions
must abide by the <a href="../domain/enum.Domain.html"><code>Domain</code></a> restrictions: the left and right slices
produced by this function will include the head and tail elements of the
domain (if present), as well as the left and right subslices (if any)
produced by calling <a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.align_to"><code>slice::align_to</code></a> on the domain body (if present).</p>
<p>The standard library implementation currently maximizes the width of the
center slice, but its API does not guarantee this property, and retains
the right to produce pessimal slices. As such, this function cannot
guarantee maximal center slice width either, and you cannot rely on this
behavior for <em>correctness</em> of your work; it is only a possible
performance improvement.</p>
<h5 id="safety-3"><a href="#safety-3">Safety</a></h5>
<p>This method is essentially a <a href="https://doc.rust-lang.org/1.65.0/core/intrinsics/fn.transmute.html"><code>mem::transmute</code></a> with respect to the
memory region in the returned middle slice, so all of the usual caveats
pertaining to <a href="https://doc.rust-lang.org/1.65.0/core/intrinsics/fn.transmute.html"><code>mem::transmute::&lt;T, U&gt;</code></a> also apply here.</p>
<h5 id="examples-89"><a href="#examples-89">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">unsafe </span>{
  <span class="kw">let </span>bytes: [u8; <span class="number">7</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];
  <span class="kw">let </span>bits = bytes.view_bits::&lt;LocalBits&gt;();
  <span class="kw">let </span>(prefix, shorts, suffix) = bits.align_to::&lt;u16&gt;();
  <span class="kw">match </span>prefix.len() {
    <span class="number">0 </span>=&gt; {
      <span class="macro">assert_eq!</span>(shorts, bits[.. <span class="number">48</span>]);
      <span class="macro">assert_eq!</span>(suffix, bits[<span class="number">48 </span>..]);
    },
    <span class="number">8 </span>=&gt; {
      <span class="macro">assert_eq!</span>(prefix, bits[.. <span class="number">8</span>]);
      <span class="macro">assert_eq!</span>(shorts, bits[<span class="number">8 </span>..]);
    },
    <span class="kw">_ </span>=&gt; <span class="macro">unreachable!</span>(<span class="string">&quot;This case will not occur&quot;</span>)
  }
}</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.align_to_mut" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#2107-2117">source</a><h4 class="code-header">pub unsafe fn <a href="#method.align_to_mut" class="fnname">align_to_mut</a>&lt;U&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self<br>) -&gt; (<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;mut </a>Self, &amp;mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, U&gt;, <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;mut </a>Self)<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h4></section></summary><div class="docblock"><p>Transmute the bit-slice to a bit-slice of another type, ensuring
alignment of the types is maintained.</p>
<h5 id="original-81"><a href="#original-81">Original</a></h5>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.align_to_mut"><code>slice::align_to_mut</code></a></p>
<h5 id="api-differences-37"><a href="#api-differences-37">API Differences</a></h5>
<p>Type <code>U</code> is <strong>required</strong> to have the same <a href="../store/trait.BitStore.html"><code>BitStore</code></a> type family as
type <code>T</code>. If <code>T</code> is a fundamental integer, so must <code>U</code> be; if <code>T</code> is an
<a href="../store/trait.BitStore.html#associatedtype.Alias"><code>::Alias</code></a> type, then so must <code>U</code>. Changing the type family with this
method is <strong>unsound</strong> and strictly forbidden. Unfortunately, this cannot
be encoded in the type system, so you are required to abide by this
limitation yourself.</p>
<h5 id="implementation-1"><a href="#implementation-1">Implementation</a></h5>
<p>The algorithm used to implement this function attempts to create the
widest possible span for the middle slice. However, the slice divisions
must abide by the <a href="../domain/enum.DomainMut.html"><code>DomainMut</code></a> restrictions: the left and right slices
produced by this function will include the head and tail elements of the
domain (if present), as well as the left and right subslices (if any)
produced by calling <a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.align_to_mut"><code>slice::align_to_mut</code></a> on the domain body (if
present).</p>
<p>The standard library implementation currently maximizes the width of the
center slice, but its API does not guarantee this property, and retains
the right to produce pessimal slices. As such, this function cannot
guarantee maximal center slice width either, and you cannot rely on this
behavior for <em>correctness</em> of your work; it is only a possible
performance improvement.</p>
<h5 id="safety-4"><a href="#safety-4">Safety</a></h5>
<p>This method is essentially a <a href="https://doc.rust-lang.org/1.65.0/core/intrinsics/fn.transmute.html"><code>mem::transmute</code></a> with respect to the
memory region in the returned middle slice, so all of the usual caveats
pertaining to <a href="https://doc.rust-lang.org/1.65.0/core/intrinsics/fn.transmute.html"><code>mem::transmute::&lt;T, U&gt;</code></a> also apply here.</p>
<h5 id="examples-90"><a href="#examples-90">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">unsafe </span>{
  <span class="kw">let </span><span class="kw-2">mut </span>bytes: [u8; <span class="number">7</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];
  <span class="kw">let </span>bits = bytes.view_bits_mut::&lt;LocalBits&gt;();
  <span class="kw">let </span>(prefix, shorts, suffix) = bits.align_to_mut::&lt;u16&gt;();
  <span class="comment">//  same access and behavior as in `align_to`
</span>}</code></pre></div>
</div></details></div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.repeat-1" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice/api.rs.html#2167-2181">source</a><h4 class="code-header">pub fn <a href="#method.repeat-1" class="fnname">repeat</a>(&amp;self, n: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Unalias" title="type bitvec::store::BitStore::Unalias">Unalias</a>&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/std/io/trait.Write.html" title="trait std::io::Write">Write</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,</span></span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Creates a vector by repeating a slice <code>n</code> times.</p>
<h5 id="original-82"><a href="#original-82">Original</a></h5>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.repeat"><code>slice::repeat</code></a></p>
<h5 id="panics-27"><a href="#panics-27">Panics</a></h5>
<p>This function will panic if the capacity would overflow.</p>
<h5 id="examples-91"><a href="#examples-91">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>].repeat(<span class="number">3</span>), <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]);</code></pre></div>
<p>A panic upon overflow:</p>

<div class="example-wrap should_panic"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="comment">// this will panic at runtime
</span><span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>].repeat(BitSlice::&lt;LocalBits, usize&gt;::MAX_BITS);</code></pre></div>
</div></details></div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.set" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#803-808">source</a><h4 class="code-header">pub fn <a href="#method.set" class="fnname">set</a>(&amp;mut self, index: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>, value: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a>)</h4></section></summary><div class="docblock"><p>Writes a new bit at a given index.</p>
<h5 id="parameters-5"><a href="#parameters-5">Parameters</a></h5>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>index</code>: The bit index at which to write. It must be in the range <code>0 .. self.len()</code>.</li>
<li><code>value</code>: The value to be written; <code>true</code> for <code>1</code> or <code>false</code> for <code>0</code>.</li>
</ul>
<h5 id="effects"><a href="#effects">Effects</a></h5>
<p>If <code>index</code> is valid, then the bit to which it refers is set to <code>value</code>.</p>
<h5 id="panics-28"><a href="#panics-28">Panics</a></h5>
<p>This method panics if <code>index</code> is not less than <a href="../slice/struct.BitSlice.html#method.len"><code>self.len()</code></a>.</p>
<h5 id="examples-92"><a href="#examples-92">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>];

<span class="macro">assert!</span>(!bits[<span class="number">0</span>]);
bits.set(<span class="number">0</span>, <span class="bool-val">true</span>);
<span class="macro">assert!</span>(bits[<span class="number">0</span>]);</code></pre></div>
<p>This example panics when it attempts to set a bit that is out of bounds.</p>

<div class="example-wrap should_panic"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>];
bits.set(<span class="number">1</span>, <span class="bool-val">false</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.any" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#840-854">source</a><h4 class="code-header">pub fn <a href="#method.any" class="fnname">any</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Tests if <em>any</em> bit in the slice is set (logical <code>∨</code>).</p>
<h5 id="truth-table"><a href="#truth-table">Truth Table</a></h5><div class="example-wrap"><pre class="language-text"><code>0 0 =&gt; 0
0 1 =&gt; 1
1 0 =&gt; 1
1 1 =&gt; 1</code></pre></div><h5 id="parameters-6"><a href="#parameters-6">Parameters</a></h5>
<ul>
<li><code>&amp;self</code></li>
</ul>
<h5 id="returns-4"><a href="#returns-4">Returns</a></h5>
<p>Whether any bit in the slice domain is set. The empty slice returns
<code>false</code>.</p>
<h5 id="examples-93"><a href="#examples-93">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="macro">assert!</span>(bits[.. <span class="number">2</span>].any());
<span class="macro">assert!</span>(!bits[<span class="number">2 </span>..].any());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.all" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#886-914">source</a><h4 class="code-header">pub fn <a href="#method.all" class="fnname">all</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Tests if <em>all</em> bits in the slice domain are set (logical <code>∧</code>).</p>
<h5 id="truth-table-1"><a href="#truth-table-1">Truth Table</a></h5><div class="example-wrap"><pre class="language-text"><code>0 0 =&gt; 0
0 1 =&gt; 0
1 0 =&gt; 0
1 1 =&gt; 1</code></pre></div><h5 id="parameters-7"><a href="#parameters-7">Parameters</a></h5>
<ul>
<li><code>&amp;self</code></li>
</ul>
<h5 id="returns-5"><a href="#returns-5">Returns</a></h5>
<p>Whether all bits in the slice domain are set. The empty slice returns
<code>true</code>.</p>
<h5 id="examples-94"><a href="#examples-94">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="macro">assert!</span>(bits[.. <span class="number">2</span>].all());
<span class="macro">assert!</span>(!bits[<span class="number">2 </span>..].all());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.not_any" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#945-947">source</a><h4 class="code-header">pub fn <a href="#method.not_any" class="fnname">not_any</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Tests if <em>all</em> bits in the slice are unset (logical <code>¬∨</code>).</p>
<h5 id="truth-table-2"><a href="#truth-table-2">Truth Table</a></h5><div class="example-wrap"><pre class="language-text"><code>0 0 =&gt; 1
0 1 =&gt; 0
1 0 =&gt; 0
1 1 =&gt; 0</code></pre></div><h5 id="parameters-8"><a href="#parameters-8">Parameters</a></h5>
<ul>
<li><code>&amp;self</code></li>
</ul>
<h5 id="returns-6"><a href="#returns-6">Returns</a></h5>
<p>Whether all bits in the slice domain are unset.</p>
<h5 id="examples-95"><a href="#examples-95">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="macro">assert!</span>(!bits[.. <span class="number">2</span>].not_any());
<span class="macro">assert!</span>(bits[<span class="number">2 </span>..].not_any());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.not_all" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#978-980">source</a><h4 class="code-header">pub fn <a href="#method.not_all" class="fnname">not_all</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Tests if <em>any</em> bit in the slice is unset (logical <code>¬∧</code>).</p>
<h5 id="truth-table-3"><a href="#truth-table-3">Truth Table</a></h5><div class="example-wrap"><pre class="language-text"><code>0 0 =&gt; 1
0 1 =&gt; 1
1 0 =&gt; 1
1 1 =&gt; 0</code></pre></div><h5 id="parameters-9"><a href="#parameters-9">Parameters</a></h5>
<ul>
<li><code>&amp;self</code></li>
</ul>
<h5 id="returns-7"><a href="#returns-7">Returns</a></h5>
<p>Whether any bit in the slice domain is unset.</p>
<h5 id="examples-96"><a href="#examples-96">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="macro">assert!</span>(!bits[.. <span class="number">2</span>].not_all());
<span class="macro">assert!</span>(bits[<span class="number">2 </span>..].not_all());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.some" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#1021-1023">source</a><h4 class="code-header">pub fn <a href="#method.some" class="fnname">some</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Tests whether the slice has some, but not all, bits set and some, but
not all, bits unset.</p>
<p>This is <code>false</code> if either <a href="../slice/struct.BitSlice.html#method.all"><code>.all()</code></a> or <a href="../slice/struct.BitSlice.html#method.not_any"><code>.not_any()</code></a> are <code>true</code>.</p>
<h5 id="truth-table-4"><a href="#truth-table-4">Truth Table</a></h5><div class="example-wrap"><pre class="language-text"><code>0 0 =&gt; 0
0 1 =&gt; 1
1 0 =&gt; 1
1 1 =&gt; 0</code></pre></div><h5 id="parameters-10"><a href="#parameters-10">Parameters</a></h5>
<ul>
<li><code>&amp;self</code></li>
</ul>
<h5 id="returns-8"><a href="#returns-8">Returns</a></h5>
<p>Whether the slice domain has mixed content. The empty slice returns
<code>false</code>.</p>
<h5 id="examples-97"><a href="#examples-97">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>data = <span class="number">0b111_000_10u8</span>;
<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];

<span class="macro">assert!</span>(!bits[.. <span class="number">2</span>].some());
<span class="macro">assert!</span>(!bits[<span class="number">2 </span>.. <span class="number">4</span>].some());
<span class="macro">assert!</span>(bits.some());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.count_ones" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#1046-1068">source</a><h4 class="code-header">pub fn <a href="#method.count_ones" class="fnname">count_ones</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Counts the number of bits set to <code>1</code> in the slice contents.</p>
<h5 id="parameters-11"><a href="#parameters-11">Parameters</a></h5>
<ul>
<li><code>&amp;self</code></li>
</ul>
<h5 id="returns-9"><a href="#returns-9">Returns</a></h5>
<p>The number of bits in the slice domain that are set to <code>1</code>.</p>
<h5 id="examples-98"><a href="#examples-98">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="macro">assert_eq!</span>(bits[.. <span class="number">2</span>].count_ones(), <span class="number">2</span>);
<span class="macro">assert_eq!</span>(bits[<span class="number">2 </span>..].count_ones(), <span class="number">0</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.count_zeros" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#1091-1113">source</a><h4 class="code-header">pub fn <a href="#method.count_zeros" class="fnname">count_zeros</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Counts the number of bits cleared to <code>0</code> in the slice contents.</p>
<h5 id="parameters-12"><a href="#parameters-12">Parameters</a></h5>
<ul>
<li><code>&amp;self</code></li>
</ul>
<h5 id="returns-10"><a href="#returns-10">Returns</a></h5>
<p>The number of bits in the slice domain that are cleared to <code>0</code>.</p>
<h5 id="examples-99"><a href="#examples-99">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="macro">assert_eq!</span>(bits[.. <span class="number">2</span>].count_zeros(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(bits[<span class="number">2 </span>..].count_zeros(), <span class="number">2</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.iter_ones" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#1138-1140">source</a><h4 class="code-header">pub fn <a href="#method.iter_ones" class="fnname">iter_ones</a>(&amp;self) -&gt; <a class="struct" href="../slice/struct.IterOnes.html" title="struct bitvec::slice::IterOnes">IterOnes</a>&lt;'_, O, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../slice/struct.IterOnes.html" title="struct bitvec::slice::IterOnes">IterOnes</a>&lt;'_, O, T&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../slice/struct.IterOnes.html" title="struct bitvec::slice::IterOnes">IterOnes</a>&lt;'_, O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Enumerates all bits in a <code>BitSlice</code> that are set to <code>1</code>.</p>
<h5 id="examples-100"><a href="#examples-100">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let </span><span class="kw-2">mut </span>indices = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">8</span>].iter().copied();

<span class="kw">let </span><span class="kw-2">mut </span>iter_ones = bits.iter_ones();
<span class="kw">let </span><span class="kw-2">mut </span>compose = bits.iter()
  .copied()
  .enumerate()
  .filter_map(|(idx, bit)| <span class="kw">if </span>bit { <span class="prelude-val">Some</span>(idx) } <span class="kw">else </span>{ <span class="prelude-val">None </span>});

<span class="kw">for </span>((a, b), c) <span class="kw">in </span>iter_ones.zip(compose).zip(indices) {
  <span class="macro">assert_eq!</span>(a, b);
  <span class="macro">assert_eq!</span>(b, c);
}</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.iter_zeros" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#1165-1167">source</a><h4 class="code-header">pub fn <a href="#method.iter_zeros" class="fnname">iter_zeros</a>(&amp;self) -&gt; <a class="struct" href="../slice/struct.IterZeros.html" title="struct bitvec::slice::IterZeros">IterZeros</a>&lt;'_, O, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../slice/struct.IterZeros.html" title="struct bitvec::slice::IterZeros">IterZeros</a>&lt;'_, O, T&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../slice/struct.IterZeros.html" title="struct bitvec::slice::IterZeros">IterZeros</a>&lt;'_, O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Enumerates all bits in a <code>BitSlice</code> that are cleared to <code>0</code>.</p>
<h5 id="examples-101"><a href="#examples-101">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="kw">let </span><span class="kw-2">mut </span>indices = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">8</span>].iter().copied();

<span class="kw">let </span><span class="kw-2">mut </span>iter_zeros = bits.iter_zeros();
<span class="kw">let </span><span class="kw-2">mut </span>compose = bits.iter()
  .copied()
  .enumerate()
  .filter_map(|(idx, bit)| <span class="kw">if </span>!bit { <span class="prelude-val">Some</span>(idx) } <span class="kw">else </span>{ <span class="prelude-val">None </span>});

<span class="kw">for </span>((a, b), c) <span class="kw">in </span>iter_zeros.zip(compose).zip(indices) {
  <span class="macro">assert_eq!</span>(a, b);
  <span class="macro">assert_eq!</span>(b, c);
}</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.first_one" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#1180-1182">source</a><h4 class="code-header">pub fn <a href="#method.first_one" class="fnname">first_one</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.65.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Gets the index of the first bit in the bit-slice set to <code>1</code>.</p>
<h5 id="examples-102"><a href="#examples-102">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="macro">assert!</span>(<span class="macro">bits!</span>[].first_one().is_none());
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>].first_one().unwrap(), <span class="number">2</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.first_zero" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#1195-1197">source</a><h4 class="code-header">pub fn <a href="#method.first_zero" class="fnname">first_zero</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.65.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Gets the index of the first bit in the bit-slice set to <code>0</code>.</p>
<h5 id="examples-103"><a href="#examples-103">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="macro">assert!</span>(<span class="macro">bits!</span>[].first_zero().is_none());
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>].first_zero().unwrap(), <span class="number">2</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.last_one" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#1210-1212">source</a><h4 class="code-header">pub fn <a href="#method.last_one" class="fnname">last_one</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.65.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Gets the index of the last bit in the bit-slice set to <code>1</code>.</p>
<h5 id="examples-104"><a href="#examples-104">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="macro">assert!</span>(<span class="macro">bits!</span>[].last_one().is_none());
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>].last_one().unwrap(), <span class="number">3</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.last_zero" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#1225-1227">source</a><h4 class="code-header">pub fn <a href="#method.last_zero" class="fnname">last_zero</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.65.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Gets the index of the last bit in the bit-slice set to <code>0</code>.</p>
<h5 id="examples-105"><a href="#examples-105">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="macro">assert!</span>(<span class="macro">bits!</span>[].last_zero().is_none());
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>].last_zero().unwrap(), <span class="number">3</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.leading_ones" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#1244-1246">source</a><h4 class="code-header">pub fn <a href="#method.leading_ones" class="fnname">leading_ones</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Counts the number of bits from the start of the bit-slice to the first
bit set to <code>0</code>.</p>
<p>This returns <code>0</code> if the bit-slice is empty.</p>
<h5 id="examples-106"><a href="#examples-106">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[].leading_ones(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">0</span>].leading_ones(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>].leading_ones(), <span class="number">1</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.leading_zeros" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#1263-1265">source</a><h4 class="code-header">pub fn <a href="#method.leading_zeros" class="fnname">leading_zeros</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Counts the number of bits from the start of the bit-slice to the first
bit set to <code>1</code>.</p>
<p>This returns <code>0</code> if the bit-slice is empty.</p>
<h5 id="examples-107"><a href="#examples-107">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[].leading_zeros(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">1</span>].leading_zeros(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>].leading_zeros(), <span class="number">1</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.trailing_ones" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#1282-1286">source</a><h4 class="code-header">pub fn <a href="#method.trailing_ones" class="fnname">trailing_ones</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Counts the number of bits from the end of the bit-slice to the last bit
set to <code>0</code>.</p>
<p>This returns <code>0</code> if the bit-slice is empty.</p>
<h5 id="examples-108"><a href="#examples-108">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[].trailing_ones(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">0</span>].trailing_ones(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>].trailing_ones(), <span class="number">2</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.trailing_zeros" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#1303-1307">source</a><h4 class="code-header">pub fn <a href="#method.trailing_zeros" class="fnname">trailing_zeros</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Counts the number of bits from the end of the bit-slice to the last bit
set to <code>1</code>.</p>
<p>This returns <code>0</code> if the bit-slice is empty.</p>
<h5 id="examples-109"><a href="#examples-109">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[].trailing_zeros(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">1</span>].trailing_zeros(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>].trailing_zeros(), <span class="number">2</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.clone_from_bitslice" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#1382-1408">source</a><h4 class="code-header">pub fn <a href="#method.clone_from_bitslice" class="fnname">clone_from_bitslice</a>&lt;O2, T2&gt;(&amp;mut self, src: &amp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O2, T2&gt;)<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h4></section></summary><div class="docblock"><p>Copies the bits from <code>src</code> into <code>self</code>.</p>
<p>The length of <code>src</code> must be the same as `self.</p>
<p>If <code>src</code> has the same type arguments as <code>self</code>, it can be more
performant to use <a href="../slice/struct.BitSlice.html#method.copy_from_bitslice"><code>.copy_from_bitslice()</code></a>.</p>
<h5 id="original-83"><a href="#original-83">Original</a></h5>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.clone_from_bitslice"><code>slice::clone_from_bitslice</code></a></p>
<h5 id="api-differences-38"><a href="#api-differences-38">API Differences</a></h5>
<p>This method is renamed, as it takes a bit slice rather than an element
slice.</p>
<h5 id="panics-29"><a href="#panics-29">Panics</a></h5>
<p>This function will panic if the two slices have different lengths.</p>
<h5 id="examples-110"><a href="#examples-110">Examples</a></h5>
<p>Cloning two bits from a slice into another:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>src = <span class="macro">bits!</span>[Msb0, u16; <span class="number">1</span>; <span class="number">4</span>];
<span class="kw">let </span>dst = <span class="macro">bits!</span>[<span class="kw-2">mut </span>Lsb0, u8; <span class="number">0</span>; <span class="number">2</span>];

dst.clone_from_bitslice(<span class="kw-2">&amp;</span>src[<span class="number">2 </span>..]);
<span class="macro">assert_eq!</span>(dst, <span class="macro">bits!</span>[<span class="number">1</span>; <span class="number">2</span>]);</code></pre></div>
<p>Rust enforces that there can only be one mutable reference with no
immutable references to a particular piece of data in a particular
scope. Because of this, attempting to use clone_from_slice on a single
slice will result in a compile failure:</p>

<div class="example-wrap compile_fail"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>slice = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>];
slice[.. <span class="number">2</span>].clone_from_bitslice(<span class="kw-2">&amp;</span>slice[<span class="number">3 </span>..]); <span class="comment">// compile fail!</span></code></pre></div>
<p>To work around this, we can use <a href="../slice/struct.BitSlice.html#method.split_at_mut"><code>.split_at_mut()</code></a> to create two
distinct sub-slices from a slice:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>slice = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>];

{
  <span class="kw">let </span>(left, right) = slice.split_at_mut(<span class="number">2</span>);
  left.clone_from_bitslice(<span class="kw-2">&amp;</span>right[<span class="number">1 </span>..]);
}

<span class="macro">assert_eq!</span>(slice, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]);</code></pre></div>
<h5 id="performance-1"><a href="#performance-1">Performance</a></h5>
<p>If <code>self</code> and <code>src</code> use the same type arguments, this specializes to
<a href="../slice/struct.BitSlice.html#method.copy_from_bitslice"><code>.copy_from_bitslice()</code></a>; if you know statically that this is the case,
prefer to call that method directly and avoid the cost of detection at
runtime. Otherwise, this is a bit-by-bit crawl across both slices, which
is a slow process.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.copy_from_bitslice" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#1478-1583">source</a><h4 class="code-header">pub fn <a href="#method.copy_from_bitslice" class="fnname">copy_from_bitslice</a>(&amp;mut self, src: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;</a>Self)</h4></section></summary><div class="docblock"><p>Copies all bits from <code>src</code> into <code>self</code>, using a memcpy wherever
possible.</p>
<p>The length of <code>src</code> must be same as <code>self</code>.</p>
<p>If <code>src</code> does not use the same type arguments as <code>self</code>, use
<a href="../slice/struct.BitSlice.html#method.clone_from_bitslice"><code>.clone_from_bitslice()</code></a>.</p>
<h5 id="original-84"><a href="#original-84">Original</a></h5>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.copy_from_slice"><code>slice::copy_from_slice</code></a></p>
<h5 id="api-differences-39"><a href="#api-differences-39">API Differences</a></h5>
<p>This method is renamed, as it takes a bit slice rather than an element
slice.</p>
<h5 id="panics-30"><a href="#panics-30">Panics</a></h5>
<p>This function will panic if the two slices have different lengths.</p>
<h5 id="examples-111"><a href="#examples-111">Examples</a></h5>
<p>Copying two bits from a slice into another:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>src = <span class="macro">bits!</span>[<span class="number">1</span>; <span class="number">4</span>];
<span class="kw">let </span>dst = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>; <span class="number">2</span>];

<span class="comment">// Because the slices have to be the same length,
// we slice the source slice from four bits to
// two. It will panic if we don&#39;t do this.
</span>dst.clone_from_bitslice(<span class="kw-2">&amp;</span>src[<span class="number">2</span>..]);</code></pre></div>
<p>Rust enforces that there can only be one mutable reference with no
immutable references to a particular piece of data in a particular
scope. Because of this, attempting to use [.copy_from_slice()] on a
single slice will result in a compile failure:</p>

<div class="example-wrap compile_fail"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>slice = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>];

slice[.. <span class="number">2</span>].copy_from_bitslice(<span class="kw-2">&amp;</span>bits[<span class="number">3 </span>..]); <span class="comment">// compile fail!</span></code></pre></div>
<p>To work around this, we can use <a href="../slice/struct.BitSlice.html#method.split_at_mut"><code>.split_at_mut()</code></a> to create two
distinct sub-slices from a slice:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>slice = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>];

{
  <span class="kw">let </span>(left, right) = slice.split_at_mut(<span class="number">2</span>);
  left.copy_from_bitslice(<span class="kw-2">&amp;</span>right[<span class="number">1 </span>..]);
}

<span class="macro">assert_eq!</span>(slice, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.swap_with_bitslice" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#1620-1633">source</a><h4 class="code-header">pub fn <a href="#method.swap_with_bitslice" class="fnname">swap_with_bitslice</a>&lt;O2, T2&gt;(&amp;mut self, other: &amp;mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O2, T2&gt;)<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h4></section></summary><div class="docblock"><p>Swaps all bits in <code>self</code> with those in <code>other</code>.</p>
<p>The length of <code>other</code> must be the same as <code>self</code>.</p>
<h5 id="original-85"><a href="#original-85">Original</a></h5>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.swap_with_slice"><code>slice::swap_with_slice</code></a></p>
<h5 id="api-differences-40"><a href="#api-differences-40">API Differences</a></h5>
<p>This method is renamed, as it takes a bit slice rather than an element
slice.</p>
<h5 id="panics-31"><a href="#panics-31">Panics</a></h5>
<p>This function will panic if the two slices have different lengths.</p>
<h5 id="examples-112"><a href="#examples-112">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>one = [<span class="number">0xA5u8</span>, <span class="number">0x69</span>];
<span class="kw">let </span><span class="kw-2">mut </span>two = <span class="number">0x1234u16</span>;
<span class="kw">let </span>one_bits = one.view_bits_mut::&lt;Msb0&gt;();
<span class="kw">let </span>two_bits = two.view_bits_mut::&lt;Lsb0&gt;();

one_bits.swap_with_bitslice(two_bits);

<span class="macro">assert_eq!</span>(one, [<span class="number">0x2C</span>, <span class="number">0x48</span>]);
<span class="macro">assert_eq!</span>(two, <span class="number">0x96A5</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.shift_left" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#1661-1678">source</a><h4 class="code-header">pub fn <a href="#method.shift_left" class="fnname">shift_left</a>(&amp;mut self, by: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Shifts the contents of a bit-slice left (towards index <code>0</code>).</p>
<p>This moves the contents of the slice from <code>by ..</code> down to
<code>0 .. len - by</code>, and erases <code>len - by ..</code> to <code>0</code>. As this is a
destructive (and linearly expensive) operation, you may prefer instead
to use range subslicing.</p>
<h5 id="parameters-13"><a href="#parameters-13">Parameters</a></h5>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>by</code>: The distance by which to shift the slice contents.</li>
</ul>
<h5 id="panics-32"><a href="#panics-32">Panics</a></h5>
<p>This panics if <code>by</code> is not less than <code>self.len()</code>.</p>
<h5 id="examples-113"><a href="#examples-113">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">1</span>; <span class="number">6</span>];
bits.shift_left(<span class="number">2</span>);
<span class="macro">assert_eq!</span>(bits, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.shift_right" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#1705-1722">source</a><h4 class="code-header">pub fn <a href="#method.shift_right" class="fnname">shift_right</a>(&amp;mut self, by: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Shifts the contents of a bit-slice right (towards index <code>self.len()</code>).</p>
<p>This moves the contents of the slice from <code>.. len - by</code> up to <code>by ..</code>,
and erases <code>.. by</code> to <code>0</code>. As this is a destructive (and linearly
expensive) operation, you may prefer instead to use range subslicing.</p>
<h5 id="parameters-14"><a href="#parameters-14">Parameters</a></h5>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>by</code>: The distance by which to shift the slice contents.</li>
</ul>
<h5 id="panics-33"><a href="#panics-33">Panics</a></h5>
<p>This panics if <code>by</code> is not less than <code>self.len()</code>.</p>
<h5 id="examples-114"><a href="#examples-114">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">1</span>; <span class="number">6</span>];
bits.shift_right(<span class="number">2</span>);
<span class="macro">assert_eq!</span>(bits, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.set_all" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#1745-1769">source</a><h4 class="code-header">pub fn <a href="#method.set_all" class="fnname">set_all</a>(&amp;mut self, value: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a>)</h4></section></summary><div class="docblock"><p>Sets all bits in the slice to a value.</p>
<h5 id="parameters-15"><a href="#parameters-15">Parameters</a></h5>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>value</code>: The bit value to which all bits in the slice will be set.</li>
</ul>
<h5 id="examples-115"><a href="#examples-115">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>src = <span class="number">0u8</span>;
<span class="kw">let </span>bits = src.view_bits_mut::&lt;Msb0&gt;();
bits[<span class="number">2 </span>.. <span class="number">6</span>].set_all(<span class="bool-val">true</span>);
<span class="macro">assert_eq!</span>(bits.as_raw_slice(), <span class="kw-2">&amp;</span>[<span class="number">0b0011_1100</span>]);
bits[<span class="number">3 </span>.. <span class="number">5</span>].set_all(<span class="bool-val">false</span>);
<span class="macro">assert_eq!</span>(bits.as_raw_slice(), <span class="kw-2">&amp;</span>[<span class="number">0b0010_0100</span>]);
bits[.. <span class="number">1</span>].set_all(<span class="bool-val">true</span>);
<span class="macro">assert_eq!</span>(bits.as_raw_slice(), <span class="kw-2">&amp;</span>[<span class="number">0b1010_0100</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.for_each" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#1805-1812">source</a><h4 class="code-header">pub fn <a href="#method.for_each" class="fnname">for_each</a>&lt;F&gt;(&amp;mut self, func: F)<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>, <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a>,</span></h4></section></summary><div class="docblock"><p>Applies a function to each bit in the slice.</p>
<p><code>BitSlice</code> cannot implement <a href="https://doc.rust-lang.org/1.65.0/core/ops/index/trait.IndexMut.html"><code>IndexMut</code></a>, as it cannot manifest <code>&amp;mut bool</code> references, and the <a href="../prelude/struct.BitRef.html"><code>BitRef</code></a> proxy reference has an unavoidable
overhead. This method bypasses both problems, by applying a function to
each pair of index and value in the slice, without constructing a proxy
reference. Benchmarks indicate that this method is about 2–4 times
faster than the <code>.iter_mut().enumerate()</code> equivalent.</p>
<h5 id="parameters-16"><a href="#parameters-16">Parameters</a></h5>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>func</code>: A function which receives two arguments, <code>index: usize</code> and
<code>value: bool</code>, and returns a <code>bool</code>.</li>
</ul>
<h5 id="effects-1"><a href="#effects-1">Effects</a></h5>
<p>For each index in the slice, the result of invoking <code>func</code> with the
index number and current bit value is written into the slice.</p>
<h5 id="examples-116"><a href="#examples-116">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>data = <span class="number">0u8</span>;
<span class="kw">let </span>bits = data.view_bits_mut::&lt;Msb0&gt;();
bits.for_each(|idx, _bit| idx % <span class="number">3 </span>== <span class="number">0</span>);
<span class="macro">assert_eq!</span>(data, <span class="number">0b100_100_10</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.offset_from" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#1862-1864">source</a><h4 class="code-header">pub fn <a href="#method.offset_from" class="fnname">offset_from</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;</a>Self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.isize.html">isize</a></h4></section></summary><div class="docblock"><p>Produces the absolute offset in bits between two slice heads.</p>
<p>While this method is sound for any two arbitrary bit slices, the answer
it produces is meaningful <em>only</em> when one argument is a strict subslice
of the other. If the two slices are created from different buffers
entirely, a comparison is undefined; if the two slices are disjoint
regions of the same buffer, then the semantically correct distance is
between the tail of the lower and the head of the upper, which this
does not measure.</p>
<h5 id="visual-description"><a href="#visual-description">Visual Description</a></h5>
<p>Consider the following sequence of bits:</p>
<div class="example-wrap"><pre class="language-text"><code>[ 0 1 2 3 4 5 6 7 8 9 a b ]
  |       ^^^^^^^       |
  ^^^^^^^^^^^^^^^^^^^^^^^</code></pre></div>
<p>It does not matter whether there are bits between the tail of the
smaller and the larger slices. The offset is computed from the bit
distance between the two heads.</p>
<h5 id="behavior-3"><a href="#behavior-3">Behavior</a></h5>
<p>This function computes the <em>semantic</em> distance between the heads, rather
than the *electrical. It does not take into account the <code>BitOrder</code>
implementation of the slice.</p>
<h5 id="safety-and-soundness"><a href="#safety-and-soundness">Safety and Soundness</a></h5>
<p>One of <code>self</code> or <code>other</code> must contain the other for this comparison to
be meaningful.</p>
<h5 id="parameters-17"><a href="#parameters-17">Parameters</a></h5>
<ul>
<li><code>&amp;self</code></li>
<li><code>other</code>: Another bit slice. This must be either a strict subregion or
a strict superregion of <code>self</code>.</li>
</ul>
<h5 id="returns-11"><a href="#returns-11">Returns</a></h5>
<p>The distance in (semantic) bits between the heads of each region. The
value is positive when <code>other</code> is higher in the address space than
<code>self</code>, and negative when <code>other</code> is lower in the address space than
<code>self</code>.</p>
</div></details></div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.set_unchecked" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#1936-1938">source</a><h4 class="code-header">pub unsafe fn <a href="#method.set_unchecked" class="fnname">set_unchecked</a>(&amp;mut self, index: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>, value: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a>)</h4></section></summary><div class="docblock"><p>Writes a new bit at a given index, without doing bounds checking.</p>
<p>This is generally not recommended; use with caution! Calling this method
with an out-of-bounds index is <em><a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behavior</a></em>. For a safe
alternative, see <a href="../slice/struct.BitSlice.html#method.set"><code>.set()</code></a>.</p>
<h5 id="parameters-18"><a href="#parameters-18">Parameters</a></h5>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>index</code>: The bit index at which to write. It must be in the range <code>0 .. self.len()</code>.</li>
<li><code>value</code>: The value to be written; <code>true</code> for <code>1</code> or <code>false</code> for <code>0</code>.</li>
</ul>
<h5 id="effects-2"><a href="#effects-2">Effects</a></h5>
<p>The bit at <code>index</code> is set to <code>value</code>. If <code>index</code> is out of bounds, then
the memory access is incorrect, and its behavior is unspecified.</p>
<h5 id="safety-5"><a href="#safety-5">Safety</a></h5>
<p>This method is <strong>not</strong> safe. It performs raw pointer arithmetic to seek
from the start of the slice to the requested index, and set the bit
there. It does not inspect the length of <code>self</code>, and it is free to
perform out-of-bounds memory <em>write</em> access.</p>
<p>Use this method <strong>only</strong> when you have already performed the bounds
check, and can guarantee that the call occurs with a safely in-bounds
index.</p>
<h5 id="examples-117"><a href="#examples-117">Examples</a></h5>
<p>This example uses a bit slice of length 2, and demonstrates
out-of-bounds access to the last bit in the element.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span><span class="number">0</span>; <span class="number">2</span>];
<span class="kw">let </span>(first, <span class="kw">_</span>) = bits.split_at_mut(<span class="number">1</span>);

<span class="kw">unsafe </span>{
  first.set_unchecked(<span class="number">1</span>, <span class="bool-val">true</span>);
}

<span class="macro">assert_eq!</span>(bits, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.swap_unchecked" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#1951-1955">source</a><h4 class="code-header">pub unsafe fn <a href="#method.swap_unchecked" class="fnname">swap_unchecked</a>(&amp;mut self, a: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>, b: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Swaps two bits in the slice.</p>
<p>See <a href="../slice/struct.BitSlice.html#method.swap"><code>.swap()</code></a>.</p>
<h5 id="safety-6"><a href="#safety-6">Safety</a></h5>
<p><code>a</code> and <code>b</code> must both be less than <a href="../slice/struct.BitSlice.html#method.len"><code>self.len()</code></a>.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.split_at_unchecked" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#1985-1987">source</a><h4 class="code-header">pub unsafe fn <a href="#method.split_at_unchecked" class="fnname">split_at_unchecked</a>(&amp;self, mid: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>) -&gt; (<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;</a>Self, <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;</a>Self)</h4></section></summary><div class="docblock"><p>Divides one slice into two at an index, without performing any bounds
checking.</p>
<p>See <a href="../slice/struct.BitSlice.html#method.split_at"><code>.split_at()</code></a>.</p>
<h5 id="safety-7"><a href="#safety-7">Safety</a></h5>
<p><code>mid</code> must not be greater than <a href="../slice/struct.BitSlice.html#method.len"><code>self.len()</code></a>. If this condition is
violated, the function behavior is <em>unspecified</em>.</p>
<h5 id="examples-118"><a href="#examples-118">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="kw">let </span>(l, r) = <span class="kw">unsafe </span>{ bits.split_at_unchecked(<span class="number">3</span>) };
<span class="macro">assert!</span>(l.not_any());
<span class="macro">assert!</span>(r.all());

<span class="kw">let </span>(l, r) = <span class="kw">unsafe </span>{ bits.split_at_unchecked(<span class="number">6</span>) };
<span class="macro">assert_eq!</span>(l, bits);
<span class="macro">assert!</span>(r.is_empty());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.split_at_unchecked_mut" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#2001-2010">source</a><h4 class="code-header">pub unsafe fn <a href="#method.split_at_unchecked_mut" class="fnname">split_at_unchecked_mut</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self,<br>&nbsp;&nbsp;&nbsp;&nbsp;mid: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a><br>) -&gt; (&amp;mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>&gt;, &amp;mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>&gt;)</h4></section></summary><div class="docblock"><p>Divides one mutable slice into two at an index.</p>
<p>See <a href="../slice/struct.BitSlice.html#method.split_at_mut"><code>.split_at_mut()</code></a>.</p>
<h5 id="safety-8"><a href="#safety-8">Safety</a></h5>
<p><code>mid</code> must not be greater than <a href="../slice/struct.BitSlice.html#method.len"><code>self.len()</code></a>.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.copy_within_unchecked" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#2033-2062">source</a><h4 class="code-header">pub unsafe fn <a href="#method.copy_within_unchecked" class="fnname">copy_within_unchecked</a>&lt;R&gt;(&amp;mut self, src: R, dest: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>)<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;R: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/range/trait.RangeBounds.html" title="trait core::ops::range::RangeBounds">RangeBounds</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>&gt;,</span></h4></section></summary><div class="docblock"><p>Copies bits from one part of the slice to another part of itself,
without doing bounds checks.</p>
<p>The ranges are allowed to overlap.</p>
<h5 id="parameters-19"><a href="#parameters-19">Parameters</a></h5>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>src</code>: The range within <code>self</code> from which to copy.</li>
<li><code>dst</code>: The starting index within <code>self</code> at which to paste.</li>
</ul>
<h5 id="effects-3"><a href="#effects-3">Effects</a></h5>
<p><code>self[src]</code> is copied to <code>self[dest .. dest + src.end() - src.start()]</code>.</p>
<h5 id="safety-9"><a href="#safety-9">Safety</a></h5>
<p><code>src</code> and <code>dest .. dest + src.len()</code> must be entirely within
<a href="../slice/struct.BitSlice.html#method.len"><code>self.len()</code></a>.</p>
</div></details></div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_bitptr-1" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#2117-2119">source</a><h4 class="code-header">pub fn <a href="#method.as_bitptr-1" class="fnname">as_bitptr</a>(&amp;self) -&gt; <a class="struct" href="../prelude/struct.BitPtr.html" title="struct bitvec::prelude::BitPtr">BitPtr</a>&lt;<a class="struct" href="../ptr/struct.Const.html" title="struct bitvec::ptr::Const">Const</a>, O, T&gt;</h4></section></summary><div class="docblock"><p>Returns a raw bit-pointer to the base of the bit-slice’s region.</p>
<p>The caller must ensure that the bit-slice outlives the bit-pointer this
function returns, or else it will end up pointing to garbage.</p>
<p>The caller must also ensure that the memory the bit-pointer
(non-transitively) points to is never written to using this bit-pointer
or any bit-pointer derived from it. If you need to mutate the contents
of the slice, use <a href="../slice/struct.BitSlice.html#method.as_mut_bitptr"><code>.as_mut_bitptr()</code></a>.</p>
<p>Modifying the container referenced by this bit-slice may cause its
buffer to be reällocated, which would also make any bit-pointers to it
invalid.</p>
<h5 id="original-86"><a href="#original-86">Original</a></h5>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.as_ptr"><code>slice::as_ptr</code></a></p>
<h5 id="api-differences-41"><a href="#api-differences-41">API Differences</a></h5>
<p>This returns a structure, <a href="../prelude/struct.BitPtr.html" title="BitPtr"><code>BitPtr</code></a>, rather than an actual raw pointer
<code>*Bit</code>. The information required to address a bit within a memory
element cannot be encoded into a single pointer.</p>
<p>This structure can be converted back into a <code>&amp;BitSlice</code> with the
function <a href="../slice/fn.from_raw_parts.html"><code>from_raw_parts</code></a>.</p>
<h5 id="examples-119"><a href="#examples-119">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>x = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let </span>x_ptr = x.as_ptr();

<span class="kw">unsafe </span>{
  <span class="kw">for </span>i <span class="kw">in </span><span class="number">0 </span>.. x.len() {
    <span class="macro">assert_eq!</span>(<span class="kw-2">*</span>x.get_unchecked(i), (<span class="kw-2">&amp;*</span>x)[i]);
  }
}</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_mut_bitptr-1" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#2157-2159">source</a><h4 class="code-header">pub fn <a href="#method.as_mut_bitptr-1" class="fnname">as_mut_bitptr</a>(&amp;mut self) -&gt; <a class="struct" href="../prelude/struct.BitPtr.html" title="struct bitvec::prelude::BitPtr">BitPtr</a>&lt;<a class="struct" href="../ptr/struct.Mut.html" title="struct bitvec::ptr::Mut">Mut</a>, O, T&gt;</h4></section></summary><div class="docblock"><p>Returns an unsafe mutable bit-pointer to the bit-slice’s region.</p>
<p>The caller must ensure that the bit-slice outlives the bit-pointer this
function returns, or else it will end up pointing to garbage.</p>
<p>Modifying the container referenced by this bit-slice may cause its
buffer to be reällocated, which would also make any bit-pointers to it
invalid.</p>
<h5 id="original-87"><a href="#original-87">Original</a></h5>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.as_mut_ptr"><code>slice::as_mut_ptr</code></a></p>
<h5 id="api-differences-42"><a href="#api-differences-42">API Differences</a></h5>
<p>This returns <code>*mut BitSlice</code>, which is the equivalent of <code>*mut [T]</code>
instead of <code>*mut T</code>. The pointer encoding used requires more than one
CPU word of space to address a single bit, so there is no advantage to
removing the length information from the encoded pointer value.</p>
<h5 id="examples-120"><a href="#examples-120">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="kw-2">mut </span>Lsb0, u8; <span class="number">0</span>; <span class="number">8</span>];
<span class="kw">let </span>bits_ptr = bits.as_mut_ptr();

<span class="kw">for </span>i <span class="kw">in </span><span class="number">0 </span>.. bits.len() {
  <span class="kw">unsafe </span>{
    bits_ptr.add(i).write(i % <span class="number">3 </span>== <span class="number">0</span>);
  }
}
<span class="macro">assert_eq!</span>(bits.as_raw_slice()[<span class="number">0</span>], <span class="number">0b0100_1001</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_bitptr_range" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#2205-2207">source</a><h4 class="code-header">pub fn <a href="#method.as_bitptr_range" class="fnname">as_bitptr_range</a>(&amp;self) -&gt; <a class="struct" href="../prelude/struct.BitPtrRange.html" title="struct bitvec::prelude::BitPtrRange">BitPtrRange</a>&lt;<a class="struct" href="../ptr/struct.Const.html" title="struct bitvec::ptr::Const">Const</a>, O, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../prelude/struct.BitPtrRange.html" title="struct bitvec::prelude::BitPtrRange">BitPtrRange</a>&lt;M, O, T&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;M, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../prelude/struct.BitPtrRange.html" title="struct bitvec::prelude::BitPtrRange">BitPtrRange</a>&lt;M, O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M: <a class="trait" href="../ptr/trait.Mutability.html" title="trait bitvec::ptr::Mutability">Mutability</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = <a class="struct" href="../prelude/struct.BitPtr.html" title="struct bitvec::prelude::BitPtr">BitPtr</a>&lt;M, O, T&gt;;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Returns the two raw bit-pointers spanning the bit-slice.</p>
<p>The returned range is half-open, which means that the end bit-pointer
points <em>one past</em> the last bit of the bit-slice. This way, an empty
bit-slice is represented by two equal bit-pointers, and the difference
between the two bit-pointers represents the size of the bit-slice.</p>
<p>See <a href="../slice/struct.BitSlice.html#method.as_bitptr"><code>as_bitptr</code></a> for warnings on using these bit-pointers. The end
bit-pointer requires extra caution, as it does not point to a valid bit
in the bit-slice.</p>
<p>This function allows a more direct access to bit-pointers, without
paying the cost of encoding into a <code>*BitSlice</code>, at the cost of no longer
fitting into ordinary Rust interfaces.</p>
<h5 id="original-88"><a href="#original-88">Original</a></h5>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.as_ptr_range"><code>slice::as_ptr_range</code></a></p>
<h5 id="api-differences-43"><a href="#api-differences-43">API Differences</a></h5>
<p>This returns a dedicated structure, rather than a range of <a href="../prelude/struct.BitPtr.html"><code>BitPtr</code></a>s,
because the traits needed for non-<code>core</code> types to correctly operate in
ranges are still unstable. The structure can be converted into a range,
but that range will not be an iterator.</p>
<h5 id="examples-121"><a href="#examples-121">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let </span>mid_ptr = bits.get(<span class="number">2</span>).unwrap().into_bitptr();
<span class="kw">let </span><span class="kw-2">mut </span>range = bits.as_bitptr_range();
<span class="macro">assert!</span>(range.contains(<span class="kw-2">&amp;</span>mid_ptr));
<span class="kw">unsafe </span>{
  <span class="macro">assert!</span>(!range.next().unwrap().read());
  <span class="macro">assert!</span>(range.next_back().unwrap().read())
}</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_mut_bitptr_range" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#2248-2250">source</a><h4 class="code-header">pub fn <a href="#method.as_mut_bitptr_range" class="fnname">as_mut_bitptr_range</a>(&amp;mut self) -&gt; <a class="struct" href="../prelude/struct.BitPtrRange.html" title="struct bitvec::prelude::BitPtrRange">BitPtrRange</a>&lt;<a class="struct" href="../ptr/struct.Mut.html" title="struct bitvec::ptr::Mut">Mut</a>, O, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../prelude/struct.BitPtrRange.html" title="struct bitvec::prelude::BitPtrRange">BitPtrRange</a>&lt;M, O, T&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;M, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../prelude/struct.BitPtrRange.html" title="struct bitvec::prelude::BitPtrRange">BitPtrRange</a>&lt;M, O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M: <a class="trait" href="../ptr/trait.Mutability.html" title="trait bitvec::ptr::Mutability">Mutability</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = <a class="struct" href="../prelude/struct.BitPtr.html" title="struct bitvec::prelude::BitPtr">BitPtr</a>&lt;M, O, T&gt;;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Returns the two unsafe mutable bit-pointers spanning the bit-slice.</p>
<p>The returned range is half-open, which means that the end bit-pointer
points <em>one past</em> the last bitt of the bit-slice. This way, an empty
bit-slice is represented by two equal bit-pointers, and the difference
between the two bit-pointers represents the size of the bit-slice.</p>
<p>See <a href="../slice/struct.BitSlice.html#method.as_mut_bitptr"><code>as_mut_bitptr</code></a> for warnings on using these bit-pointers. The end
bit-pointer requires extra caution, as it does not point to a valid bit
in the bit-slice.</p>
<h5 id="original-89"><a href="#original-89">Original</a></h5>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.as_mut_ptr_range"><code>slice::as_mut_ptr_range</code></a></p>
<h5 id="api-differences-44"><a href="#api-differences-44">API Differences</a></h5>
<p>This returns a dedicated structure, rather than a range of <a href="../prelude/struct.BitPtr.html"><code>BitPtr</code></a>s,
because the traits needed for non-<code>core</code> types to correctly operate in
ranges are still unstable. The structure can be converted into a range,
but that range will not be an iterator.</p>
<h5 id="examples-122"><a href="#examples-122">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;
<span class="kw">use </span>bitvec::ptr <span class="kw">as </span>bv_ptr;

<span class="kw">let </span><span class="kw-2">mut </span>data = <span class="number">0u8</span>;
<span class="kw">let </span>bits = data.view_bits_mut::&lt;Msb0&gt;();
<span class="kw">for </span><span class="kw-2">mut </span>bitptr <span class="kw">in </span>bits.as_mut_bitptr_range() {
  <span class="kw">unsafe </span>{ bv_ptr::write(bitptr, <span class="bool-val">true</span>); }
}
<span class="macro">assert_eq!</span>(data, !<span class="number">0</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.bit_domain" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#2287-2289">source</a><h4 class="code-header">pub fn <a href="#method.bit_domain" class="fnname">bit_domain</a>(&amp;self) -&gt; <a class="enum" href="../domain/enum.BitDomain.html" title="enum bitvec::domain::BitDomain">BitDomain</a>&lt;'_, O, T&gt;</h4></section></summary><div class="docblock"><p>Splits the slice into subslices at alias boundaries.</p>
<p>This splits <code>self</code> into the memory locations that it partially fills and
the memory locations that it completely fills. The locations that are
completely filled may be accessed without any <code>bitvec</code>-imposed alias
conditions, while the locations that are only partially filled are left
unchanged.</p>
<p>You can read more about the <a href="../domain/enum.BitDomain.html"><code>BitDomain</code></a> splitting in its
documentation.</p>
<h5 id="examples-123"><a href="#examples-123">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>data = [<span class="number">0u16</span>; <span class="number">3</span>];
<span class="kw">let </span>all = data.view_bits_mut::&lt;Msb0&gt;();
<span class="kw">let </span>(<span class="kw">_</span>, rest) = all.split_at_mut(<span class="number">8</span>);
<span class="kw">let </span>bits: <span class="kw-2">&amp;</span>BitSlice&lt;Msb0, &lt;u16 <span class="kw">as </span>BitStore&gt;::Alias&gt; = <span class="kw-2">&amp;</span>rest[.. <span class="number">32</span>];

<span class="kw">let </span>(head, body, tail) = bits
  .bit_domain()
  .region()
  .unwrap();
<span class="macro">assert_eq!</span>(head.len(), <span class="number">8</span>);
<span class="macro">assert_eq!</span>(tail.len(), <span class="number">8</span>);
<span class="kw">let _</span>: <span class="kw-2">&amp;</span>BitSlice&lt;Msb0, &lt;u16 <span class="kw">as </span>BitStore&gt;::Alias&gt; = head;
<span class="kw">let _</span>: <span class="kw-2">&amp;</span>BitSlice&lt;Msb0, &lt;u16 <span class="kw">as </span>BitStore&gt;::Alias&gt; = tail;
<span class="kw">let _</span>: <span class="kw-2">&amp;</span>BitSlice&lt;Msb0, u16&gt; = body;</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.bit_domain_mut" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#2327-2329">source</a><h4 class="code-header">pub fn <a href="#method.bit_domain_mut" class="fnname">bit_domain_mut</a>(&amp;mut self) -&gt; <a class="enum" href="../domain/enum.BitDomainMut.html" title="enum bitvec::domain::BitDomainMut">BitDomainMut</a>&lt;'_, O, T&gt;</h4></section></summary><div class="docblock"><p>Splits the slice into subslices at alias boundaries.</p>
<p>This splits <code>self</code> into the memory locations that it partially fills and
the memory locations that it completely fills. The locations that are
completely filled may be accessed without any <code>bitvec</code>-imposed alias
conditions, while the locations that are only partially filled are left
unchanged.</p>
<p>You can read more about the <a href="../domain/enum.BitDomainMut.html"><code>BitDomainMut</code></a> splitting in its
documentation.</p>
<h5 id="examples-124"><a href="#examples-124">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>data = [<span class="number">0u16</span>; <span class="number">3</span>];
<span class="kw">let </span>all = data.view_bits_mut::&lt;Msb0&gt;();
<span class="kw">let </span>(<span class="kw">_</span>, rest) = all.split_at_mut(<span class="number">8</span>);
<span class="kw">let </span>bits: <span class="kw-2">&amp;mut </span>BitSlice&lt;Msb0, &lt;u16 <span class="kw">as </span>BitStore&gt;::Alias&gt;
  = <span class="kw-2">&amp;mut </span>rest[.. <span class="number">32</span>];

<span class="kw">let </span>(head, body, tail) = bits
  .bit_domain_mut()
  .region()
  .unwrap();
<span class="macro">assert_eq!</span>(head.len(), <span class="number">8</span>);
<span class="macro">assert_eq!</span>(tail.len(), <span class="number">8</span>);
<span class="kw">let _</span>: <span class="kw-2">&amp;mut </span>BitSlice&lt;Msb0, &lt;u16 <span class="kw">as </span>BitStore&gt;::Alias&gt; = head;
<span class="kw">let _</span>: <span class="kw-2">&amp;mut </span>BitSlice&lt;Msb0, &lt;u16 <span class="kw">as </span>BitStore&gt;::Alias&gt; = tail;
<span class="kw">let _</span>: <span class="kw-2">&amp;mut </span>BitSlice&lt;Msb0, u16&gt; = body;</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.domain" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#2366-2368">source</a><h4 class="code-header">pub fn <a href="#method.domain" class="fnname">domain</a>(&amp;self) -&gt; <a class="enum" href="../domain/enum.Domain.html" title="enum bitvec::domain::Domain">Domain</a>&lt;'_, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="enum" href="../domain/enum.Domain.html" title="enum bitvec::domain::Domain">Domain</a>&lt;'a, T&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="enum" href="../domain/enum.Domain.html" title="enum bitvec::domain::Domain">Domain</a>&lt;'a, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Mem" title="type bitvec::store::BitStore::Mem">Mem</a>;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Views the underlying memory containing the slice, split at alias
boundaries.</p>
<p>This splits <code>self</code> into the memory locations that it partially fills and
the memory locations that it completely fills. The locations that are
completely filled may be accessed without any <code>bitvec</code>-imposed alias
conditions, while the locations that are only partially filled are left
unchanged.</p>
<p>You can read more about the <a href="../domain/enum.Domain.html"><code>Domain</code></a> splitting in its documentation.</p>
<h5 id="examples-125"><a href="#examples-125">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>data = [<span class="number">0u16</span>; <span class="number">3</span>];
<span class="kw">let </span>all = data.view_bits_mut::&lt;Msb0&gt;();
<span class="kw">let </span>(<span class="kw">_</span>, rest) = all.split_at_mut(<span class="number">8</span>);
<span class="kw">let </span>bits: <span class="kw-2">&amp;</span>BitSlice&lt;Msb0, &lt;u16 <span class="kw">as </span>BitStore&gt;::Alias&gt; = <span class="kw-2">&amp;</span>rest[.. <span class="number">32</span>];

<span class="kw">let </span>(head, body, tail) = bits
  .domain()
  .region()
  .unwrap();
<span class="macro">assert_eq!</span>(body.len(), <span class="number">1</span>);

<span class="kw">let _</span>: <span class="kw-2">&amp;</span>&lt;u16 <span class="kw">as </span>BitStore&gt;::Alias = head.unwrap().<span class="number">1</span>;
<span class="kw">let _</span>: <span class="kw-2">&amp;</span>&lt;u16 <span class="kw">as </span>BitStore&gt;::Alias = tail.unwrap().<span class="number">0</span>;
<span class="kw">let _</span>: <span class="kw-2">&amp;</span>[u16] = body;</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.domain_mut" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#2407-2409">source</a><h4 class="code-header">pub fn <a href="#method.domain_mut" class="fnname">domain_mut</a>(&amp;mut self) -&gt; <a class="enum" href="../domain/enum.DomainMut.html" title="enum bitvec::domain::DomainMut">DomainMut</a>&lt;'_, T&gt;</h4></section></summary><div class="docblock"><p>Views the underlying memory containing the slice, split at alias
boundaries.</p>
<p>This splits <code>self</code> into the memory locations that it partially fills and
the memory locations that it completely fills. The locations that are
completely filled may be accessed without any <code>bitvec</code>-imposed alias
conditions, while the locations that are only partially filled are left
unchanged.</p>
<p>You can read more about the <a href="../domain/enum.DomainMut.html"><code>DomainMut</code></a> splitting in its
documentation.</p>
<h5 id="examples-126"><a href="#examples-126">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>data = [<span class="number">0u16</span>; <span class="number">3</span>];
<span class="kw">let </span>all = data.view_bits_mut::&lt;Msb0&gt;();
<span class="kw">let </span>(<span class="kw">_</span>, rest) = all.split_at_mut(<span class="number">8</span>);
<span class="kw">let </span>bits: <span class="kw-2">&amp;mut </span>BitSlice&lt;Msb0, &lt;u16 <span class="kw">as </span>BitStore&gt;::Alias&gt; = <span class="kw-2">&amp;mut </span>rest[.. <span class="number">32</span>];

<span class="kw">let </span>(head, body, tail) = bits
  .domain_mut()
  .region()
  .unwrap();
<span class="macro">assert_eq!</span>(body.len(), <span class="number">1</span>);

<span class="kw">let _</span>: <span class="kw-2">&amp;</span>&lt;&lt;u16 <span class="kw">as </span>BitStore&gt;::Alias <span class="kw">as </span>BitStore&gt;::Access = head.unwrap().<span class="number">1</span>;
<span class="kw">let _</span>: <span class="kw-2">&amp;</span>&lt;&lt;u16 <span class="kw">as </span>BitStore&gt;::Alias <span class="kw">as </span>BitStore&gt;::Access = tail.unwrap().<span class="number">0</span>;
<span class="kw">let _</span>: <span class="kw-2">&amp;mut </span>[u16] = body;</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_raw_slice-1" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#2421-2425">source</a><h4 class="code-header">pub fn <a href="#method.as_raw_slice-1" class="fnname">as_raw_slice</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.slice.html">[T]</a><span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for &amp;mut [<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.u8.html">u8</a>]</span><code class="content"><span class="where fmt-newline">impl <a class="trait" href="https://doc.rust-lang.org/1.65.0/std/io/trait.Write.html" title="trait std::io::Write">Write</a> for &amp;mut [<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.u8.html">u8</a>]</span><span class="where fmt-newline">impl <a class="trait" href="https://doc.rust-lang.org/1.65.0/std/io/trait.Read.html" title="trait std::io::Read">Read</a> for &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.u8.html">u8</a>]</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Views the underlying memory containing the slice.</p>
<p>The returned slice handle views all elements touched by <code>self</code>, and
marks them all with <code>self</code>’s current aliasing state. For a more precise
view, or one that permits mutation, use <a href="../slice/struct.BitSlice.html#method.domain"><code>.domain()</code></a> or
<a href="../slice/struct.BitSlice.html#method.domain_mut"><code>.domain_mut()</code></a>.</p>
</div></details></div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.set_aliased" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#2585-2590">source</a><h4 class="code-header">pub fn <a href="#method.set_aliased" class="fnname">set_aliased</a>(&amp;self, index: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>, value: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a>)</h4></section></summary><div class="docblock"><p>Writes a new bit at a given index.</p>
<p>This method supports writing through a shared reference to a bit that
may be observed by other <code>BitSlice</code> handles. It is only present when the
<code>T</code> type parameter supports such shared mutation (measured by the
<a href="../../radium/trait.Radium.html"><code>Radium</code></a> trait).</p>
<h5 id="parameters-20"><a href="#parameters-20">Parameters</a></h5>
<ul>
<li><code>&amp;self</code></li>
<li><code>index</code>: The bit index at which to write. It must be in the range <code>0 .. self.len()</code>.</li>
<li><code>value</code>: The value to be written; <code>true</code> for <code>1</code> or <code>false</code> for <code>0</code>.</li>
</ul>
<h5 id="effects-4"><a href="#effects-4">Effects</a></h5>
<p>If <code>index</code> is valid, then the bit to which it refers is set to <code>value</code>.
If <code>T</code> is an <a href="https://doc.rust-lang.org/1.65.0/core/sync/atomic/index.html">atomic</a>, this will lock the memory bus for the referent
address, and may cause stalls.</p>
<h5 id="panics-34"><a href="#panics-34">Panics</a></h5>
<p>This method panics if <code>index</code> is not less than <a href="../slice/struct.BitSlice.html#method.len"><code>self.len()</code></a>.</p>
<h5 id="examples-127"><a href="#examples-127">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;
<span class="kw">use </span>core::cell::Cell;

<span class="kw">let </span>byte = Cell::new(<span class="number">0u8</span>);
<span class="kw">let </span>bits = byte.view_bits::&lt;Msb0&gt;();
<span class="kw">let </span>bits_2 = bits;

bits.set_aliased(<span class="number">1</span>, <span class="bool-val">true</span>);
<span class="macro">assert!</span>(bits_2[<span class="number">1</span>]);</code></pre></div>
<p>This example panics when it attempts to set a bit that is out of bounds.</p>

<div class="example-wrap should_panic"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;
<span class="kw">use </span>core::cell::Cell;

<span class="kw">let </span>byte = Cell::new(<span class="number">0u8</span>);
<span class="kw">let </span>bits = byte.view_bits::&lt;Lsb0&gt;();
bits.set_aliased(<span class="number">8</span>, <span class="bool-val">false</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.set_aliased_unchecked" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#2637-2639">source</a><h4 class="code-header">pub unsafe fn <a href="#method.set_aliased_unchecked" class="fnname">set_aliased_unchecked</a>(&amp;self, index: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>, value: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a>)</h4></section></summary><div class="docblock"><p>Writes a new bit at a given index, without doing bounds checking.</p>
<p>This method supports writing through a shared reference to a bit that
may be observed by other <code>BitSlice</code> handles. It is only present when the
<code>T</code> type parameter supports such shared mutation (measured by the
<a href="../../radium/trait.Radium.html"><code>Radium</code></a> trait).</p>
<h5 id="effects-5"><a href="#effects-5">Effects</a></h5>
<p>The bit at <code>index</code> is set to <code>value</code>. If <code>index</code> is out of bounds, then
the memory access is incorrect, and its behavior is unspecified. If <code>T</code>
is an <a href="https://doc.rust-lang.org/1.65.0/core/sync/atomic/index.html">atomic</a>, this will lock the memory bus for the referent
address, and may cause stalls.</p>
<h5 id="safety-10"><a href="#safety-10">Safety</a></h5>
<p>This method is <strong>not</strong> safe. It performs raw pointer arithmetic to seek
from the start of the slice to the requested index, and set the bit
there. It does not inspect the length of <code>self</code>, and it is free to
perform out-of-bounds memory <em>write</em> access.</p>
<p>Use this method <strong>only</strong> when you have already performed the bounds
check, and can guarantee that the call occurs with a safely in-bounds
index.</p>
<h5 id="examples-128"><a href="#examples-128">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;
<span class="kw">use </span>core::cell::Cell;

<span class="kw">let </span>byte = Cell::new(<span class="number">0u8</span>);
<span class="kw">let </span>bits = byte.view_bits::&lt;Msb0&gt;();
<span class="kw">let </span>bits_2 = bits;

<span class="kw">let </span>(first, <span class="kw">_</span>) = bits.split_at(<span class="number">1</span>);
<span class="macro">assert_eq!</span>(first.len(), <span class="number">1</span>);
<span class="kw">unsafe </span>{ first.set_aliased_unchecked(<span class="number">2</span>, <span class="bool-val">true</span>); }

<span class="macro">assert!</span>(bits_2[<span class="number">2</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.split_at_aliased_mut" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#2653-2659">source</a><h4 class="code-header">pub fn <a href="#method.split_at_aliased_mut" class="fnname">split_at_aliased_mut</a>(&amp;mut self, mid: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>) -&gt; (<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;mut </a>Self, <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;mut </a>Self)</h4></section></summary><div class="docblock"><p>Splits a mutable slice at some mid-point.</p>
<p>This method has the same behavior as <a href="../slice/struct.BitSlice.html#method.split_at_mut"><code>.split_at_mut()</code></a>, except that it
does not apply an aliasing marker to the partitioned subslices.</p>
<h5 id="safety-11"><a href="#safety-11">Safety</a></h5>
<p>Because this method is defined only on <code>BitSlice</code>s whose <code>T</code> type is
alias-safe, the subslices do not need to be additionally marked.</p>
</div></details></div><div class="impl-items"><section id="associatedconstant.MAX_BITS" class="associatedconstant has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#2677">source</a><h4 class="code-header">pub const <a href="#associatedconstant.MAX_BITS" class="constant">MAX_BITS</a>: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a> = 2_305_843_009_213_693_951usize</h4></section><section id="associatedconstant.MAX_ELTS" class="associatedconstant has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#2692">source</a><h4 class="code-header">pub const <a href="#associatedconstant.MAX_ELTS" class="constant">MAX_ELTS</a>: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a> = BitSpan&lt;Const, O, T&gt;::REGION_MAX_ELTS</h4></section></div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.to_bitvec" class="method has-srclink"><a class="srclink rightside" href="../../src/bitvec/slice.rs.html#2717-2732">source</a><h4 class="code-header">pub fn <a href="#method.to_bitvec" class="fnname">to_bitvec</a>(&amp;self) -&gt; <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Unalias" title="type bitvec::store::BitStore::Unalias">Unalias</a>&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/std/io/trait.Write.html" title="trait std::io::Write">Write</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,</span></span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Copies <code>self</code> into a new <a href="struct.BitVec.html"><code>BitVec</code></a>.</p>
<p>This resets any alias markings from <code>self</code>, since the returned buffer is
known to be newly allocated and thus unaliased.</p>
<h5 id="examples-129"><a href="#examples-129">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let </span>bv = bits.to_bitvec();
<span class="macro">assert_eq!</span>(bits, bv);</code></pre></div>
</div></details></div></div><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor"></a></h2><div id="trait-implementations-list"><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-AsMut%3CBitSlice%3CO%2C%20T%3E%3E-for-BitVec%3CO%2C%20T%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#219-228">source</a><a href="#impl-AsMut%3CBitSlice%3CO%2C%20T%3E%3E-for-BitVec%3CO%2C%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.AsMut.html" title="trait core::convert::AsMut">AsMut</a>&lt;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_mut" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#225-227">source</a><a href="#method.as_mut" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/convert/trait.AsMut.html#tymethod.as_mut" class="fnname">as_mut</a>(&amp;mut self) -&gt; &amp;mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for &amp;'a <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/std/io/trait.Read.html" title="trait std::io::Read">Read</a> for &amp;'a <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,</span></span><span class="where fmt-newline">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/std/io/trait.Write.html" title="trait std::io::Write">Write</a> for &amp;'a mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,</span></span></code></span></span></span></span></h4></section></summary><div class='docblock'>Converts this type into a mutable reference of the (usually inferred) input type.</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-AsRef%3CBitSlice%3CO%2C%20T%3E%3E-for-BitVec%3CO%2C%20T%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#207-216">source</a><a href="#impl-AsRef%3CBitSlice%3CO%2C%20T%3E%3E-for-BitVec%3CO%2C%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_ref" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#213-215">source</a><a href="#method.as_ref" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/convert/trait.AsRef.html#tymethod.as_ref" class="fnname">as_ref</a>(&amp;self) -&gt; &amp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for &amp;'a <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/std/io/trait.Read.html" title="trait std::io::Read">Read</a> for &amp;'a <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,</span></span><span class="where fmt-newline">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/std/io/trait.Write.html" title="trait std::io::Write">Write</a> for &amp;'a mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,</span></span></code></span></span></span></span></h4></section></summary><div class='docblock'>Converts this type into a shared reference of the (usually inferred) input type.</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Binary-for-BitVec%3CO%2C%20T%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#333-342">source</a><a href="#impl-Binary-for-BitVec%3CO%2C%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/fmt/trait.Binary.html" title="trait core::fmt::Binary">Binary</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt-2" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#339-341">source</a><a href="#method.fmt-2" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/fmt/trait.Binary.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, fmt: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.65.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.65.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter.</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BitAnd%3CRhs%3E-for-BitVec%3CO%2C%20T%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/ops.rs.html#28-41">source</a><a href="#impl-BitAnd%3CRhs%3E-for-BitVec%3CO%2C%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T, Rhs&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/bit/trait.BitAnd.html" title="trait core::ops::bit::BitAnd">BitAnd</a>&lt;Rhs&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/bit/trait.BitAndAssign.html" title="trait core::ops::bit::BitAndAssign">BitAndAssign</a>&lt;Rhs&gt;,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Output" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Output" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.65.0/core/ops/bit/trait.BitAnd.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;</h4></section></summary><div class='docblock'>The resulting type after applying the <code>&amp;</code> operator.</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.bitand" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/ops.rs.html#37-40">source</a><a href="#method.bitand" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/ops/bit/trait.BitAnd.html#tymethod.bitand" class="fnname">bitand</a>(self, rhs: Rhs) -&gt; Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.65.0/core/ops/bit/trait.BitAnd.html#associatedtype.Output" title="type core::ops::bit::BitAnd::Output">Output</a></h4></section></summary><div class='docblock'>Performs the <code>&amp;</code> operation. <a href="https://doc.rust-lang.org/1.65.0/core/ops/bit/trait.BitAnd.html#tymethod.bitand">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BitAndAssign%3CRhs%3E-for-BitVec%3CO%2C%20T%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/ops.rs.html#44-54">source</a><a href="#impl-BitAndAssign%3CRhs%3E-for-BitVec%3CO%2C%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T, Rhs&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/bit/trait.BitAndAssign.html" title="trait core::ops::bit::BitAndAssign">BitAndAssign</a>&lt;Rhs&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/bit/trait.BitAndAssign.html" title="trait core::ops::bit::BitAndAssign">BitAndAssign</a>&lt;Rhs&gt;,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.bitand_assign" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/ops.rs.html#51-53">source</a><a href="#method.bitand_assign" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/ops/bit/trait.BitAndAssign.html#tymethod.bitand_assign" class="fnname">bitand_assign</a>(&amp;mut self, rhs: Rhs)</h4></section></summary><div class='docblock'>Performs the <code>&amp;=</code> operation. <a href="https://doc.rust-lang.org/1.65.0/core/ops/bit/trait.BitAndAssign.html#tymethod.bitand_assign">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BitField-for-BitVec%3CO%2C%20T%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/field.rs.html#1432-1461">source</a><a href="#impl-BitField-for-BitVec%3CO%2C%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.load_le" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/field.rs.html#1439-1442">source</a><a href="#method.load_le" class="anchor"></a><h4 class="code-header">fn <a href="../field/trait.BitField.html#tymethod.load_le" class="fnname">load_le</a>&lt;M&gt;(&amp;self) -&gt; M<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M: <a class="trait" href="../mem/trait.BitMemory.html" title="trait bitvec::mem::BitMemory">BitMemory</a>,</span></h4></section></summary><div class='docblock'>Loads from <code>self</code>, using little-endian element <code>T</code> ordering. <a href="../field/trait.BitField.html#tymethod.load_le">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.load_be" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/field.rs.html#1445-1448">source</a><a href="#method.load_be" class="anchor"></a><h4 class="code-header">fn <a href="../field/trait.BitField.html#tymethod.load_be" class="fnname">load_be</a>&lt;M&gt;(&amp;self) -&gt; M<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M: <a class="trait" href="../mem/trait.BitMemory.html" title="trait bitvec::mem::BitMemory">BitMemory</a>,</span></h4></section></summary><div class='docblock'>Loads from <code>self</code>, using big-endian element <code>T</code> ordering. <a href="../field/trait.BitField.html#tymethod.load_be">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.store_le" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/field.rs.html#1451-1454">source</a><a href="#method.store_le" class="anchor"></a><h4 class="code-header">fn <a href="../field/trait.BitField.html#tymethod.store_le" class="fnname">store_le</a>&lt;M&gt;(&amp;mut self, value: M)<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M: <a class="trait" href="../mem/trait.BitMemory.html" title="trait bitvec::mem::BitMemory">BitMemory</a>,</span></h4></section></summary><div class='docblock'>Stores into <code>self</code>, using little-endian element ordering. <a href="../field/trait.BitField.html#tymethod.store_le">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.store_be" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/field.rs.html#1457-1460">source</a><a href="#method.store_be" class="anchor"></a><h4 class="code-header">fn <a href="../field/trait.BitField.html#tymethod.store_be" class="fnname">store_be</a>&lt;M&gt;(&amp;mut self, value: M)<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M: <a class="trait" href="../mem/trait.BitMemory.html" title="trait bitvec::mem::BitMemory">BitMemory</a>,</span></h4></section></summary><div class='docblock'>Stores into <code>self</code>, using big-endian element ordering. <a href="../field/trait.BitField.html#tymethod.store_be">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.load" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/field.rs.html#323-330">source</a><a href="#method.load" class="anchor"></a><h4 class="code-header">fn <a href="../field/trait.BitField.html#method.load" class="fnname">load</a>&lt;M&gt;(&amp;self) -&gt; M<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M: <a class="trait" href="../mem/trait.BitMemory.html" title="trait bitvec::mem::BitMemory">BitMemory</a>,</span></h4></section></summary><div class='docblock'>Loads the bits in the <code>self</code> region into a local value. <a href="../field/trait.BitField.html#method.load">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.store" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/field.rs.html#374-381">source</a><a href="#method.store" class="anchor"></a><h4 class="code-header">fn <a href="../field/trait.BitField.html#method.store" class="fnname">store</a>&lt;M&gt;(&amp;mut self, value: M)<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M: <a class="trait" href="../mem/trait.BitMemory.html" title="trait bitvec::mem::BitMemory">BitMemory</a>,</span></h4></section></summary><div class='docblock'>Stores a sequence of bits from the user into the domain of <code>self</code>. <a href="../field/trait.BitField.html#method.store">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BitOr%3CRhs%3E-for-BitVec%3CO%2C%20T%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/ops.rs.html#57-70">source</a><a href="#impl-BitOr%3CRhs%3E-for-BitVec%3CO%2C%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T, Rhs&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/bit/trait.BitOr.html" title="trait core::ops::bit::BitOr">BitOr</a>&lt;Rhs&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/bit/trait.BitOrAssign.html" title="trait core::ops::bit::BitOrAssign">BitOrAssign</a>&lt;Rhs&gt;,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Output-1" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Output-1" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.65.0/core/ops/bit/trait.BitOr.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;</h4></section></summary><div class='docblock'>The resulting type after applying the <code>|</code> operator.</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.bitor" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/ops.rs.html#66-69">source</a><a href="#method.bitor" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/ops/bit/trait.BitOr.html#tymethod.bitor" class="fnname">bitor</a>(self, rhs: Rhs) -&gt; Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.65.0/core/ops/bit/trait.BitOr.html#associatedtype.Output" title="type core::ops::bit::BitOr::Output">Output</a></h4></section></summary><div class='docblock'>Performs the <code>|</code> operation. <a href="https://doc.rust-lang.org/1.65.0/core/ops/bit/trait.BitOr.html#tymethod.bitor">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BitOrAssign%3CRhs%3E-for-BitVec%3CO%2C%20T%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/ops.rs.html#73-83">source</a><a href="#impl-BitOrAssign%3CRhs%3E-for-BitVec%3CO%2C%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T, Rhs&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/bit/trait.BitOrAssign.html" title="trait core::ops::bit::BitOrAssign">BitOrAssign</a>&lt;Rhs&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/bit/trait.BitOrAssign.html" title="trait core::ops::bit::BitOrAssign">BitOrAssign</a>&lt;Rhs&gt;,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.bitor_assign" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/ops.rs.html#80-82">source</a><a href="#method.bitor_assign" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/ops/bit/trait.BitOrAssign.html#tymethod.bitor_assign" class="fnname">bitor_assign</a>(&amp;mut self, rhs: Rhs)</h4></section></summary><div class='docblock'>Performs the <code>|=</code> operation. <a href="https://doc.rust-lang.org/1.65.0/core/ops/bit/trait.BitOrAssign.html#tymethod.bitor_assign">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BitXor%3CRhs%3E-for-BitVec%3CO%2C%20T%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/ops.rs.html#86-99">source</a><a href="#impl-BitXor%3CRhs%3E-for-BitVec%3CO%2C%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T, Rhs&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/bit/trait.BitXor.html" title="trait core::ops::bit::BitXor">BitXor</a>&lt;Rhs&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/bit/trait.BitXorAssign.html" title="trait core::ops::bit::BitXorAssign">BitXorAssign</a>&lt;Rhs&gt;,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Output-2" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Output-2" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.65.0/core/ops/bit/trait.BitXor.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;</h4></section></summary><div class='docblock'>The resulting type after applying the <code>^</code> operator.</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.bitxor" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/ops.rs.html#95-98">source</a><a href="#method.bitxor" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/ops/bit/trait.BitXor.html#tymethod.bitxor" class="fnname">bitxor</a>(self, rhs: Rhs) -&gt; Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.65.0/core/ops/bit/trait.BitXor.html#associatedtype.Output" title="type core::ops::bit::BitXor::Output">Output</a></h4></section></summary><div class='docblock'>Performs the <code>^</code> operation. <a href="https://doc.rust-lang.org/1.65.0/core/ops/bit/trait.BitXor.html#tymethod.bitxor">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BitXorAssign%3CRhs%3E-for-BitVec%3CO%2C%20T%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/ops.rs.html#102-112">source</a><a href="#impl-BitXorAssign%3CRhs%3E-for-BitVec%3CO%2C%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T, Rhs&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/bit/trait.BitXorAssign.html" title="trait core::ops::bit::BitXorAssign">BitXorAssign</a>&lt;Rhs&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/bit/trait.BitXorAssign.html" title="trait core::ops::bit::BitXorAssign">BitXorAssign</a>&lt;Rhs&gt;,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.bitxor_assign" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/ops.rs.html#109-111">source</a><a href="#method.bitxor_assign" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/ops/bit/trait.BitXorAssign.html#tymethod.bitxor_assign" class="fnname">bitxor_assign</a>(&amp;mut self, rhs: Rhs)</h4></section></summary><div class='docblock'>Performs the <code>^=</code> operation. <a href="https://doc.rust-lang.org/1.65.0/core/ops/bit/trait.BitXorAssign.html#tymethod.bitxor_assign">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Borrow%3CBitSlice%3CO%2C%20T%3E%3E-for-BitVec%3CO%2C%20T%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#38-47">source</a><a href="#impl-Borrow%3CBitSlice%3CO%2C%20T%3E%3E-for-BitVec%3CO%2C%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#44-46">source</a><a href="#method.borrow" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/borrow/trait.Borrow.html#tymethod.borrow" class="fnname">borrow</a>(&amp;self) -&gt; &amp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for &amp;'a <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/std/io/trait.Read.html" title="trait std::io::Read">Read</a> for &amp;'a <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,</span></span><span class="where fmt-newline">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/std/io/trait.Write.html" title="trait std::io::Write">Write</a> for &amp;'a mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,</span></span></code></span></span></span></span></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.65.0/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BorrowMut%3CBitSlice%3CO%2C%20T%3E%3E-for-BitVec%3CO%2C%20T%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#50-59">source</a><a href="#impl-BorrowMut%3CBitSlice%3CO%2C%20T%3E%3E-for-BitVec%3CO%2C%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#56-58">source</a><a href="#method.borrow_mut" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fnname">borrow_mut</a>(&amp;mut self) -&gt; &amp;mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for &amp;'a <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/std/io/trait.Read.html" title="trait std::io::Read">Read</a> for &amp;'a <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,</span></span><span class="where fmt-newline">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/std/io/trait.Write.html" title="trait std::io::Write">Write</a> for &amp;'a mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,</span></span></code></span></span></span></span></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.65.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Clone-for-BitVec%3CO%2C%20T%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#61-75">source</a><a href="#impl-Clone-for-BitVec%3CO%2C%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#66-68">source</a><a href="#method.clone" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/clone/trait.Clone.html#tymethod.clone" class="fnname">clone</a>(&amp;self) -&gt; Self</h4></section></summary><div class='docblock'>Returns a copy of the value. <a href="https://doc.rust-lang.org/1.65.0/core/clone/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#70-74">source</a><a href="#method.clone_from" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/clone/trait.Clone.html#method.clone_from" class="fnname">clone_from</a>(&amp;mut self, source: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;</a>Self)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/1.65.0/core/clone/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Debug-for-BitVec%3CO%2C%20T%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#304-318">source</a><a href="#impl-Debug-for-BitVec%3CO%2C%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#310-317">source</a><a href="#method.fmt" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/fmt/trait.Debug.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, fmt: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.65.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.65.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.65.0/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Default-for-BitVec%3CO%2C%20T%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#293-302">source</a><a href="#impl-Default-for-BitVec%3CO%2C%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/default/trait.Default.html" title="trait core::default::Default">Default</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.default" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#299-301">source</a><a href="#method.default" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/default/trait.Default.html#tymethod.default" class="fnname">default</a>() -&gt; Self</h4></section></summary><div class='docblock'>Returns the “default value” for a type. <a href="https://doc.rust-lang.org/1.65.0/core/default/trait.Default.html#tymethod.default">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Deref-for-BitVec%3CO%2C%20T%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/ops.rs.html#115-126">source</a><a href="#impl-Deref-for-BitVec%3CO%2C%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Target" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Target" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.65.0/core/ops/deref/trait.Deref.html#associatedtype.Target" class="associatedtype">Target</a> = <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;</h4></section></summary><div class='docblock'>The resulting type after dereferencing.</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.deref" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/ops.rs.html#123-125">source</a><a href="#method.deref" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/ops/deref/trait.Deref.html#tymethod.deref" class="fnname">deref</a>(&amp;self) -&gt; &amp;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.65.0/core/ops/deref/trait.Deref.html#associatedtype.Target" title="type core::ops::deref::Deref::Target">Target</a></h4></section></summary><div class='docblock'>Dereferences the value.</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-DerefMut-for-BitVec%3CO%2C%20T%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/ops.rs.html#129-138">source</a><a href="#impl-DerefMut-for-BitVec%3CO%2C%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/deref/trait.DerefMut.html" title="trait core::ops::deref::DerefMut">DerefMut</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.deref_mut" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/ops.rs.html#135-137">source</a><a href="#method.deref_mut" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/ops/deref/trait.DerefMut.html#tymethod.deref_mut" class="fnname">deref_mut</a>(&amp;mut self) -&gt; &amp;mut Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.65.0/core/ops/deref/trait.Deref.html#associatedtype.Target" title="type core::ops::deref::Deref::Target">Target</a></h4></section></summary><div class='docblock'>Mutably dereferences the value.</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Display-for-BitVec%3CO%2C%20T%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#321-330">source</a><a href="#impl-Display-for-BitVec%3CO%2C%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/fmt/trait.Display.html" title="trait core::fmt::Display">Display</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt-1" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#327-329">source</a><a href="#method.fmt-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/fmt/trait.Display.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, fmt: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.65.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.65.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.65.0/core/fmt/trait.Display.html#tymethod.fmt">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Drop-for-BitVec%3CO%2C%20T%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/ops.rs.html#141-151">source</a><a href="#impl-Drop-for-BitVec%3CO%2C%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/drop/trait.Drop.html" title="trait core::ops::drop::Drop">Drop</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.drop" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/ops.rs.html#147-150">source</a><a href="#method.drop" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/ops/drop/trait.Drop.html#tymethod.drop" class="fnname">drop</a>(&amp;mut self)</h4></section></summary><div class='docblock'>Executes the destructor for this type. <a href="https://doc.rust-lang.org/1.65.0/core/ops/drop/trait.Drop.html#tymethod.drop">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Extend%3C%26%27a%20T%3E-for-BitVec%3CO%2C%20T%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/iter.rs.html#139-151">source</a><a href="#impl-Extend%3C%26%27a%20T%3E-for-BitVec%3CO%2C%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.Extend.html" title="trait core::iter::traits::collect::Extend">Extend</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;'a </a>T&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.extend-4" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/iter.rs.html#145-150">source</a><a href="#method.extend-4" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.Extend.html#tymethod.extend" class="fnname">extend</a>&lt;I&gt;(&amp;mut self, iter: I)<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;'a </a>T&gt;,</span></h4></section></summary><div class='docblock'>Extends a collection with the contents of an iterator. <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.Extend.html#tymethod.extend">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.extend_one-4" class="method trait-impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/core/iter/traits/collect.rs.html#371">source</a><a href="#method.extend_one-4" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.Extend.html#method.extend_one" class="fnname">extend_one</a>(&amp;mut self, item: A)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>extend_one</code>)</span></div></span><div class='docblock'>Extends a collection with exactly one element.</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.extend_reserve-4" class="method trait-impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/core/iter/traits/collect.rs.html#379">source</a><a href="#method.extend_reserve-4" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.Extend.html#method.extend_reserve" class="fnname">extend_reserve</a>(&amp;mut self, additional: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>extend_one</code>)</span></div></span><div class='docblock'>Reserves capacity in a collection for the given number of additional elements. <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.Extend.html#method.extend_reserve">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Extend%3C%26%27a%20bool%3E-for-BitVec%3CO%2C%20T%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/iter.rs.html#96-106">source</a><a href="#impl-Extend%3C%26%27a%20bool%3E-for-BitVec%3CO%2C%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.Extend.html" title="trait core::iter::traits::collect::Extend">Extend</a>&lt;&amp;'a <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a>&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.extend-1" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/iter.rs.html#102-105">source</a><a href="#method.extend-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.Extend.html#tymethod.extend" class="fnname">extend</a>&lt;I&gt;(&amp;mut self, iter: I)<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = &amp;'a <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a>&gt;,</span></h4></section></summary><div class='docblock'>Extends a collection with the contents of an iterator. <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.Extend.html#tymethod.extend">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.extend_one-1" class="method trait-impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/core/iter/traits/collect.rs.html#371">source</a><a href="#method.extend_one-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.Extend.html#method.extend_one" class="fnname">extend_one</a>(&amp;mut self, item: A)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>extend_one</code>)</span></div></span><div class='docblock'>Extends a collection with exactly one element.</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.extend_reserve-1" class="method trait-impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/core/iter/traits/collect.rs.html#379">source</a><a href="#method.extend_reserve-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.Extend.html#method.extend_reserve" class="fnname">extend_reserve</a>(&amp;mut self, additional: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>extend_one</code>)</span></div></span><div class='docblock'>Reserves capacity in a collection for the given number of additional elements. <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.Extend.html#method.extend_reserve">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Extend%3CBitRef%3C%27a%2C%20M%2C%20O2%2C%20T2%3E%3E-for-BitVec%3CO1%2C%20T1%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/iter.rs.html#110-123">source</a><a href="#impl-Extend%3CBitRef%3C%27a%2C%20M%2C%20O2%2C%20T2%3E%3E-for-BitVec%3CO1%2C%20T1%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;'a, M, O1, O2, T1, T2&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.Extend.html" title="trait core::iter::traits::collect::Extend">Extend</a>&lt;<a class="struct" href="../prelude/struct.BitRef.html" title="struct bitvec::prelude::BitRef">BitRef</a>&lt;'a, M, O2, T2&gt;&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O1, T1&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M: <a class="trait" href="../ptr/trait.Mutability.html" title="trait bitvec::ptr::Mutability">Mutability</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O1: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T1: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section></summary><div class="docblock"><p><em><strong>DO NOT</strong></em> use this. You clearly have a <a href="../slice/struct.BitSlice.html" title="BitSlice"><code>BitSlice</code></a>. Use
<a href="struct.BitVec.html#method.extend_from_bitslice" title="BitVec::extend_from_bitslice"><code>BitVec::extend_from_bitslice</code></a>.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.extend-2" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/iter.rs.html#119-122">source</a><a href="#method.extend-2" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.Extend.html#tymethod.extend" class="fnname">extend</a>&lt;I&gt;(&amp;mut self, iter: I)<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = <a class="struct" href="../prelude/struct.BitRef.html" title="struct bitvec::prelude::BitRef">BitRef</a>&lt;'a, M, O2, T2&gt;&gt;,</span></h4></section></summary><div class='docblock'>Extends a collection with the contents of an iterator. <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.Extend.html#tymethod.extend">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.extend_one-2" class="method trait-impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/core/iter/traits/collect.rs.html#371">source</a><a href="#method.extend_one-2" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.Extend.html#method.extend_one" class="fnname">extend_one</a>(&amp;mut self, item: A)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>extend_one</code>)</span></div></span><div class='docblock'>Extends a collection with exactly one element.</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.extend_reserve-2" class="method trait-impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/core/iter/traits/collect.rs.html#379">source</a><a href="#method.extend_reserve-2" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.Extend.html#method.extend_reserve" class="fnname">extend_reserve</a>(&amp;mut self, additional: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>extend_one</code>)</span></div></span><div class='docblock'>Reserves capacity in a collection for the given number of additional elements. <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.Extend.html#method.extend_reserve">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Extend%3CT%3E-for-BitVec%3CO%2C%20T%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/iter.rs.html#125-137">source</a><a href="#impl-Extend%3CT%3E-for-BitVec%3CO%2C%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.Extend.html" title="trait core::iter::traits::collect::Extend">Extend</a>&lt;T&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.extend-3" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/iter.rs.html#131-136">source</a><a href="#method.extend-3" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.Extend.html#tymethod.extend" class="fnname">extend</a>&lt;I&gt;(&amp;mut self, iter: I)<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = T&gt;,</span></h4></section></summary><div class='docblock'>Extends a collection with the contents of an iterator. <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.Extend.html#tymethod.extend">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.extend_one-3" class="method trait-impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/core/iter/traits/collect.rs.html#371">source</a><a href="#method.extend_one-3" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.Extend.html#method.extend_one" class="fnname">extend_one</a>(&amp;mut self, item: A)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>extend_one</code>)</span></div></span><div class='docblock'>Extends a collection with exactly one element.</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.extend_reserve-3" class="method trait-impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/core/iter/traits/collect.rs.html#379">source</a><a href="#method.extend_reserve-3" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.Extend.html#method.extend_reserve" class="fnname">extend_reserve</a>(&amp;mut self, additional: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>extend_one</code>)</span></div></span><div class='docblock'>Reserves capacity in a collection for the given number of additional elements. <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.Extend.html#method.extend_reserve">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Extend%3Cbool%3E-for-BitVec%3CO%2C%20T%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/iter.rs.html#61-94">source</a><a href="#impl-Extend%3Cbool%3E-for-BitVec%3CO%2C%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.Extend.html" title="trait core::iter::traits::collect::Extend">Extend</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a>&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section></summary><div class="docblock"><p>Extends a <code>BitVec</code> from a <code>bool</code> producer.</p>
<h4 id="notes"><a href="#notes">Notes</a></h4>
<p>This is the second-slowest possible way to append bits to a bit-vector, second
only to <code>for bit in bits { bitvec.push(bit); }</code>. <strong>Do not</strong> use this if you have
any other choice.</p>
<p>If you are extending a bit-vector from the contents of a bit-slice, use
<a href="struct.BitVec.html#method.extend_from_bitslice" title="BitVec::extend_from_bitslice"><code>BitVec::extend_from_bitslice</code></a> instead. That method will never be <em>slower</em>
than this. When the source bit-slice does not match the destination bit-vector’s
type parameters, it will still be faster by virtue of knowing the bit-slice
length upfront; when the type parameters match, it will optimize to <code>memcpy</code>
with some bookkeeping.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.extend" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/iter.rs.html#67-93">source</a><a href="#method.extend" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.Extend.html#tymethod.extend" class="fnname">extend</a>&lt;I&gt;(&amp;mut self, iter: I)<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a>&gt;,</span></h4></section></summary><div class='docblock'>Extends a collection with the contents of an iterator. <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.Extend.html#tymethod.extend">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.extend_one" class="method trait-impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/core/iter/traits/collect.rs.html#371">source</a><a href="#method.extend_one" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.Extend.html#method.extend_one" class="fnname">extend_one</a>(&amp;mut self, item: A)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>extend_one</code>)</span></div></span><div class='docblock'>Extends a collection with exactly one element.</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.extend_reserve" class="method trait-impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/core/iter/traits/collect.rs.html#379">source</a><a href="#method.extend_reserve" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.Extend.html#method.extend_reserve" class="fnname">extend_reserve</a>(&amp;mut self, additional: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>extend_one</code>)</span></div></span><div class='docblock'>Reserves capacity in a collection for the given number of additional elements. <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.Extend.html#method.extend_reserve">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-From%3C%26%27a%20BitSlice%3CO%2C%20T%3E%3E-for-BitVec%3CO%2C%20T%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#231-240">source</a><a href="#impl-From%3C%26%27a%20BitSlice%3CO%2C%20T%3E%3E-for-BitVec%3CO%2C%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;&amp;'a <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from-1" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#237-239">source</a><a href="#method.from-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(slice: &amp;'a <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;) -&gt; Self</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-From%3C%26%27a%20mut%20BitSlice%3CO%2C%20T%3E%3E-for-BitVec%3CO%2C%20T%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#243-252">source</a><a href="#impl-From%3C%26%27a%20mut%20BitSlice%3CO%2C%20T%3E%3E-for-BitVec%3CO%2C%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;&amp;'a mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from-2" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#249-251">source</a><a href="#method.from-2" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(slice: &amp;'a mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;) -&gt; Self</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-From%3CBitBox%3CO%2C%20T%3E%3E-for-BitVec%3CO%2C%20T%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#255-264">source</a><a href="#impl-From%3CBitBox%3CO%2C%20T%3E%3E-for-BitVec%3CO%2C%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="../boxed/struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;O, T&gt;&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from-3" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#261-263">source</a><a href="#method.from-3" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(boxed: <a class="struct" href="../boxed/struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;O, T&gt;) -&gt; Self</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-From%3CBitVec%3CO%2C%20T%3E%3E-for-BitBox%3CO%2C%20T%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/boxed/traits.rs.html#244-253">source</a><a href="#impl-From%3CBitVec%3CO%2C%20T%3E%3E-for-BitBox%3CO%2C%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;&gt; for <a class="struct" href="../boxed/struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/boxed/traits.rs.html#250-252">source</a><a href="#method.from" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(bv: <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;) -&gt; Self</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-From%3CBitVec%3CO%2C%20T%3E%3E-for-Vec%3CT%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#267-276">source</a><a href="#impl-From%3CBitVec%3CO%2C%20T%3E%3E-for-Vec%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;&gt; for <a class="struct" href="https://doc.rust-lang.org/1.65.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from-4" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#273-275">source</a><a href="#method.from-4" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(bv: <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;) -&gt; Self</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-FromIterator%3C%26%27a%20T%3E-for-BitVec%3CO%2C%20T%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/iter.rs.html#215-232">source</a><a href="#impl-FromIterator%3C%26%27a%20T%3E-for-BitVec%3CO%2C%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.FromIterator.html" title="trait core::iter::traits::collect::FromIterator">FromIterator</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;'a </a>T&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from_iter-4" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/iter.rs.html#221-231">source</a><a href="#method.from_iter-4" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.FromIterator.html#tymethod.from_iter" class="fnname">from_iter</a>&lt;I&gt;(iter: I) -&gt; Self<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;'a </a>T&gt;,</span></h4></section></summary><div class='docblock'>Creates a value from an iterator. <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.FromIterator.html#tymethod.from_iter">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-FromIterator%3C%26%27a%20bool%3E-for-BitVec%3CO%2C%20T%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/iter.rs.html#183-193">source</a><a href="#impl-FromIterator%3C%26%27a%20bool%3E-for-BitVec%3CO%2C%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.FromIterator.html" title="trait core::iter::traits::collect::FromIterator">FromIterator</a>&lt;&amp;'a <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a>&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from_iter-2" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/iter.rs.html#189-192">source</a><a href="#method.from_iter-2" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.FromIterator.html#tymethod.from_iter" class="fnname">from_iter</a>&lt;I&gt;(iter: I) -&gt; Self<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = &amp;'a <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a>&gt;,</span></h4></section></summary><div class='docblock'>Creates a value from an iterator. <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.FromIterator.html#tymethod.from_iter">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-FromIterator%3CBitRef%3C%27a%2C%20M%2C%20O2%2C%20T2%3E%3E-for-BitVec%3CO1%2C%20T1%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/iter.rs.html#167-181">source</a><a href="#impl-FromIterator%3CBitRef%3C%27a%2C%20M%2C%20O2%2C%20T2%3E%3E-for-BitVec%3CO1%2C%20T1%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;'a, M, O1, O2, T1, T2&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.FromIterator.html" title="trait core::iter::traits::collect::FromIterator">FromIterator</a>&lt;<a class="struct" href="../prelude/struct.BitRef.html" title="struct bitvec::prelude::BitRef">BitRef</a>&lt;'a, M, O2, T2&gt;&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O1, T1&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M: <a class="trait" href="../ptr/trait.Mutability.html" title="trait bitvec::ptr::Mutability">Mutability</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O1: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T1: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section></summary><div class="docblock"><p><em><strong>DO NOT</strong></em> use this. You clearly have a <a href="../slice/struct.BitSlice.html" title="BitSlice"><code>BitSlice</code></a>. Use
<a href="struct.BitVec.html#method.from_bitslice" title="BitVec::from_bitslice"><code>BitVec::from_bitslice</code></a> instead.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from_iter-1" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/iter.rs.html#177-180">source</a><a href="#method.from_iter-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.FromIterator.html#tymethod.from_iter" class="fnname">from_iter</a>&lt;I&gt;(iter: I) -&gt; Self<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = <a class="struct" href="../prelude/struct.BitRef.html" title="struct bitvec::prelude::BitRef">BitRef</a>&lt;'a, M, O2, T2&gt;&gt;,</span></h4></section></summary><div class='docblock'>Creates a value from an iterator. <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.FromIterator.html#tymethod.from_iter">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-FromIterator%3CT%3E-for-BitVec%3CO%2C%20T%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/iter.rs.html#203-213">source</a><a href="#impl-FromIterator%3CT%3E-for-BitVec%3CO%2C%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.FromIterator.html" title="trait core::iter::traits::collect::FromIterator">FromIterator</a>&lt;T&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section></summary><div class="docblock"><p>Collect a sequence of memory elements into a bit-vector.</p>
<p>This is a short-hand for, and implemented as, <code>iter.collect::&lt;Vec&lt;_&gt;&gt;().into()</code>.</p>
<p>This is not a standard-library API, and was added for <a href="https://github.com/bitvecto-rs/bitvec/issues/83">Issue #83</a>.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from_iter-3" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/iter.rs.html#209-212">source</a><a href="#method.from_iter-3" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.FromIterator.html#tymethod.from_iter" class="fnname">from_iter</a>&lt;I&gt;(iter: I) -&gt; Self<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = T&gt;,</span></h4></section></summary><div class='docblock'>Creates a value from an iterator. <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.FromIterator.html#tymethod.from_iter">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-FromIterator%3Cbool%3E-for-BitVec%3CO%2C%20T%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/iter.rs.html#153-163">source</a><a href="#impl-FromIterator%3Cbool%3E-for-BitVec%3CO%2C%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.FromIterator.html" title="trait core::iter::traits::collect::FromIterator">FromIterator</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a>&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from_iter" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/iter.rs.html#159-162">source</a><a href="#method.from_iter" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.FromIterator.html#tymethod.from_iter" class="fnname">from_iter</a>&lt;I&gt;(iter: I) -&gt; Self<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a>&gt;,</span></h4></section></summary><div class='docblock'>Creates a value from an iterator. <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.FromIterator.html#tymethod.from_iter">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Hash-for-BitVec%3CO%2C%20T%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#381-391">source</a><a href="#impl-Hash-for-BitVec%3CO%2C%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.hash" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#387-390">source</a><a href="#method.hash" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/hash/trait.Hash.html#tymethod.hash" class="fnname">hash</a>&lt;H&gt;(&amp;self, state: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;mut </a>H)<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;H: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/hash/trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a>,</span></h4></section></summary><div class='docblock'>Feeds this value into the given <a href="https://doc.rust-lang.org/1.65.0/core/hash/trait.Hasher.html" title="Hasher"><code>Hasher</code></a>. <a href="https://doc.rust-lang.org/1.65.0/core/hash/trait.Hash.html#tymethod.hash">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.hash_slice" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.3.0">1.3.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.65.0/src/core/hash/mod.rs.html#237-239">source</a></span><a href="#method.hash_slice" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/hash/trait.Hash.html#method.hash_slice" class="fnname">hash_slice</a>&lt;H&gt;(data: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.slice.html">[Self]</a>, state: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;mut </a>H)<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;H: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/hash/trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a>,</span></h4></section></summary><div class='docblock'>Feeds a slice of this type into the given <a href="https://doc.rust-lang.org/1.65.0/core/hash/trait.Hasher.html" title="Hasher"><code>Hasher</code></a>. <a href="https://doc.rust-lang.org/1.65.0/core/hash/trait.Hash.html#method.hash_slice">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Index%3CIdx%3E-for-BitVec%3CO%2C%20T%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/ops.rs.html#154-166">source</a><a href="#impl-Index%3CIdx%3E-for-BitVec%3CO%2C%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T, Idx&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/index/trait.Index.html" title="trait core::ops::index::Index">Index</a>&lt;Idx&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/index/trait.Index.html" title="trait core::ops::index::Index">Index</a>&lt;Idx&gt;,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Output-3" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Output-3" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.65.0/core/ops/index/trait.Index.html#associatedtype.Output" class="associatedtype">Output</a> = &lt;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt; as <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/index/trait.Index.html" title="trait core::ops::index::Index">Index</a>&lt;Idx&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.65.0/core/ops/index/trait.Index.html#associatedtype.Output" title="type core::ops::index::Index::Output">Output</a></h4></section></summary><div class='docblock'>The returned type after indexing.</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.index" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/ops.rs.html#163-165">source</a><a href="#method.index" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/ops/index/trait.Index.html#tymethod.index" class="fnname">index</a>(&amp;self, index: Idx) -&gt; &amp;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.65.0/core/ops/index/trait.Index.html#associatedtype.Output" title="type core::ops::index::Index::Output">Output</a></h4></section></summary><div class='docblock'>Performs the indexing (<code>container[index]</code>) operation. <a href="https://doc.rust-lang.org/1.65.0/core/ops/index/trait.Index.html#tymethod.index">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-IndexMut%3CIdx%3E-for-BitVec%3CO%2C%20T%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/ops.rs.html#169-179">source</a><a href="#impl-IndexMut%3CIdx%3E-for-BitVec%3CO%2C%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T, Idx&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/index/trait.IndexMut.html" title="trait core::ops::index::IndexMut">IndexMut</a>&lt;Idx&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/index/trait.IndexMut.html" title="trait core::ops::index::IndexMut">IndexMut</a>&lt;Idx&gt;,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.index_mut" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/ops.rs.html#176-178">source</a><a href="#method.index_mut" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/ops/index/trait.IndexMut.html#tymethod.index_mut" class="fnname">index_mut</a>(&amp;mut self, index: Idx) -&gt; &amp;mut Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.65.0/core/ops/index/trait.Index.html#associatedtype.Output" title="type core::ops::index::Index::Output">Output</a></h4></section></summary><div class='docblock'>Performs the mutable indexing (<code>container[index]</code>) operation. <a href="https://doc.rust-lang.org/1.65.0/core/ops/index/trait.IndexMut.html#tymethod.index_mut">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-IntoIterator-for-%26%27a%20BitVec%3CO%2C%20T%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/iter.rs.html#250-262">source</a><a href="#impl-IntoIterator-for-%26%27a%20BitVec%3CO%2C%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a> for &amp;'a <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.IntoIter-1" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.IntoIter-1" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" class="associatedtype">IntoIter</a> = &lt;&amp;'a <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt; as <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" title="type core::iter::traits::collect::IntoIterator::IntoIter">IntoIter</a></h4></section></summary><div class='docblock'>Which kind of iterator are we turning this into?</div></details><details class="rustdoc-toggle" open><summary><section id="associatedtype.Item-1" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Item-1" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.Item" class="associatedtype">Item</a> = &lt;&amp;'a <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt; as <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.Item" title="type core::iter::traits::collect::IntoIterator::Item">Item</a></h4></section></summary><div class='docblock'>The type of the elements being iterated over.</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.into_iter-1" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/iter.rs.html#259-261">source</a><a href="#method.into_iter-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.IntoIterator.html#tymethod.into_iter" class="fnname">into_iter</a>(self) -&gt; Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" title="type core::iter::traits::collect::IntoIterator::IntoIter">IntoIter</a></h4></section></summary><div class='docblock'>Creates an iterator from a value. <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.IntoIterator.html#tymethod.into_iter">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-IntoIterator-for-%26%27a%20mut%20BitVec%3CO%2C%20T%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/iter.rs.html#265-277">source</a><a href="#impl-IntoIterator-for-%26%27a%20mut%20BitVec%3CO%2C%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a> for &amp;'a mut <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.IntoIter-2" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.IntoIter-2" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" class="associatedtype">IntoIter</a> = &lt;&amp;'a mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt; as <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" title="type core::iter::traits::collect::IntoIterator::IntoIter">IntoIter</a></h4></section></summary><div class='docblock'>Which kind of iterator are we turning this into?</div></details><details class="rustdoc-toggle" open><summary><section id="associatedtype.Item-2" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Item-2" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.Item" class="associatedtype">Item</a> = &lt;&amp;'a mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt; as <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.Item" title="type core::iter::traits::collect::IntoIterator::Item">Item</a></h4></section></summary><div class='docblock'>The type of the elements being iterated over.</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.into_iter-2" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/iter.rs.html#274-276">source</a><a href="#method.into_iter-2" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.IntoIterator.html#tymethod.into_iter" class="fnname">into_iter</a>(self) -&gt; Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" title="type core::iter::traits::collect::IntoIterator::IntoIter">IntoIter</a></h4></section></summary><div class='docblock'>Creates an iterator from a value. <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.IntoIterator.html#tymethod.into_iter">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-IntoIterator-for-BitVec%3CO%2C%20T%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/iter.rs.html#235-247">source</a><a href="#impl-IntoIterator-for-BitVec%3CO%2C%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.IntoIter" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.IntoIter" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" class="associatedtype">IntoIter</a> = &lt;<a class="struct" href="../boxed/struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;O, T&gt; as <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" title="type core::iter::traits::collect::IntoIterator::IntoIter">IntoIter</a></h4></section></summary><div class='docblock'>Which kind of iterator are we turning this into?</div></details><details class="rustdoc-toggle" open><summary><section id="associatedtype.Item" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Item" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.Item" class="associatedtype">Item</a> = &lt;<a class="struct" href="../boxed/struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;O, T&gt; as <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.Item" title="type core::iter::traits::collect::IntoIterator::Item">Item</a></h4></section></summary><div class='docblock'>The type of the elements being iterated over.</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.into_iter" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/iter.rs.html#244-246">source</a><a href="#method.into_iter" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.IntoIterator.html#tymethod.into_iter" class="fnname">into_iter</a>(self) -&gt; Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" title="type core::iter::traits::collect::IntoIterator::IntoIter">IntoIter</a></h4></section></summary><div class='docblock'>Creates an iterator from a value. <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.IntoIterator.html#tymethod.into_iter">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-LowerHex-for-BitVec%3CO%2C%20T%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#345-354">source</a><a href="#impl-LowerHex-for-BitVec%3CO%2C%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/fmt/trait.LowerHex.html" title="trait core::fmt::LowerHex">LowerHex</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt-3" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#351-353">source</a><a href="#method.fmt-3" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/fmt/trait.LowerHex.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, fmt: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.65.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.65.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter.</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Not-for-BitVec%3CO%2C%20T%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/ops.rs.html#186-200">source</a><a href="#impl-Not-for-BitVec%3CO%2C%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/bit/trait.Not.html" title="trait core::ops::bit::Not">Not</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section></summary><div class="docblock"><p>This implementation inverts all elements in the live buffer. You cannot rely
on the value of bits in the buffer that are outside the domain of
<a href="struct.BitVec.html#method.as_mut_bitslice" title="BitVec::as_mut_bitslice"><code>BitVec::as_mut_bitslice</code></a>.</p>
</div><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Output-4" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Output-4" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.65.0/core/ops/bit/trait.Not.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;</h4></section></summary><div class='docblock'>The resulting type after applying the <code>!</code> operator.</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.not" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/ops.rs.html#194-199">source</a><a href="#method.not" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/ops/bit/trait.Not.html#tymethod.not" class="fnname">not</a>(self) -&gt; Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.65.0/core/ops/bit/trait.Not.html#associatedtype.Output" title="type core::ops::bit::Not::Output">Output</a></h4></section></summary><div class='docblock'>Performs the unary <code>!</code> operation. <a href="https://doc.rust-lang.org/1.65.0/core/ops/bit/trait.Not.html#tymethod.not">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Octal-for-BitVec%3CO%2C%20T%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#357-366">source</a><a href="#impl-Octal-for-BitVec%3CO%2C%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/fmt/trait.Octal.html" title="trait core::fmt::Octal">Octal</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt-4" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#363-365">source</a><a href="#method.fmt-4" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/fmt/trait.Octal.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, fmt: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.65.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.65.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter.</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Ord-for-BitVec%3CO%2C%20T%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#85-94">source</a><a href="#impl-Ord-for-BitVec%3CO%2C%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.Ord.html" title="trait core::cmp::Ord">Ord</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.cmp" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#91-93">source</a><a href="#method.cmp" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.Ord.html#tymethod.cmp" class="fnname">cmp</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;</a>Self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.65.0/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a></h4></section></summary><div class='docblock'>This method returns an <a href="https://doc.rust-lang.org/1.65.0/core/cmp/enum.Ordering.html" title="Ordering"><code>Ordering</code></a> between <code>self</code> and <code>other</code>. <a href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.Ord.html#tymethod.cmp">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.max" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.65.0/src/core/cmp.rs.html#804-807">source</a></span><a href="#method.max" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.Ord.html#method.max" class="fnname">max</a>(self, other: Self) -&gt; Self</h4></section></summary><div class='docblock'>Compares and returns the maximum of two values. <a href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.Ord.html#method.max">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.min" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.65.0/src/core/cmp.rs.html#831-834">source</a></span><a href="#method.min" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.Ord.html#method.min" class="fnname">min</a>(self, other: Self) -&gt; Self</h4></section></summary><div class='docblock'>Compares and returns the minimum of two values. <a href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.Ord.html#method.min">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.clamp" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.50.0">1.50.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.65.0/src/core/cmp.rs.html#863-867">source</a></span><a href="#method.clamp" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.Ord.html#method.clamp" class="fnname">clamp</a>(self, min: Self, max: Self) -&gt; Self<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;Self&gt;,</span></h4></section></summary><div class='docblock'>Restrict a value to a certain interval. <a href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.Ord.html#method.clamp">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-PartialEq%3CBitVec%3CO2%2C%20T2%3E%3E-for-%26BitSlice%3CO1%2C%20T1%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#111-122">source</a><a href="#impl-PartialEq%3CBitVec%3CO2%2C%20T2%3E%3E-for-%26BitSlice%3CO1%2C%20T1%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O1, O2, T1, T2&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O2, T2&gt;&gt; for &amp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O1, T1&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O1: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T1: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.eq-1" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#119-121">source</a><a href="#method.eq-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialEq.html#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;<a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O2, T2&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>. <a href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialEq.html#tymethod.eq">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.ne-1" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.65.0/src/core/cmp.rs.html#236">source</a></span><a href="#method.ne-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialEq.html#method.ne" class="fnname">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>!=</code>. The default implementation is almost always
sufficient, and should not be overridden without very good reason. <a href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialEq.html#method.ne">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-PartialEq%3CBitVec%3CO2%2C%20T2%3E%3E-for-%26mut%20BitSlice%3CO1%2C%20T1%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#125-136">source</a><a href="#impl-PartialEq%3CBitVec%3CO2%2C%20T2%3E%3E-for-%26mut%20BitSlice%3CO1%2C%20T1%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O1, O2, T1, T2&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O2, T2&gt;&gt; for &amp;mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O1, T1&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O1: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T1: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.eq-2" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#133-135">source</a><a href="#method.eq-2" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialEq.html#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;<a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O2, T2&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>. <a href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialEq.html#tymethod.eq">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.ne-2" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.65.0/src/core/cmp.rs.html#236">source</a></span><a href="#method.ne-2" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialEq.html#method.ne" class="fnname">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>!=</code>. The default implementation is almost always
sufficient, and should not be overridden without very good reason. <a href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialEq.html#method.ne">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-PartialEq%3CBitVec%3CO2%2C%20T2%3E%3E-for-BitSlice%3CO1%2C%20T1%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#97-108">source</a><a href="#impl-PartialEq%3CBitVec%3CO2%2C%20T2%3E%3E-for-BitSlice%3CO1%2C%20T1%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O1, O2, T1, T2&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O2, T2&gt;&gt; for <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O1, T1&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O1: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T1: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.eq" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#105-107">source</a><a href="#method.eq" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialEq.html#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;<a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O2, T2&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>. <a href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialEq.html#tymethod.eq">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.ne" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.65.0/src/core/cmp.rs.html#236">source</a></span><a href="#method.ne" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialEq.html#method.ne" class="fnname">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>!=</code>. The default implementation is almost always
sufficient, and should not be overridden without very good reason. <a href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialEq.html#method.ne">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-PartialEq%3CRhs%3E-for-BitVec%3CO%2C%20T%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#139-149">source</a><a href="#impl-PartialEq%3CRhs%3E-for-BitVec%3CO%2C%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T, Rhs&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;Rhs&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;Rhs: ?<a class="trait" href="https://doc.rust-lang.org/1.65.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;&gt;,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.eq-3" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#146-148">source</a><a href="#method.eq-3" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialEq.html#tymethod.eq" class="fnname">eq</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>. <a href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialEq.html#tymethod.eq">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.ne-3" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.65.0/src/core/cmp.rs.html#236">source</a></span><a href="#method.ne-3" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialEq.html#method.ne" class="fnname">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>!=</code>. The default implementation is almost always
sufficient, and should not be overridden without very good reason. <a href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialEq.html#method.ne">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-PartialOrd%3CBitVec%3CO2%2C%20T2%3E%3E-for-%26%27a%20BitSlice%3CO1%2C%20T1%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#166-177">source</a><a href="#impl-PartialOrd%3CBitVec%3CO2%2C%20T2%3E%3E-for-%26%27a%20BitSlice%3CO1%2C%20T1%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;'a, O1, O2, T1, T2&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;<a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O2, T2&gt;&gt; for &amp;'a <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O1, T1&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O1: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T1: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.partial_cmp-1" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#174-176">source</a><a href="#method.partial_cmp-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fnname">partial_cmp</a>(&amp;self, other: &amp;<a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O2, T2&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.65.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.65.0/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</h4></section></summary><div class='docblock'>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.lt-1" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.65.0/src/core/cmp.rs.html#1138">source</a></span><a href="#method.lt-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialOrd.html#method.lt" class="fnname">lt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialOrd.html#method.lt">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.le-1" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.65.0/src/core/cmp.rs.html#1157">source</a></span><a href="#method.le-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialOrd.html#method.le" class="fnname">le</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code>
operator. <a href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialOrd.html#method.le">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.gt-1" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.65.0/src/core/cmp.rs.html#1175">source</a></span><a href="#method.gt-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialOrd.html#method.gt" class="fnname">gt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialOrd.html#method.gt">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.ge-1" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.65.0/src/core/cmp.rs.html#1194">source</a></span><a href="#method.ge-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialOrd.html#method.ge" class="fnname">ge</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code>
operator. <a href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialOrd.html#method.ge">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-PartialOrd%3CBitVec%3CO2%2C%20T2%3E%3E-for-%26%27a%20mut%20BitSlice%3CO1%2C%20T1%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#180-191">source</a><a href="#impl-PartialOrd%3CBitVec%3CO2%2C%20T2%3E%3E-for-%26%27a%20mut%20BitSlice%3CO1%2C%20T1%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;'a, O1, O2, T1, T2&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;<a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O2, T2&gt;&gt; for &amp;'a mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O1, T1&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O1: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T1: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.partial_cmp-2" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#188-190">source</a><a href="#method.partial_cmp-2" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fnname">partial_cmp</a>(&amp;self, other: &amp;<a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O2, T2&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.65.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.65.0/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</h4></section></summary><div class='docblock'>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.lt-2" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.65.0/src/core/cmp.rs.html#1138">source</a></span><a href="#method.lt-2" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialOrd.html#method.lt" class="fnname">lt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialOrd.html#method.lt">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.le-2" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.65.0/src/core/cmp.rs.html#1157">source</a></span><a href="#method.le-2" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialOrd.html#method.le" class="fnname">le</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code>
operator. <a href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialOrd.html#method.le">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.gt-2" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.65.0/src/core/cmp.rs.html#1175">source</a></span><a href="#method.gt-2" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialOrd.html#method.gt" class="fnname">gt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialOrd.html#method.gt">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.ge-2" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.65.0/src/core/cmp.rs.html#1194">source</a></span><a href="#method.ge-2" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialOrd.html#method.ge" class="fnname">ge</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code>
operator. <a href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialOrd.html#method.ge">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-PartialOrd%3CBitVec%3CO2%2C%20T2%3E%3E-for-BitSlice%3CO1%2C%20T1%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#152-163">source</a><a href="#impl-PartialOrd%3CBitVec%3CO2%2C%20T2%3E%3E-for-BitSlice%3CO1%2C%20T1%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O1, O2, T1, T2&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;<a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O2, T2&gt;&gt; for <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O1, T1&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O1: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T1: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.partial_cmp" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#160-162">source</a><a href="#method.partial_cmp" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fnname">partial_cmp</a>(&amp;self, other: &amp;<a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O2, T2&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.65.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.65.0/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</h4></section></summary><div class='docblock'>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.lt" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.65.0/src/core/cmp.rs.html#1138">source</a></span><a href="#method.lt" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialOrd.html#method.lt" class="fnname">lt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialOrd.html#method.lt">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.le" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.65.0/src/core/cmp.rs.html#1157">source</a></span><a href="#method.le" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialOrd.html#method.le" class="fnname">le</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code>
operator. <a href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialOrd.html#method.le">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.gt" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.65.0/src/core/cmp.rs.html#1175">source</a></span><a href="#method.gt" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialOrd.html#method.gt" class="fnname">gt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialOrd.html#method.gt">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.ge" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.65.0/src/core/cmp.rs.html#1194">source</a></span><a href="#method.ge" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialOrd.html#method.ge" class="fnname">ge</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code>
operator. <a href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialOrd.html#method.ge">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-PartialOrd%3CRhs%3E-for-BitVec%3CO%2C%20T%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#194-204">source</a><a href="#impl-PartialOrd%3CRhs%3E-for-BitVec%3CO%2C%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T, Rhs&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;Rhs&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;Rhs: ?<a class="trait" href="https://doc.rust-lang.org/1.65.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;&gt;,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.partial_cmp-3" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#201-203">source</a><a href="#method.partial_cmp-3" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fnname">partial_cmp</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.65.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.65.0/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</h4></section></summary><div class='docblock'>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.lt-3" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.65.0/src/core/cmp.rs.html#1138">source</a></span><a href="#method.lt-3" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialOrd.html#method.lt" class="fnname">lt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialOrd.html#method.lt">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.le-3" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.65.0/src/core/cmp.rs.html#1157">source</a></span><a href="#method.le-3" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialOrd.html#method.le" class="fnname">le</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code>
operator. <a href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialOrd.html#method.le">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.gt-3" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.65.0/src/core/cmp.rs.html#1175">source</a></span><a href="#method.gt-3" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialOrd.html#method.gt" class="fnname">gt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialOrd.html#method.gt">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.ge-3" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.65.0/src/core/cmp.rs.html#1194">source</a></span><a href="#method.ge-3" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialOrd.html#method.ge" class="fnname">ge</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code>
operator. <a href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialOrd.html#method.ge">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-TryFrom%3CVec%3CT%2C%20Global%3E%3E-for-BitVec%3CO%2C%20T%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#279-290">source</a><a href="#impl-TryFrom%3CVec%3CT%2C%20Global%3E%3E-for-BitVec%3CO%2C%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.65.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T, <a class="struct" href="https://doc.rust-lang.org/1.65.0/alloc/alloc/struct.Global.html" title="struct alloc::alloc::Global">Global</a>&gt;&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Error" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="struct" href="https://doc.rust-lang.org/1.65.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T, <a class="struct" href="https://doc.rust-lang.org/1.65.0/alloc/alloc/struct.Global.html" title="struct alloc::alloc::Global">Global</a>&gt;</h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#287-289">source</a><a href="#method.try_from" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryFrom.html#tymethod.try_from" class="fnname">try_from</a>(vec: <a class="struct" href="https://doc.rust-lang.org/1.65.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.65.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;Self, Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-UpperHex-for-BitVec%3CO%2C%20T%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#369-378">source</a><a href="#impl-UpperHex-for-BitVec%3CO%2C%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/fmt/trait.UpperHex.html" title="trait core::fmt::UpperHex">UpperHex</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt-5" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#375-377">source</a><a href="#method.fmt-5" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/fmt/trait.UpperHex.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, fmt: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.65.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.65.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter.</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Write-for-BitVec%3CO%2C%20T%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/field/io.rs.html#121-139">source</a><a href="#impl-Write-for-BitVec%3CO%2C%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/std/io/trait.Write.html" title="trait std::io::Write">Write</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,</span></h3></section></summary><div class="docblock"><p>Mirrors the implementation on <code>Vec&lt;u8&gt;</code> (found <a href="https://doc.rust-lang.org/stable/std/vec/struct.Vec.html#impl-Write">here</a>).</p>
<p>The implementation copies bytes from <code>buf</code> into the tail end of <code>self</code>. The
performance characteristics of this operation are dependent on the type
parameters of the <a href="struct.BitVec.html"><code>BitVec</code></a>, and the position of its tail.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.write" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/field/io.rs.html#128-132">source</a><a href="#method.write" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/std/io/trait.Write.html#tymethod.write" class="fnname">write</a>(&amp;mut self, buf: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.u8.html">u8</a>]) -&gt; <a class="type" href="https://doc.rust-lang.org/1.65.0/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class='docblock'>Write a buffer into this writer, returning how many bytes were written. <a href="https://doc.rust-lang.org/1.65.0/std/io/trait.Write.html#tymethod.write">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.flush" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/field/io.rs.html#136-138">source</a><a href="#method.flush" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/std/io/trait.Write.html#tymethod.flush" class="fnname">flush</a>(&amp;mut self) -&gt; <a class="type" href="https://doc.rust-lang.org/1.65.0/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.unit.html">()</a>&gt;</h4></section></summary><div class='docblock'>Flush this output stream, ensuring that all intermediately buffered
contents reach their destination. <a href="https://doc.rust-lang.org/1.65.0/std/io/trait.Write.html#tymethod.flush">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.write_vectored" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.36.0">1.36.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.65.0/src/std/io/mod.rs.html#1460">source</a></span><a href="#method.write_vectored" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/std/io/trait.Write.html#method.write_vectored" class="fnname">write_vectored</a>(&amp;mut self, bufs: &amp;[<a class="struct" href="https://doc.rust-lang.org/1.65.0/std/io/struct.IoSlice.html" title="struct std::io::IoSlice">IoSlice</a>&lt;'_&gt;]) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.65.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>, <a class="struct" href="https://doc.rust-lang.org/1.65.0/std/io/error/struct.Error.html" title="struct std::io::error::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Like <a href="https://doc.rust-lang.org/1.65.0/std/io/trait.Write.html#tymethod.write"><code>write</code></a>, except that it writes from a slice of buffers. <a href="https://doc.rust-lang.org/1.65.0/std/io/trait.Write.html#method.write_vectored">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.is_write_vectored" class="method trait-impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/std/io/mod.rs.html#1475">source</a><a href="#method.is_write_vectored" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/std/io/trait.Write.html#method.is_write_vectored" class="fnname">is_write_vectored</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>can_vector</code>)</span></div></span><div class='docblock'>Determines if this <code>Write</code>r has an efficient <a href="https://doc.rust-lang.org/1.65.0/std/io/trait.Write.html#method.write_vectored"><code>write_vectored</code></a>
implementation. <a href="https://doc.rust-lang.org/1.65.0/std/io/trait.Write.html#method.is_write_vectored">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.write_all" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.65.0/src/std/io/mod.rs.html#1537">source</a></span><a href="#method.write_all" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/std/io/trait.Write.html#method.write_all" class="fnname">write_all</a>(&amp;mut self, buf: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.u8.html">u8</a>]) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.65.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.unit.html">()</a>, <a class="struct" href="https://doc.rust-lang.org/1.65.0/std/io/error/struct.Error.html" title="struct std::io::error::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Attempts to write an entire buffer into this writer. <a href="https://doc.rust-lang.org/1.65.0/std/io/trait.Write.html#method.write_all">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.write_all_vectored" class="method trait-impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/std/io/mod.rs.html#1602">source</a><a href="#method.write_all_vectored" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/std/io/trait.Write.html#method.write_all_vectored" class="fnname">write_all_vectored</a>(&amp;mut self, bufs: &amp;mut [<a class="struct" href="https://doc.rust-lang.org/1.65.0/std/io/struct.IoSlice.html" title="struct std::io::IoSlice">IoSlice</a>&lt;'_&gt;]) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.65.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.unit.html">()</a>, <a class="struct" href="https://doc.rust-lang.org/1.65.0/std/io/error/struct.Error.html" title="struct std::io::error::Error">Error</a>&gt;</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>write_all_vectored</code>)</span></div></span><div class='docblock'>Attempts to write multiple buffers into this writer. <a href="https://doc.rust-lang.org/1.65.0/std/io/trait.Write.html#method.write_all_vectored">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.write_fmt" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.65.0/src/std/io/mod.rs.html#1658">source</a></span><a href="#method.write_fmt" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/std/io/trait.Write.html#method.write_fmt" class="fnname">write_fmt</a>(&amp;mut self, fmt: <a class="struct" href="https://doc.rust-lang.org/1.65.0/core/fmt/struct.Arguments.html" title="struct core::fmt::Arguments">Arguments</a>&lt;'_&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.65.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.unit.html">()</a>, <a class="struct" href="https://doc.rust-lang.org/1.65.0/std/io/error/struct.Error.html" title="struct std::io::error::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Writes a formatted string into this writer, returning any error
encountered. <a href="https://doc.rust-lang.org/1.65.0/std/io/trait.Write.html#method.write_fmt">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.by_ref" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.65.0/src/std/io/mod.rs.html#1714-1716">source</a></span><a href="#method.by_ref" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/std/io/trait.Write.html#method.by_ref" class="fnname">by_ref</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;mut </a>Self</h4></section></summary><div class='docblock'>Creates a “by reference” adapter for this instance of <code>Write</code>. <a href="https://doc.rust-lang.org/1.65.0/std/io/trait.Write.html#method.by_ref">Read more</a></div></details></div></details><section id="impl-Eq-for-BitVec%3CO%2C%20T%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#77-82">source</a><a href="#impl-Eq-for-BitVec%3CO%2C%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section><section id="impl-Send-for-BitVec%3CO%2C%20T%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#393-398">source</a><a href="#impl-Send-for-BitVec%3CO%2C%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section><section id="impl-Sync-for-BitVec%3CO%2C%20T%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#400-405">source</a><a href="#impl-Sync-for-BitVec%3CO%2C%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section><section id="impl-Unpin-for-BitVec%3CO%2C%20T%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/bitvec/vec/traits.rs.html#407-412">source</a><a href="#impl-Unpin-for-BitVec%3CO%2C%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,</span></h3></section></div><h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor"></a></h2><div id="synthetic-implementations-list"><section id="impl-RefUnwindSafe-for-BitVec%3CO%2C%20T%3E" class="impl has-srclink"><a href="#impl-RefUnwindSafe-for-BitVec%3CO%2C%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a>,</span></h3></section><section id="impl-UnwindSafe-for-BitVec%3CO%2C%20T%3E" class="impl has-srclink"><a href="#impl-UnwindSafe-for-BitVec%3CO%2C%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a>,</span></h3></section></div><h2 id="blanket-implementations" class="small-section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor"></a></h2><div id="blanket-implementations-list"><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Any-for-BitVec%3CO%2C%20T%3E" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/core/any.rs.html#200">source</a><a href="#impl-Any-for-BitVec%3CO%2C%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.65.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/core/any.rs.html#201">source</a><a href="#method.type_id" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/any/trait.Any.html#tymethod.type_id" class="fnname">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.65.0/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.65.0/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-BitVec%3CO%2C%20T%3E" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/core/borrow.rs.html#209">source</a><a href="#impl-Borrow%3CT%3E-for-BitVec%3CO%2C%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/1.65.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.borrow-1" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/91522" title="Tracking issue for const_borrow">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.65.0/src/core/borrow.rs.html#211">source</a></span><a href="#method.borrow-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/borrow/trait.Borrow.html#tymethod.borrow" class="fnname">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;</a>T</h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.65.0/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-BitVec%3CO%2C%20T%3E" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/core/borrow.rs.html#218">source</a><a href="#impl-BorrowMut%3CT%3E-for-BitVec%3CO%2C%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/1.65.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.borrow_mut-1" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/91522" title="Tracking issue for const_borrow">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.65.0/src/core/borrow.rs.html#219">source</a></span><a href="#method.borrow_mut-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fnname">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;mut </a>T</h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.65.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Conv-for-BitVec%3CO%2C%20T%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/tap/conv.rs.html#58">source</a><a href="#impl-Conv-for-BitVec%3CO%2C%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../../tap/conv/trait.Conv.html" title="trait tap::conv::Conv">Conv</a> for T</h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.conv" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/tap/conv.rs.html#49-52">source</a><a href="#method.conv" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/conv/trait.Conv.html#method.conv" class="fnname">conv</a>&lt;T&gt;(self) -&gt; T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</span></h4></section></summary><div class='docblock'>Converts <code>self</code> into <code>T</code> using <code>Into&lt;T&gt;</code>. <a href="../../tap/conv/trait.Conv.html#method.conv">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-FmtForward-for-BitVec%3CO%2C%20T%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/wyz/fmt.rs.html#93">source</a><a href="#impl-FmtForward-for-BitVec%3CO%2C%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../../wyz/fmt/trait.FmtForward.html" title="trait wyz::fmt::FmtForward">FmtForward</a> for T</h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt_binary" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/wyz/fmt.rs.html#39-40">source</a><a href="#method.fmt_binary" class="anchor"></a><h4 class="code-header">fn <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_binary" class="fnname">fmt_binary</a>(self) -&gt; <a class="struct" href="../../wyz/fmt/struct.FmtBinary.html" title="struct wyz::fmt::FmtBinary">FmtBinary</a>&lt;Self&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/fmt/trait.Binary.html" title="trait core::fmt::Binary">Binary</a>,</span></h4></section></summary><div class='docblock'>Causes <code>self</code> to use its <code>Binary</code> implementation when <code>Debug</code>-formatted.</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt_display" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/wyz/fmt.rs.html#46-47">source</a><a href="#method.fmt_display" class="anchor"></a><h4 class="code-header">fn <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_display" class="fnname">fmt_display</a>(self) -&gt; <a class="struct" href="../../wyz/fmt/struct.FmtDisplay.html" title="struct wyz::fmt::FmtDisplay">FmtDisplay</a>&lt;Self&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/fmt/trait.Display.html" title="trait core::fmt::Display">Display</a>,</span></h4></section></summary><div class='docblock'>Causes <code>self</code> to use its <code>Display</code> implementation when
<code>Debug</code>-formatted. <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_display">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt_lower_exp" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/wyz/fmt.rs.html#53-54">source</a><a href="#method.fmt_lower_exp" class="anchor"></a><h4 class="code-header">fn <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_lower_exp" class="fnname">fmt_lower_exp</a>(self) -&gt; <a class="struct" href="../../wyz/fmt/struct.FmtLowerExp.html" title="struct wyz::fmt::FmtLowerExp">FmtLowerExp</a>&lt;Self&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/fmt/trait.LowerExp.html" title="trait core::fmt::LowerExp">LowerExp</a>,</span></h4></section></summary><div class='docblock'>Causes <code>self</code> to use its <code>LowerExp</code> implementation when
<code>Debug</code>-formatted. <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_lower_exp">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt_lower_hex" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/wyz/fmt.rs.html#60-61">source</a><a href="#method.fmt_lower_hex" class="anchor"></a><h4 class="code-header">fn <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_lower_hex" class="fnname">fmt_lower_hex</a>(self) -&gt; <a class="struct" href="../../wyz/fmt/struct.FmtLowerHex.html" title="struct wyz::fmt::FmtLowerHex">FmtLowerHex</a>&lt;Self&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/fmt/trait.LowerHex.html" title="trait core::fmt::LowerHex">LowerHex</a>,</span></h4></section></summary><div class='docblock'>Causes <code>self</code> to use its <code>LowerHex</code> implementation when
<code>Debug</code>-formatted. <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_lower_hex">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt_octal" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/wyz/fmt.rs.html#66-67">source</a><a href="#method.fmt_octal" class="anchor"></a><h4 class="code-header">fn <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_octal" class="fnname">fmt_octal</a>(self) -&gt; <a class="struct" href="../../wyz/fmt/struct.FmtOctal.html" title="struct wyz::fmt::FmtOctal">FmtOctal</a>&lt;Self&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/fmt/trait.Octal.html" title="trait core::fmt::Octal">Octal</a>,</span></h4></section></summary><div class='docblock'>Causes <code>self</code> to use its <code>Octal</code> implementation when <code>Debug</code>-formatted.</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt_pointer" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/wyz/fmt.rs.html#73-74">source</a><a href="#method.fmt_pointer" class="anchor"></a><h4 class="code-header">fn <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_pointer" class="fnname">fmt_pointer</a>(self) -&gt; <a class="struct" href="../../wyz/fmt/struct.FmtPointer.html" title="struct wyz::fmt::FmtPointer">FmtPointer</a>&lt;Self&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/fmt/trait.Pointer.html" title="trait core::fmt::Pointer">Pointer</a>,</span></h4></section></summary><div class='docblock'>Causes <code>self</code> to use its <code>Pointer</code> implementation when
<code>Debug</code>-formatted. <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_pointer">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt_upper_exp" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/wyz/fmt.rs.html#80-81">source</a><a href="#method.fmt_upper_exp" class="anchor"></a><h4 class="code-header">fn <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_upper_exp" class="fnname">fmt_upper_exp</a>(self) -&gt; <a class="struct" href="../../wyz/fmt/struct.FmtUpperExp.html" title="struct wyz::fmt::FmtUpperExp">FmtUpperExp</a>&lt;Self&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/fmt/trait.UpperExp.html" title="trait core::fmt::UpperExp">UpperExp</a>,</span></h4></section></summary><div class='docblock'>Causes <code>self</code> to use its <code>UpperExp</code> implementation when
<code>Debug</code>-formatted. <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_upper_exp">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt_upper_hex" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/wyz/fmt.rs.html#87-88">source</a><a href="#method.fmt_upper_hex" class="anchor"></a><h4 class="code-header">fn <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_upper_hex" class="fnname">fmt_upper_hex</a>(self) -&gt; <a class="struct" href="../../wyz/fmt/struct.FmtUpperHex.html" title="struct wyz::fmt::FmtUpperHex">FmtUpperHex</a>&lt;Self&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/fmt/trait.UpperHex.html" title="trait core::fmt::UpperHex">UpperHex</a>,</span></h4></section></summary><div class='docblock'>Causes <code>self</code> to use its <code>UpperHex</code> implementation when
<code>Debug</code>-formatted. <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_upper_hex">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-BitVec%3CO%2C%20T%3E" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/core/convert/mod.rs.html#559">source</a><a href="#impl-From%3CT%3E-for-BitVec%3CO%2C%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from-5" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.65.0/src/core/convert/mod.rs.html#562">source</a></span><a href="#method.from-5" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-BitVec%3CO%2C%20T%3E" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/core/convert/mod.rs.html#543">source</a><a href="#impl-Into%3CU%3E-for-BitVec%3CO%2C%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.into" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.65.0/src/core/convert/mod.rs.html#551">source</a></span><a href="#method.into" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/convert/trait.Into.html#tymethod.into" class="fnname">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.65.0/core/convert/trait.From.html" title="From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Pipe-for-BitVec%3CO%2C%20T%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/tap/pipe.rs.html#234">source</a><a href="#impl-Pipe-for-BitVec%3CO%2C%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../../tap/pipe/trait.Pipe.html" title="trait tap::pipe::Pipe">Pipe</a> for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/1.65.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.pipe" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/tap/pipe.rs.html#73-76">source</a><a href="#method.pipe" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/pipe/trait.Pipe.html#method.pipe" class="fnname">pipe</a>&lt;R&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(Self) -&gt; R) -&gt; R</h4></section></summary><div class='docblock'>Pipes by value. This is generally the method you want to use. <a href="../../tap/pipe/trait.Pipe.html#method.pipe">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.pipe_ref" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/tap/pipe.rs.html#97-99">source</a><a href="#method.pipe_ref" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/pipe/trait.Pipe.html#method.pipe_ref" class="fnname">pipe_ref</a>&lt;'a, R&gt;(&amp;'a self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;'a </a>Self) -&gt; R) -&gt; R<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;R: 'a,</span></h4></section></summary><div class='docblock'>Borrows <code>self</code> and passes that borrow into the pipe function. <a href="../../tap/pipe/trait.Pipe.html#method.pipe_ref">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.pipe_ref_mut" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/tap/pipe.rs.html#122-127">source</a><a href="#method.pipe_ref_mut" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/pipe/trait.Pipe.html#method.pipe_ref_mut" class="fnname">pipe_ref_mut</a>&lt;'a, R&gt;(&amp;'a mut self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;'a mut </a>Self) -&gt; R) -&gt; R<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;R: 'a,</span></h4></section></summary><div class='docblock'>Mutably borrows <code>self</code> and passes that borrow into the pipe function. <a href="../../tap/pipe/trait.Pipe.html#method.pipe_ref_mut">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.pipe_borrow" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/tap/pipe.rs.html#145-149">source</a><a href="#method.pipe_borrow" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/pipe/trait.Pipe.html#method.pipe_borrow" class="fnname">pipe_borrow</a>&lt;'a, B, R&gt;(&amp;'a self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;'a </a>B) -&gt; R) -&gt; R<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;B&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;B: 'a + ?<a class="trait" href="https://doc.rust-lang.org/1.65.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: 'a,</span></h4></section></summary><div class='docblock'>Borrows <code>self</code>, then passes <code>self.borrow()</code> into the pipe function. <a href="../../tap/pipe/trait.Pipe.html#method.pipe_borrow">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.pipe_borrow_mut" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/tap/pipe.rs.html#169-176">source</a><a href="#method.pipe_borrow_mut" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/pipe/trait.Pipe.html#method.pipe_borrow_mut" class="fnname">pipe_borrow_mut</a>&lt;'a, B, R&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;'a mut self,<br>&nbsp;&nbsp;&nbsp;&nbsp;func: impl <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;'a mut </a>B) -&gt; R<br>) -&gt; R<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;B&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;B: 'a + ?<a class="trait" href="https://doc.rust-lang.org/1.65.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: 'a,</span></h4></section></summary><div class='docblock'>Mutably borrows <code>self</code>, then passes <code>self.borrow_mut()</code> into the pipe
function. <a href="../../tap/pipe/trait.Pipe.html#method.pipe_borrow_mut">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.pipe_as_ref" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/tap/pipe.rs.html#183-187">source</a><a href="#method.pipe_as_ref" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/pipe/trait.Pipe.html#method.pipe_as_ref" class="fnname">pipe_as_ref</a>&lt;'a, U, R&gt;(&amp;'a self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;'a </a>U) -&gt; R) -&gt; R<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;U&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;U: 'a + ?<a class="trait" href="https://doc.rust-lang.org/1.65.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: 'a,</span></h4></section></summary><div class='docblock'>Borrows <code>self</code>, then passes <code>self.as_ref()</code> into the pipe function.</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.pipe_as_mut" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/tap/pipe.rs.html#195-202">source</a><a href="#method.pipe_as_mut" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/pipe/trait.Pipe.html#method.pipe_as_mut" class="fnname">pipe_as_mut</a>&lt;'a, U, R&gt;(&amp;'a mut self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;'a mut </a>U) -&gt; R) -&gt; R<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.AsMut.html" title="trait core::convert::AsMut">AsMut</a>&lt;U&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;U: 'a + ?<a class="trait" href="https://doc.rust-lang.org/1.65.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: 'a,</span></h4></section></summary><div class='docblock'>Mutably borrows <code>self</code>, then passes <code>self.as_mut()</code> into the pipe
function. <a href="../../tap/pipe/trait.Pipe.html#method.pipe_as_mut">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.pipe_deref" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/tap/pipe.rs.html#209-213">source</a><a href="#method.pipe_deref" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/pipe/trait.Pipe.html#method.pipe_deref" class="fnname">pipe_deref</a>&lt;'a, T, R&gt;(&amp;'a self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;'a </a>T) -&gt; R) -&gt; R<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>&lt;Target = T&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + ?<a class="trait" href="https://doc.rust-lang.org/1.65.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: 'a,</span></h4></section></summary><div class='docblock'>Borrows <code>self</code>, then passes <code>self.deref()</code> into the pipe function.</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.pipe_deref_mut" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/tap/pipe.rs.html#221-228">source</a><a href="#method.pipe_deref_mut" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/pipe/trait.Pipe.html#method.pipe_deref_mut" class="fnname">pipe_deref_mut</a>&lt;'a, T, R&gt;(&amp;'a mut self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;'a mut </a>T) -&gt; R) -&gt; R<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/deref/trait.DerefMut.html" title="trait core::ops::deref::DerefMut">DerefMut</a>&lt;Target = T&gt; + <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + ?<a class="trait" href="https://doc.rust-lang.org/1.65.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: 'a,</span></h4></section></summary><div class='docblock'>Mutably borrows <code>self</code>, then passes <code>self.deref_mut()</code> into the pipe
function. <a href="../../tap/pipe/trait.Pipe.html#method.pipe_deref_mut">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Tap-for-BitVec%3CO%2C%20T%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/tap/tap.rs.html#329">source</a><a href="#impl-Tap-for-BitVec%3CO%2C%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../../tap/tap/trait.Tap.html" title="trait tap::tap::Tap">Tap</a> for T</h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.tap" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/tap/tap.rs.html#78">source</a><a href="#method.tap" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/tap/trait.Tap.html#method.tap" class="fnname">tap</a>(self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;</a>Self)) -&gt; Self</h4></section></summary><div class='docblock'>Immutable access to a value. <a href="../../tap/tap/trait.Tap.html#method.tap">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.tap_mut" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/tap/tap.rs.html#116">source</a><a href="#method.tap_mut" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/tap/trait.Tap.html#method.tap_mut" class="fnname">tap_mut</a>(self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;mut </a>Self)) -&gt; Self</h4></section></summary><div class='docblock'>Mutable access to a value. <a href="../../tap/tap/trait.Tap.html#method.tap_mut">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.tap_borrow" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/tap/tap.rs.html#129-132">source</a><a href="#method.tap_borrow" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/tap/trait.Tap.html#method.tap_borrow" class="fnname">tap_borrow</a>&lt;B&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;</a>B)) -&gt; Self<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;B&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;B: ?<a class="trait" href="https://doc.rust-lang.org/1.65.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h4></section></summary><div class='docblock'>Immutable access to the <code>Borrow&lt;B&gt;</code> of a value. <a href="../../tap/tap/trait.Tap.html#method.tap_borrow">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.tap_borrow_mut" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/tap/tap.rs.html#146-149">source</a><a href="#method.tap_borrow_mut" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/tap/trait.Tap.html#method.tap_borrow_mut" class="fnname">tap_borrow_mut</a>&lt;B&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;mut </a>B)) -&gt; Self<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;B&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;B: ?<a class="trait" href="https://doc.rust-lang.org/1.65.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h4></section></summary><div class='docblock'>Mutable access to the <code>BorrowMut&lt;B&gt;</code> of a value. <a href="../../tap/tap/trait.Tap.html#method.tap_borrow_mut">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.tap_ref" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/tap/tap.rs.html#163-166">source</a><a href="#method.tap_ref" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/tap/trait.Tap.html#method.tap_ref" class="fnname">tap_ref</a>&lt;R&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;</a>R)) -&gt; Self<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;R&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: ?<a class="trait" href="https://doc.rust-lang.org/1.65.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h4></section></summary><div class='docblock'>Immutable access to the <code>AsRef&lt;R&gt;</code> view of a value. <a href="../../tap/tap/trait.Tap.html#method.tap_ref">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.tap_ref_mut" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/tap/tap.rs.html#180-183">source</a><a href="#method.tap_ref_mut" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/tap/trait.Tap.html#method.tap_ref_mut" class="fnname">tap_ref_mut</a>&lt;R&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;mut </a>R)) -&gt; Self<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.AsMut.html" title="trait core::convert::AsMut">AsMut</a>&lt;R&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: ?<a class="trait" href="https://doc.rust-lang.org/1.65.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h4></section></summary><div class='docblock'>Mutable access to the <code>AsMut&lt;R&gt;</code> view of a value. <a href="../../tap/tap/trait.Tap.html#method.tap_ref_mut">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.tap_deref" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/tap/tap.rs.html#197-200">source</a><a href="#method.tap_deref" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/tap/trait.Tap.html#method.tap_deref" class="fnname">tap_deref</a>&lt;T&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;</a>T)) -&gt; Self<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>&lt;Target = T&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/1.65.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h4></section></summary><div class='docblock'>Immutable access to the <code>Deref::Target</code> of a value. <a href="../../tap/tap/trait.Tap.html#method.tap_deref">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.tap_deref_mut" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/tap/tap.rs.html#214-217">source</a><a href="#method.tap_deref_mut" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/tap/trait.Tap.html#method.tap_deref_mut" class="fnname">tap_deref_mut</a>&lt;T&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;mut </a>T)) -&gt; Self<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/deref/trait.DerefMut.html" title="trait core::ops::deref::DerefMut">DerefMut</a>&lt;Target = T&gt; + <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/1.65.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h4></section></summary><div class='docblock'>Mutable access to the <code>Deref::Target</code> of a value. <a href="../../tap/tap/trait.Tap.html#method.tap_deref_mut">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.tap_dbg" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/tap/tap.rs.html#227">source</a><a href="#method.tap_dbg" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/tap/trait.Tap.html#method.tap_dbg" class="fnname">tap_dbg</a>(self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;</a>Self)) -&gt; Self</h4></section></summary><div class='docblock'>Calls <code>.tap()</code> only in debug builds, and is erased in release builds.</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.tap_mut_dbg" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/tap/tap.rs.html#237">source</a><a href="#method.tap_mut_dbg" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/tap/trait.Tap.html#method.tap_mut_dbg" class="fnname">tap_mut_dbg</a>(self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;mut </a>Self)) -&gt; Self</h4></section></summary><div class='docblock'>Calls <code>.tap_mut()</code> only in debug builds, and is erased in release
builds. <a href="../../tap/tap/trait.Tap.html#method.tap_mut_dbg">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.tap_borrow_dbg" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/tap/tap.rs.html#247-250">source</a><a href="#method.tap_borrow_dbg" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/tap/trait.Tap.html#method.tap_borrow_dbg" class="fnname">tap_borrow_dbg</a>&lt;B&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;</a>B)) -&gt; Self<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;B&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;B: ?<a class="trait" href="https://doc.rust-lang.org/1.65.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h4></section></summary><div class='docblock'>Calls <code>.tap_borrow()</code> only in debug builds, and is erased in release
builds. <a href="../../tap/tap/trait.Tap.html#method.tap_borrow_dbg">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.tap_borrow_mut_dbg" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/tap/tap.rs.html#261-264">source</a><a href="#method.tap_borrow_mut_dbg" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/tap/trait.Tap.html#method.tap_borrow_mut_dbg" class="fnname">tap_borrow_mut_dbg</a>&lt;B&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;mut </a>B)) -&gt; Self<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;B&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;B: ?<a class="trait" href="https://doc.rust-lang.org/1.65.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h4></section></summary><div class='docblock'>Calls <code>.tap_borrow_mut()</code> only in debug builds, and is erased in release
builds. <a href="../../tap/tap/trait.Tap.html#method.tap_borrow_mut_dbg">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.tap_ref_dbg" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/tap/tap.rs.html#275-278">source</a><a href="#method.tap_ref_dbg" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/tap/trait.Tap.html#method.tap_ref_dbg" class="fnname">tap_ref_dbg</a>&lt;R&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;</a>R)) -&gt; Self<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;R&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: ?<a class="trait" href="https://doc.rust-lang.org/1.65.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h4></section></summary><div class='docblock'>Calls <code>.tap_ref()</code> only in debug builds, and is erased in release
builds. <a href="../../tap/tap/trait.Tap.html#method.tap_ref_dbg">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.tap_ref_mut_dbg" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/tap/tap.rs.html#289-292">source</a><a href="#method.tap_ref_mut_dbg" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/tap/trait.Tap.html#method.tap_ref_mut_dbg" class="fnname">tap_ref_mut_dbg</a>&lt;R&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;mut </a>R)) -&gt; Self<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.AsMut.html" title="trait core::convert::AsMut">AsMut</a>&lt;R&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: ?<a class="trait" href="https://doc.rust-lang.org/1.65.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h4></section></summary><div class='docblock'>Calls <code>.tap_ref_mut()</code> only in debug builds, and is erased in release
builds. <a href="../../tap/tap/trait.Tap.html#method.tap_ref_mut_dbg">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.tap_deref_dbg" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/tap/tap.rs.html#303-306">source</a><a href="#method.tap_deref_dbg" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/tap/trait.Tap.html#method.tap_deref_dbg" class="fnname">tap_deref_dbg</a>&lt;T&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;</a>T)) -&gt; Self<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>&lt;Target = T&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/1.65.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h4></section></summary><div class='docblock'>Calls <code>.tap_deref()</code> only in debug builds, and is erased in release
builds. <a href="../../tap/tap/trait.Tap.html#method.tap_deref_dbg">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.tap_deref_mut_dbg" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/tap/tap.rs.html#317-320">source</a><a href="#method.tap_deref_mut_dbg" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/tap/trait.Tap.html#method.tap_deref_mut_dbg" class="fnname">tap_deref_mut_dbg</a>&lt;T&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;mut </a>T)) -&gt; Self<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/deref/trait.DerefMut.html" title="trait core::ops::deref::DerefMut">DerefMut</a>&lt;Target = T&gt; + <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/1.65.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h4></section></summary><div class='docblock'>Calls <code>.tap_deref_mut()</code> only in debug builds, and is erased in release
builds. <a href="../../tap/tap/trait.Tap.html#method.tap_deref_mut_dbg">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-ToOwned-for-BitVec%3CO%2C%20T%3E" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/alloc/borrow.rs.html#83">source</a><a href="#impl-ToOwned-for-BitVec%3CO%2C%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Owned" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.65.0/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/alloc/borrow.rs.html#88">source</a><a href="#method.to_owned" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fnname">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/1.65.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/alloc/borrow.rs.html#92">source</a><a href="#method.clone_into" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fnname">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;mut </a>T)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/1.65.0/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-ToString-for-BitVec%3CO%2C%20T%3E" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/alloc/string.rs.html#2500">source</a><a href="#impl-ToString-for-BitVec%3CO%2C%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/alloc/string/trait.ToString.html" title="trait alloc::string::ToString">ToString</a> for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/fmt/trait.Display.html" title="trait core::fmt::Display">Display</a> + ?<a class="trait" href="https://doc.rust-lang.org/1.65.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.to_string" class="method trait-impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/alloc/string.rs.html#2506">source</a><a href="#method.to_string" class="anchor"></a><h4 class="code-header">default fn <a href="https://doc.rust-lang.org/1.65.0/alloc/string/trait.ToString.html#tymethod.to_string" class="fnname">to_string</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.65.0/alloc/string/struct.String.html" title="struct alloc::string::String">String</a></h4></section></summary><div class='docblock'>Converts the given value to a <code>String</code>. <a href="https://doc.rust-lang.org/1.65.0/alloc/string/trait.ToString.html#tymethod.to_string">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-TryConv-for-BitVec%3CO%2C%20T%3E" class="impl has-srclink"><a class="srclink rightside" href="../../src/tap/conv.rs.html#87">source</a><a href="#impl-TryConv-for-BitVec%3CO%2C%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../../tap/conv/trait.TryConv.html" title="trait tap::conv::TryConv">TryConv</a> for T</h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.try_conv" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/tap/conv.rs.html#78-81">source</a><a href="#method.try_conv" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/conv/trait.TryConv.html#method.try_conv" class="fnname">try_conv</a>&lt;T&gt;(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.65.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryInto.html#associatedtype.Error" title="type core::convert::TryInto::Error">Error</a>&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;T&gt;,</span></h4></section></summary><div class='docblock'>Attempts to convert <code>self</code> into <code>T</code> using <code>TryInto&lt;T&gt;</code>. <a href="../../tap/conv/trait.TryConv.html#method.try_conv">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-BitVec%3CO%2C%20T%3E" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/core/convert/mod.rs.html#601">source</a><a href="#impl-TryFrom%3CU%3E-for-BitVec%3CO%2C%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Error-2" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Error-2" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.65.0/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.try_from-1" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.65.0/src/core/convert/mod.rs.html#607">source</a></span><a href="#method.try_from-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryFrom.html#tymethod.try_from" class="fnname">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.65.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-BitVec%3CO%2C%20T%3E" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/core/convert/mod.rs.html#586">source</a><a href="#impl-TryInto%3CU%3E-for-BitVec%3CO%2C%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Error-1" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.65.0/src/core/convert/mod.rs.html#592">source</a></span><a href="#method.try_into" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryInto.html#tymethod.try_into" class="fnname">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.65.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main><div id="rustdoc-vars" data-root-path="../../" data-current-crate="bitvec" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.65.0 (897e37553 2022-11-02)" ></div></body></html>