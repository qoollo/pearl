<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `/home/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.22.3/src/ptr/span.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>span.rs - source</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" href="../../../normalize.css"><link rel="stylesheet" href="../../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" href="../../../ayu.css" disabled><link rel="stylesheet" href="../../../dark.css" disabled><link rel="stylesheet" href="../../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../../storage.js"></script><script defer src="../../../source-script.js"></script><script defer src="../../../source-files.js"></script><script defer src="../../../main.js"></script><noscript><link rel="stylesheet" href="../../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../../favicon.svg"></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../../bitvec/index.html"><div class="logo-container"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></div></a><h2 class="location"></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../../../bitvec/index.html"><div class="logo-container"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></div></a></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../../bitvec/index.html"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></a><nav class="sub"><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><button type="button">?</button></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../wheel.svg"></a></div></div></form></nav></div><section id="main-content" class="content"><div class="example-wrap"><pre class="line-numbers"><span id="1">1</span>
<span id="2">2</span>
<span id="3">3</span>
<span id="4">4</span>
<span id="5">5</span>
<span id="6">6</span>
<span id="7">7</span>
<span id="8">8</span>
<span id="9">9</span>
<span id="10">10</span>
<span id="11">11</span>
<span id="12">12</span>
<span id="13">13</span>
<span id="14">14</span>
<span id="15">15</span>
<span id="16">16</span>
<span id="17">17</span>
<span id="18">18</span>
<span id="19">19</span>
<span id="20">20</span>
<span id="21">21</span>
<span id="22">22</span>
<span id="23">23</span>
<span id="24">24</span>
<span id="25">25</span>
<span id="26">26</span>
<span id="27">27</span>
<span id="28">28</span>
<span id="29">29</span>
<span id="30">30</span>
<span id="31">31</span>
<span id="32">32</span>
<span id="33">33</span>
<span id="34">34</span>
<span id="35">35</span>
<span id="36">36</span>
<span id="37">37</span>
<span id="38">38</span>
<span id="39">39</span>
<span id="40">40</span>
<span id="41">41</span>
<span id="42">42</span>
<span id="43">43</span>
<span id="44">44</span>
<span id="45">45</span>
<span id="46">46</span>
<span id="47">47</span>
<span id="48">48</span>
<span id="49">49</span>
<span id="50">50</span>
<span id="51">51</span>
<span id="52">52</span>
<span id="53">53</span>
<span id="54">54</span>
<span id="55">55</span>
<span id="56">56</span>
<span id="57">57</span>
<span id="58">58</span>
<span id="59">59</span>
<span id="60">60</span>
<span id="61">61</span>
<span id="62">62</span>
<span id="63">63</span>
<span id="64">64</span>
<span id="65">65</span>
<span id="66">66</span>
<span id="67">67</span>
<span id="68">68</span>
<span id="69">69</span>
<span id="70">70</span>
<span id="71">71</span>
<span id="72">72</span>
<span id="73">73</span>
<span id="74">74</span>
<span id="75">75</span>
<span id="76">76</span>
<span id="77">77</span>
<span id="78">78</span>
<span id="79">79</span>
<span id="80">80</span>
<span id="81">81</span>
<span id="82">82</span>
<span id="83">83</span>
<span id="84">84</span>
<span id="85">85</span>
<span id="86">86</span>
<span id="87">87</span>
<span id="88">88</span>
<span id="89">89</span>
<span id="90">90</span>
<span id="91">91</span>
<span id="92">92</span>
<span id="93">93</span>
<span id="94">94</span>
<span id="95">95</span>
<span id="96">96</span>
<span id="97">97</span>
<span id="98">98</span>
<span id="99">99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
<span id="148">148</span>
<span id="149">149</span>
<span id="150">150</span>
<span id="151">151</span>
<span id="152">152</span>
<span id="153">153</span>
<span id="154">154</span>
<span id="155">155</span>
<span id="156">156</span>
<span id="157">157</span>
<span id="158">158</span>
<span id="159">159</span>
<span id="160">160</span>
<span id="161">161</span>
<span id="162">162</span>
<span id="163">163</span>
<span id="164">164</span>
<span id="165">165</span>
<span id="166">166</span>
<span id="167">167</span>
<span id="168">168</span>
<span id="169">169</span>
<span id="170">170</span>
<span id="171">171</span>
<span id="172">172</span>
<span id="173">173</span>
<span id="174">174</span>
<span id="175">175</span>
<span id="176">176</span>
<span id="177">177</span>
<span id="178">178</span>
<span id="179">179</span>
<span id="180">180</span>
<span id="181">181</span>
<span id="182">182</span>
<span id="183">183</span>
<span id="184">184</span>
<span id="185">185</span>
<span id="186">186</span>
<span id="187">187</span>
<span id="188">188</span>
<span id="189">189</span>
<span id="190">190</span>
<span id="191">191</span>
<span id="192">192</span>
<span id="193">193</span>
<span id="194">194</span>
<span id="195">195</span>
<span id="196">196</span>
<span id="197">197</span>
<span id="198">198</span>
<span id="199">199</span>
<span id="200">200</span>
<span id="201">201</span>
<span id="202">202</span>
<span id="203">203</span>
<span id="204">204</span>
<span id="205">205</span>
<span id="206">206</span>
<span id="207">207</span>
<span id="208">208</span>
<span id="209">209</span>
<span id="210">210</span>
<span id="211">211</span>
<span id="212">212</span>
<span id="213">213</span>
<span id="214">214</span>
<span id="215">215</span>
<span id="216">216</span>
<span id="217">217</span>
<span id="218">218</span>
<span id="219">219</span>
<span id="220">220</span>
<span id="221">221</span>
<span id="222">222</span>
<span id="223">223</span>
<span id="224">224</span>
<span id="225">225</span>
<span id="226">226</span>
<span id="227">227</span>
<span id="228">228</span>
<span id="229">229</span>
<span id="230">230</span>
<span id="231">231</span>
<span id="232">232</span>
<span id="233">233</span>
<span id="234">234</span>
<span id="235">235</span>
<span id="236">236</span>
<span id="237">237</span>
<span id="238">238</span>
<span id="239">239</span>
<span id="240">240</span>
<span id="241">241</span>
<span id="242">242</span>
<span id="243">243</span>
<span id="244">244</span>
<span id="245">245</span>
<span id="246">246</span>
<span id="247">247</span>
<span id="248">248</span>
<span id="249">249</span>
<span id="250">250</span>
<span id="251">251</span>
<span id="252">252</span>
<span id="253">253</span>
<span id="254">254</span>
<span id="255">255</span>
<span id="256">256</span>
<span id="257">257</span>
<span id="258">258</span>
<span id="259">259</span>
<span id="260">260</span>
<span id="261">261</span>
<span id="262">262</span>
<span id="263">263</span>
<span id="264">264</span>
<span id="265">265</span>
<span id="266">266</span>
<span id="267">267</span>
<span id="268">268</span>
<span id="269">269</span>
<span id="270">270</span>
<span id="271">271</span>
<span id="272">272</span>
<span id="273">273</span>
<span id="274">274</span>
<span id="275">275</span>
<span id="276">276</span>
<span id="277">277</span>
<span id="278">278</span>
<span id="279">279</span>
<span id="280">280</span>
<span id="281">281</span>
<span id="282">282</span>
<span id="283">283</span>
<span id="284">284</span>
<span id="285">285</span>
<span id="286">286</span>
<span id="287">287</span>
<span id="288">288</span>
<span id="289">289</span>
<span id="290">290</span>
<span id="291">291</span>
<span id="292">292</span>
<span id="293">293</span>
<span id="294">294</span>
<span id="295">295</span>
<span id="296">296</span>
<span id="297">297</span>
<span id="298">298</span>
<span id="299">299</span>
<span id="300">300</span>
<span id="301">301</span>
<span id="302">302</span>
<span id="303">303</span>
<span id="304">304</span>
<span id="305">305</span>
<span id="306">306</span>
<span id="307">307</span>
<span id="308">308</span>
<span id="309">309</span>
<span id="310">310</span>
<span id="311">311</span>
<span id="312">312</span>
<span id="313">313</span>
<span id="314">314</span>
<span id="315">315</span>
<span id="316">316</span>
<span id="317">317</span>
<span id="318">318</span>
<span id="319">319</span>
<span id="320">320</span>
<span id="321">321</span>
<span id="322">322</span>
<span id="323">323</span>
<span id="324">324</span>
<span id="325">325</span>
<span id="326">326</span>
<span id="327">327</span>
<span id="328">328</span>
<span id="329">329</span>
<span id="330">330</span>
<span id="331">331</span>
<span id="332">332</span>
<span id="333">333</span>
<span id="334">334</span>
<span id="335">335</span>
<span id="336">336</span>
<span id="337">337</span>
<span id="338">338</span>
<span id="339">339</span>
<span id="340">340</span>
<span id="341">341</span>
<span id="342">342</span>
<span id="343">343</span>
<span id="344">344</span>
<span id="345">345</span>
<span id="346">346</span>
<span id="347">347</span>
<span id="348">348</span>
<span id="349">349</span>
<span id="350">350</span>
<span id="351">351</span>
<span id="352">352</span>
<span id="353">353</span>
<span id="354">354</span>
<span id="355">355</span>
<span id="356">356</span>
<span id="357">357</span>
<span id="358">358</span>
<span id="359">359</span>
<span id="360">360</span>
<span id="361">361</span>
<span id="362">362</span>
<span id="363">363</span>
<span id="364">364</span>
<span id="365">365</span>
<span id="366">366</span>
<span id="367">367</span>
<span id="368">368</span>
<span id="369">369</span>
<span id="370">370</span>
<span id="371">371</span>
<span id="372">372</span>
<span id="373">373</span>
<span id="374">374</span>
<span id="375">375</span>
<span id="376">376</span>
<span id="377">377</span>
<span id="378">378</span>
<span id="379">379</span>
<span id="380">380</span>
<span id="381">381</span>
<span id="382">382</span>
<span id="383">383</span>
<span id="384">384</span>
<span id="385">385</span>
<span id="386">386</span>
<span id="387">387</span>
<span id="388">388</span>
<span id="389">389</span>
<span id="390">390</span>
<span id="391">391</span>
<span id="392">392</span>
<span id="393">393</span>
<span id="394">394</span>
<span id="395">395</span>
<span id="396">396</span>
<span id="397">397</span>
<span id="398">398</span>
<span id="399">399</span>
<span id="400">400</span>
<span id="401">401</span>
<span id="402">402</span>
<span id="403">403</span>
<span id="404">404</span>
<span id="405">405</span>
<span id="406">406</span>
<span id="407">407</span>
<span id="408">408</span>
<span id="409">409</span>
<span id="410">410</span>
<span id="411">411</span>
<span id="412">412</span>
<span id="413">413</span>
<span id="414">414</span>
<span id="415">415</span>
<span id="416">416</span>
<span id="417">417</span>
<span id="418">418</span>
<span id="419">419</span>
<span id="420">420</span>
<span id="421">421</span>
<span id="422">422</span>
<span id="423">423</span>
<span id="424">424</span>
<span id="425">425</span>
<span id="426">426</span>
<span id="427">427</span>
<span id="428">428</span>
<span id="429">429</span>
<span id="430">430</span>
<span id="431">431</span>
<span id="432">432</span>
<span id="433">433</span>
<span id="434">434</span>
<span id="435">435</span>
<span id="436">436</span>
<span id="437">437</span>
<span id="438">438</span>
<span id="439">439</span>
<span id="440">440</span>
<span id="441">441</span>
<span id="442">442</span>
<span id="443">443</span>
<span id="444">444</span>
<span id="445">445</span>
<span id="446">446</span>
<span id="447">447</span>
<span id="448">448</span>
<span id="449">449</span>
<span id="450">450</span>
<span id="451">451</span>
<span id="452">452</span>
<span id="453">453</span>
<span id="454">454</span>
<span id="455">455</span>
<span id="456">456</span>
<span id="457">457</span>
<span id="458">458</span>
<span id="459">459</span>
<span id="460">460</span>
<span id="461">461</span>
<span id="462">462</span>
<span id="463">463</span>
<span id="464">464</span>
<span id="465">465</span>
<span id="466">466</span>
<span id="467">467</span>
<span id="468">468</span>
<span id="469">469</span>
<span id="470">470</span>
<span id="471">471</span>
<span id="472">472</span>
<span id="473">473</span>
<span id="474">474</span>
<span id="475">475</span>
<span id="476">476</span>
<span id="477">477</span>
<span id="478">478</span>
<span id="479">479</span>
<span id="480">480</span>
<span id="481">481</span>
<span id="482">482</span>
<span id="483">483</span>
<span id="484">484</span>
<span id="485">485</span>
<span id="486">486</span>
<span id="487">487</span>
<span id="488">488</span>
<span id="489">489</span>
<span id="490">490</span>
<span id="491">491</span>
<span id="492">492</span>
<span id="493">493</span>
<span id="494">494</span>
<span id="495">495</span>
<span id="496">496</span>
<span id="497">497</span>
<span id="498">498</span>
<span id="499">499</span>
<span id="500">500</span>
<span id="501">501</span>
<span id="502">502</span>
<span id="503">503</span>
<span id="504">504</span>
<span id="505">505</span>
<span id="506">506</span>
<span id="507">507</span>
<span id="508">508</span>
<span id="509">509</span>
<span id="510">510</span>
<span id="511">511</span>
<span id="512">512</span>
<span id="513">513</span>
<span id="514">514</span>
<span id="515">515</span>
<span id="516">516</span>
<span id="517">517</span>
<span id="518">518</span>
<span id="519">519</span>
<span id="520">520</span>
<span id="521">521</span>
<span id="522">522</span>
<span id="523">523</span>
<span id="524">524</span>
<span id="525">525</span>
<span id="526">526</span>
<span id="527">527</span>
<span id="528">528</span>
<span id="529">529</span>
<span id="530">530</span>
<span id="531">531</span>
<span id="532">532</span>
<span id="533">533</span>
<span id="534">534</span>
<span id="535">535</span>
<span id="536">536</span>
<span id="537">537</span>
<span id="538">538</span>
<span id="539">539</span>
<span id="540">540</span>
<span id="541">541</span>
<span id="542">542</span>
<span id="543">543</span>
<span id="544">544</span>
<span id="545">545</span>
<span id="546">546</span>
<span id="547">547</span>
<span id="548">548</span>
<span id="549">549</span>
<span id="550">550</span>
<span id="551">551</span>
<span id="552">552</span>
<span id="553">553</span>
<span id="554">554</span>
<span id="555">555</span>
<span id="556">556</span>
<span id="557">557</span>
<span id="558">558</span>
<span id="559">559</span>
<span id="560">560</span>
<span id="561">561</span>
<span id="562">562</span>
<span id="563">563</span>
<span id="564">564</span>
<span id="565">565</span>
<span id="566">566</span>
<span id="567">567</span>
<span id="568">568</span>
<span id="569">569</span>
<span id="570">570</span>
<span id="571">571</span>
<span id="572">572</span>
<span id="573">573</span>
<span id="574">574</span>
<span id="575">575</span>
<span id="576">576</span>
<span id="577">577</span>
<span id="578">578</span>
<span id="579">579</span>
<span id="580">580</span>
<span id="581">581</span>
<span id="582">582</span>
<span id="583">583</span>
<span id="584">584</span>
<span id="585">585</span>
<span id="586">586</span>
<span id="587">587</span>
<span id="588">588</span>
<span id="589">589</span>
<span id="590">590</span>
<span id="591">591</span>
<span id="592">592</span>
<span id="593">593</span>
<span id="594">594</span>
<span id="595">595</span>
<span id="596">596</span>
<span id="597">597</span>
<span id="598">598</span>
<span id="599">599</span>
<span id="600">600</span>
<span id="601">601</span>
<span id="602">602</span>
<span id="603">603</span>
<span id="604">604</span>
<span id="605">605</span>
<span id="606">606</span>
<span id="607">607</span>
<span id="608">608</span>
<span id="609">609</span>
<span id="610">610</span>
<span id="611">611</span>
<span id="612">612</span>
<span id="613">613</span>
<span id="614">614</span>
<span id="615">615</span>
<span id="616">616</span>
<span id="617">617</span>
<span id="618">618</span>
<span id="619">619</span>
<span id="620">620</span>
<span id="621">621</span>
<span id="622">622</span>
<span id="623">623</span>
<span id="624">624</span>
<span id="625">625</span>
<span id="626">626</span>
<span id="627">627</span>
<span id="628">628</span>
<span id="629">629</span>
<span id="630">630</span>
<span id="631">631</span>
<span id="632">632</span>
<span id="633">633</span>
<span id="634">634</span>
<span id="635">635</span>
<span id="636">636</span>
<span id="637">637</span>
<span id="638">638</span>
<span id="639">639</span>
<span id="640">640</span>
<span id="641">641</span>
<span id="642">642</span>
<span id="643">643</span>
<span id="644">644</span>
<span id="645">645</span>
<span id="646">646</span>
<span id="647">647</span>
<span id="648">648</span>
<span id="649">649</span>
<span id="650">650</span>
<span id="651">651</span>
<span id="652">652</span>
<span id="653">653</span>
<span id="654">654</span>
<span id="655">655</span>
<span id="656">656</span>
<span id="657">657</span>
<span id="658">658</span>
<span id="659">659</span>
<span id="660">660</span>
<span id="661">661</span>
<span id="662">662</span>
<span id="663">663</span>
<span id="664">664</span>
<span id="665">665</span>
<span id="666">666</span>
<span id="667">667</span>
<span id="668">668</span>
<span id="669">669</span>
<span id="670">670</span>
<span id="671">671</span>
<span id="672">672</span>
<span id="673">673</span>
<span id="674">674</span>
<span id="675">675</span>
<span id="676">676</span>
<span id="677">677</span>
<span id="678">678</span>
<span id="679">679</span>
<span id="680">680</span>
<span id="681">681</span>
<span id="682">682</span>
<span id="683">683</span>
<span id="684">684</span>
<span id="685">685</span>
<span id="686">686</span>
<span id="687">687</span>
<span id="688">688</span>
<span id="689">689</span>
<span id="690">690</span>
<span id="691">691</span>
<span id="692">692</span>
<span id="693">693</span>
<span id="694">694</span>
<span id="695">695</span>
<span id="696">696</span>
<span id="697">697</span>
<span id="698">698</span>
<span id="699">699</span>
<span id="700">700</span>
<span id="701">701</span>
<span id="702">702</span>
<span id="703">703</span>
<span id="704">704</span>
<span id="705">705</span>
<span id="706">706</span>
<span id="707">707</span>
<span id="708">708</span>
<span id="709">709</span>
<span id="710">710</span>
<span id="711">711</span>
<span id="712">712</span>
<span id="713">713</span>
<span id="714">714</span>
<span id="715">715</span>
<span id="716">716</span>
<span id="717">717</span>
<span id="718">718</span>
<span id="719">719</span>
<span id="720">720</span>
<span id="721">721</span>
<span id="722">722</span>
<span id="723">723</span>
<span id="724">724</span>
<span id="725">725</span>
<span id="726">726</span>
<span id="727">727</span>
<span id="728">728</span>
<span id="729">729</span>
<span id="730">730</span>
<span id="731">731</span>
<span id="732">732</span>
<span id="733">733</span>
<span id="734">734</span>
<span id="735">735</span>
<span id="736">736</span>
<span id="737">737</span>
<span id="738">738</span>
<span id="739">739</span>
<span id="740">740</span>
<span id="741">741</span>
<span id="742">742</span>
<span id="743">743</span>
<span id="744">744</span>
<span id="745">745</span>
<span id="746">746</span>
<span id="747">747</span>
<span id="748">748</span>
<span id="749">749</span>
<span id="750">750</span>
<span id="751">751</span>
<span id="752">752</span>
<span id="753">753</span>
<span id="754">754</span>
<span id="755">755</span>
<span id="756">756</span>
<span id="757">757</span>
<span id="758">758</span>
<span id="759">759</span>
<span id="760">760</span>
<span id="761">761</span>
<span id="762">762</span>
<span id="763">763</span>
<span id="764">764</span>
<span id="765">765</span>
<span id="766">766</span>
<span id="767">767</span>
<span id="768">768</span>
<span id="769">769</span>
<span id="770">770</span>
<span id="771">771</span>
<span id="772">772</span>
<span id="773">773</span>
<span id="774">774</span>
<span id="775">775</span>
<span id="776">776</span>
<span id="777">777</span>
<span id="778">778</span>
<span id="779">779</span>
<span id="780">780</span>
<span id="781">781</span>
<span id="782">782</span>
<span id="783">783</span>
<span id="784">784</span>
<span id="785">785</span>
<span id="786">786</span>
<span id="787">787</span>
<span id="788">788</span>
<span id="789">789</span>
<span id="790">790</span>
<span id="791">791</span>
<span id="792">792</span>
<span id="793">793</span>
<span id="794">794</span>
<span id="795">795</span>
<span id="796">796</span>
<span id="797">797</span>
<span id="798">798</span>
<span id="799">799</span>
<span id="800">800</span>
<span id="801">801</span>
<span id="802">802</span>
<span id="803">803</span>
<span id="804">804</span>
<span id="805">805</span>
<span id="806">806</span>
<span id="807">807</span>
<span id="808">808</span>
<span id="809">809</span>
<span id="810">810</span>
<span id="811">811</span>
<span id="812">812</span>
<span id="813">813</span>
<span id="814">814</span>
<span id="815">815</span>
<span id="816">816</span>
<span id="817">817</span>
<span id="818">818</span>
<span id="819">819</span>
<span id="820">820</span>
<span id="821">821</span>
<span id="822">822</span>
<span id="823">823</span>
<span id="824">824</span>
<span id="825">825</span>
<span id="826">826</span>
<span id="827">827</span>
<span id="828">828</span>
<span id="829">829</span>
<span id="830">830</span>
<span id="831">831</span>
<span id="832">832</span>
<span id="833">833</span>
<span id="834">834</span>
<span id="835">835</span>
<span id="836">836</span>
<span id="837">837</span>
<span id="838">838</span>
<span id="839">839</span>
<span id="840">840</span>
<span id="841">841</span>
<span id="842">842</span>
<span id="843">843</span>
<span id="844">844</span>
<span id="845">845</span>
<span id="846">846</span>
<span id="847">847</span>
<span id="848">848</span>
<span id="849">849</span>
<span id="850">850</span>
<span id="851">851</span>
<span id="852">852</span>
<span id="853">853</span>
<span id="854">854</span>
<span id="855">855</span>
<span id="856">856</span>
<span id="857">857</span>
<span id="858">858</span>
<span id="859">859</span>
<span id="860">860</span>
<span id="861">861</span>
<span id="862">862</span>
<span id="863">863</span>
<span id="864">864</span>
<span id="865">865</span>
<span id="866">866</span>
<span id="867">867</span>
<span id="868">868</span>
<span id="869">869</span>
<span id="870">870</span>
<span id="871">871</span>
<span id="872">872</span>
<span id="873">873</span>
<span id="874">874</span>
<span id="875">875</span>
<span id="876">876</span>
<span id="877">877</span>
<span id="878">878</span>
<span id="879">879</span>
<span id="880">880</span>
<span id="881">881</span>
<span id="882">882</span>
<span id="883">883</span>
<span id="884">884</span>
<span id="885">885</span>
<span id="886">886</span>
<span id="887">887</span>
<span id="888">888</span>
<span id="889">889</span>
<span id="890">890</span>
<span id="891">891</span>
<span id="892">892</span>
<span id="893">893</span>
<span id="894">894</span>
<span id="895">895</span>
<span id="896">896</span>
<span id="897">897</span>
<span id="898">898</span>
<span id="899">899</span>
<span id="900">900</span>
<span id="901">901</span>
<span id="902">902</span>
<span id="903">903</span>
<span id="904">904</span>
<span id="905">905</span>
<span id="906">906</span>
<span id="907">907</span>
<span id="908">908</span>
<span id="909">909</span>
<span id="910">910</span>
<span id="911">911</span>
<span id="912">912</span>
<span id="913">913</span>
<span id="914">914</span>
<span id="915">915</span>
<span id="916">916</span>
<span id="917">917</span>
<span id="918">918</span>
<span id="919">919</span>
<span id="920">920</span>
<span id="921">921</span>
<span id="922">922</span>
<span id="923">923</span>
<span id="924">924</span>
<span id="925">925</span>
<span id="926">926</span>
<span id="927">927</span>
<span id="928">928</span>
<span id="929">929</span>
<span id="930">930</span>
<span id="931">931</span>
<span id="932">932</span>
<span id="933">933</span>
<span id="934">934</span>
<span id="935">935</span>
<span id="936">936</span>
<span id="937">937</span>
<span id="938">938</span>
<span id="939">939</span>
<span id="940">940</span>
<span id="941">941</span>
<span id="942">942</span>
<span id="943">943</span>
<span id="944">944</span>
<span id="945">945</span>
<span id="946">946</span>
<span id="947">947</span>
<span id="948">948</span>
<span id="949">949</span>
<span id="950">950</span>
<span id="951">951</span>
<span id="952">952</span>
<span id="953">953</span>
<span id="954">954</span>
<span id="955">955</span>
<span id="956">956</span>
<span id="957">957</span>
<span id="958">958</span>
<span id="959">959</span>
<span id="960">960</span>
<span id="961">961</span>
<span id="962">962</span>
<span id="963">963</span>
<span id="964">964</span>
<span id="965">965</span>
<span id="966">966</span>
<span id="967">967</span>
<span id="968">968</span>
<span id="969">969</span>
<span id="970">970</span>
<span id="971">971</span>
<span id="972">972</span>
<span id="973">973</span>
<span id="974">974</span>
<span id="975">975</span>
<span id="976">976</span>
<span id="977">977</span>
<span id="978">978</span>
<span id="979">979</span>
<span id="980">980</span>
<span id="981">981</span>
<span id="982">982</span>
<span id="983">983</span>
<span id="984">984</span>
<span id="985">985</span>
<span id="986">986</span>
<span id="987">987</span>
<span id="988">988</span>
<span id="989">989</span>
<span id="990">990</span>
<span id="991">991</span>
<span id="992">992</span>
<span id="993">993</span>
<span id="994">994</span>
<span id="995">995</span>
<span id="996">996</span>
<span id="997">997</span>
<span id="998">998</span>
<span id="999">999</span>
<span id="1000">1000</span>
<span id="1001">1001</span>
<span id="1002">1002</span>
<span id="1003">1003</span>
<span id="1004">1004</span>
<span id="1005">1005</span>
<span id="1006">1006</span>
<span id="1007">1007</span>
<span id="1008">1008</span>
<span id="1009">1009</span>
<span id="1010">1010</span>
<span id="1011">1011</span>
<span id="1012">1012</span>
<span id="1013">1013</span>
<span id="1014">1014</span>
<span id="1015">1015</span>
<span id="1016">1016</span>
<span id="1017">1017</span>
<span id="1018">1018</span>
<span id="1019">1019</span>
<span id="1020">1020</span>
<span id="1021">1021</span>
<span id="1022">1022</span>
<span id="1023">1023</span>
<span id="1024">1024</span>
<span id="1025">1025</span>
<span id="1026">1026</span>
<span id="1027">1027</span>
<span id="1028">1028</span>
<span id="1029">1029</span>
<span id="1030">1030</span>
<span id="1031">1031</span>
<span id="1032">1032</span>
<span id="1033">1033</span>
<span id="1034">1034</span>
<span id="1035">1035</span>
<span id="1036">1036</span>
<span id="1037">1037</span>
<span id="1038">1038</span>
<span id="1039">1039</span>
<span id="1040">1040</span>
<span id="1041">1041</span>
<span id="1042">1042</span>
<span id="1043">1043</span>
<span id="1044">1044</span>
<span id="1045">1045</span>
<span id="1046">1046</span>
<span id="1047">1047</span>
<span id="1048">1048</span>
<span id="1049">1049</span>
<span id="1050">1050</span>
<span id="1051">1051</span>
<span id="1052">1052</span>
<span id="1053">1053</span>
<span id="1054">1054</span>
<span id="1055">1055</span>
<span id="1056">1056</span>
<span id="1057">1057</span>
<span id="1058">1058</span>
<span id="1059">1059</span>
<span id="1060">1060</span>
<span id="1061">1061</span>
<span id="1062">1062</span>
<span id="1063">1063</span>
<span id="1064">1064</span>
<span id="1065">1065</span>
<span id="1066">1066</span>
<span id="1067">1067</span>
<span id="1068">1068</span>
<span id="1069">1069</span>
<span id="1070">1070</span>
<span id="1071">1071</span>
<span id="1072">1072</span>
<span id="1073">1073</span>
<span id="1074">1074</span>
<span id="1075">1075</span>
<span id="1076">1076</span>
<span id="1077">1077</span>
<span id="1078">1078</span>
<span id="1079">1079</span>
<span id="1080">1080</span>
<span id="1081">1081</span>
<span id="1082">1082</span>
<span id="1083">1083</span>
<span id="1084">1084</span>
<span id="1085">1085</span>
<span id="1086">1086</span>
<span id="1087">1087</span>
<span id="1088">1088</span>
<span id="1089">1089</span>
<span id="1090">1090</span>
<span id="1091">1091</span>
<span id="1092">1092</span>
<span id="1093">1093</span>
<span id="1094">1094</span>
<span id="1095">1095</span>
<span id="1096">1096</span>
<span id="1097">1097</span>
<span id="1098">1098</span>
<span id="1099">1099</span>
<span id="1100">1100</span>
<span id="1101">1101</span>
<span id="1102">1102</span>
<span id="1103">1103</span>
<span id="1104">1104</span>
<span id="1105">1105</span>
<span id="1106">1106</span>
<span id="1107">1107</span>
<span id="1108">1108</span>
<span id="1109">1109</span>
<span id="1110">1110</span>
<span id="1111">1111</span>
<span id="1112">1112</span>
<span id="1113">1113</span>
<span id="1114">1114</span>
<span id="1115">1115</span>
<span id="1116">1116</span>
<span id="1117">1117</span>
<span id="1118">1118</span>
<span id="1119">1119</span>
<span id="1120">1120</span>
<span id="1121">1121</span>
<span id="1122">1122</span>
<span id="1123">1123</span>
<span id="1124">1124</span>
<span id="1125">1125</span>
<span id="1126">1126</span>
<span id="1127">1127</span>
<span id="1128">1128</span>
<span id="1129">1129</span>
<span id="1130">1130</span>
<span id="1131">1131</span>
<span id="1132">1132</span>
<span id="1133">1133</span>
<span id="1134">1134</span>
<span id="1135">1135</span>
<span id="1136">1136</span>
<span id="1137">1137</span>
<span id="1138">1138</span>
<span id="1139">1139</span>
<span id="1140">1140</span>
<span id="1141">1141</span>
<span id="1142">1142</span>
<span id="1143">1143</span>
<span id="1144">1144</span>
<span id="1145">1145</span>
<span id="1146">1146</span>
<span id="1147">1147</span>
<span id="1148">1148</span>
<span id="1149">1149</span>
<span id="1150">1150</span>
<span id="1151">1151</span>
<span id="1152">1152</span>
<span id="1153">1153</span>
<span id="1154">1154</span>
<span id="1155">1155</span>
<span id="1156">1156</span>
<span id="1157">1157</span>
<span id="1158">1158</span>
<span id="1159">1159</span>
<span id="1160">1160</span>
<span id="1161">1161</span>
<span id="1162">1162</span>
<span id="1163">1163</span>
<span id="1164">1164</span>
<span id="1165">1165</span>
<span id="1166">1166</span>
<span id="1167">1167</span>
<span id="1168">1168</span>
<span id="1169">1169</span>
<span id="1170">1170</span>
<span id="1171">1171</span>
<span id="1172">1172</span>
<span id="1173">1173</span>
<span id="1174">1174</span>
<span id="1175">1175</span>
<span id="1176">1176</span>
<span id="1177">1177</span>
<span id="1178">1178</span>
<span id="1179">1179</span>
<span id="1180">1180</span>
<span id="1181">1181</span>
<span id="1182">1182</span>
<span id="1183">1183</span>
<span id="1184">1184</span>
<span id="1185">1185</span>
<span id="1186">1186</span>
<span id="1187">1187</span>
<span id="1188">1188</span>
<span id="1189">1189</span>
<span id="1190">1190</span>
<span id="1191">1191</span>
<span id="1192">1192</span>
<span id="1193">1193</span>
<span id="1194">1194</span>
<span id="1195">1195</span>
<span id="1196">1196</span>
<span id="1197">1197</span>
<span id="1198">1198</span>
<span id="1199">1199</span>
<span id="1200">1200</span>
<span id="1201">1201</span>
<span id="1202">1202</span>
<span id="1203">1203</span>
<span id="1204">1204</span>
<span id="1205">1205</span>
<span id="1206">1206</span>
<span id="1207">1207</span>
<span id="1208">1208</span>
<span id="1209">1209</span>
<span id="1210">1210</span>
<span id="1211">1211</span>
<span id="1212">1212</span>
<span id="1213">1213</span>
<span id="1214">1214</span>
<span id="1215">1215</span>
<span id="1216">1216</span>
<span id="1217">1217</span>
<span id="1218">1218</span>
<span id="1219">1219</span>
<span id="1220">1220</span>
<span id="1221">1221</span>
<span id="1222">1222</span>
<span id="1223">1223</span>
<span id="1224">1224</span>
<span id="1225">1225</span>
<span id="1226">1226</span>
<span id="1227">1227</span>
<span id="1228">1228</span>
<span id="1229">1229</span>
<span id="1230">1230</span>
<span id="1231">1231</span>
<span id="1232">1232</span>
<span id="1233">1233</span>
<span id="1234">1234</span>
<span id="1235">1235</span>
<span id="1236">1236</span>
<span id="1237">1237</span>
<span id="1238">1238</span>
<span id="1239">1239</span>
<span id="1240">1240</span>
<span id="1241">1241</span>
<span id="1242">1242</span>
<span id="1243">1243</span>
<span id="1244">1244</span>
<span id="1245">1245</span>
<span id="1246">1246</span>
<span id="1247">1247</span>
<span id="1248">1248</span>
<span id="1249">1249</span>
<span id="1250">1250</span>
<span id="1251">1251</span>
<span id="1252">1252</span>
<span id="1253">1253</span>
<span id="1254">1254</span>
<span id="1255">1255</span>
<span id="1256">1256</span>
<span id="1257">1257</span>
<span id="1258">1258</span>
<span id="1259">1259</span>
<span id="1260">1260</span>
<span id="1261">1261</span>
<span id="1262">1262</span>
<span id="1263">1263</span>
<span id="1264">1264</span>
<span id="1265">1265</span>
<span id="1266">1266</span>
<span id="1267">1267</span>
<span id="1268">1268</span>
<span id="1269">1269</span>
<span id="1270">1270</span>
<span id="1271">1271</span>
<span id="1272">1272</span>
<span id="1273">1273</span>
<span id="1274">1274</span>
<span id="1275">1275</span>
<span id="1276">1276</span>
<span id="1277">1277</span>
<span id="1278">1278</span>
<span id="1279">1279</span>
<span id="1280">1280</span>
<span id="1281">1281</span>
<span id="1282">1282</span>
<span id="1283">1283</span>
<span id="1284">1284</span>
</pre><pre class="rust"><code><span class="doccomment">//! Encoded pointer to a span region.

</span><span class="attribute">#[cfg(any(feature = <span class="string">&quot;alloc&quot;</span>, test))]
</span><span class="kw">use </span>core::convert::TryInto;
<span class="kw">use </span>core::{
	any,
	convert::Infallible,
	fmt::{
		<span class="self">self</span>,
		Debug,
		Display,
		Formatter,
		Pointer,
	},
	marker::PhantomData,
	ptr::{
		<span class="self">self</span>,
		NonNull,
	},
};

<span class="kw">use </span>funty::IsNumber;
<span class="kw">use </span>wyz::fmt::FmtForward;

<span class="kw">use super</span>::{
	Address,
	BitPtr,
	BitPtrError,
	BitPtrRange,
	Const,
	Mut,
	Mutability,
};
<span class="kw">use crate</span>::{
	domain::Domain,
	index::{
		BitEnd,
		BitIdx,
	},
	mem::BitMemory,
	order::{
		BitOrder,
		Lsb0,
	},
	slice::BitSlice,
	store::BitStore,
};

<span class="doccomment">/** Encoded handle to a bit-precision memory region.

Rust slices use a pointer/length encoding to represent regions of memory.
References to slices of data, `&amp;[T]`, have the ABI layout `(*const T, usize)`.

`BitSpan` encodes a base address, a first-bit index, and a length counter, into
the Rust slice reference layout using this structure. This permits [`bitvec`] to
use an opaque reference type in its implementation of Rust interfaces that
require references, rather than immediate value types.

# Layout

This structure is a more complex version of the `*const T`/`usize` tuple that
Rust uses to represent slices throughout the language. It breaks the pointer and
counter fundamentals into sub-field components. Rust does not have bitfield
syntax, so the below description of the structure layout is in C++.

```cpp
template &lt;typename T&gt;
struct BitSpan {
  uintptr_t ptr_head : __builtin_ctzll(alignof(T));
  uintptr_t ptr_addr : sizeof(uintptr_T) * 8 - __builtin_ctzll(alignof(T));

  size_t len_head : 3;
  size_t len_bits : sizeof(size_t) * 8 - 3;
};
```

This means that the `BitSpan&lt;O, T&gt;` has three *logical* fields, stored in four
segments, across the two *structural* fields of the type. The widths and
placements of each segment are functions of the size of `*const T`, `usize`, and
of the alignment of the `T` referent buffer element type.

# Fields

This section describes the purpose, semantic meaning, and layout of the three
logical fields.

## Base Address

The address of the base element in a memory region is stored in all but the
lowest bits of the `ptr` field. An aligned pointer to `T` will always have its
lowest log&lt;sub&gt;2&lt;/sub&gt;(byte width) bits zeroed, so those bits can be used to
store other information, as long as they are erased before dereferencing the
address as a pointer to `T`.

## Head Bit Index

For any referent element type `T`, the selection of a single bit within the
element requires log&lt;sub&gt;2&lt;/sub&gt;(byte width) bits to select a byte within the
element `T`, and another three bits to select a bit within the selected byte.

|Type |Alignment|Trailing Zeros|Count Bits|
|:----|--------:|-------------:|---------:|
|`u8` |        1|             0|         3|
|`u16`|        2|             1|         4|
|`u32`|        4|             2|         5|
|`u64`|        8|             3|         6|

The index of the first live bit in the base element is split to have its three
least significant bits stored in the least significant edge of the `len` field,
and its remaining bits stored in the least significant edge of the `ptr` field.

## Length Counter

All but the lowest three bits of the `len` field are used to store a counter of
live bits in the referent region. When this is zero, the region is empty.
Because it is missing three bits, a `BitSpan` has only ⅛ of the index space of
a `usize` value.

# Significant Values

The following values represent significant instances of the `BitSpan` type.

## Null Slice

The fully-zeroed slot is not a valid member of the `BitSpan&lt;O, T&gt;` type; it is
reserved instead as the sentinel value for `Option::&lt;BitSpan&lt;O, T&gt;&gt;::None`.

## Canonical Empty Slice

All pointers with a `bits: 0` logical field are empty. Pointers that are used to
maintain ownership of heap buffers are not permitted to erase their `addr`
field. The canonical form of the empty slice has an `addr` value of
[`NonNull::&lt;T&gt;::dangling()`], but all pointers to an empty region are equivalent
regardless of address.

### Uninhabited Slices

Any empty pointer with a non-[`dangling()`] base address is considered to be an
uninhabited region. `BitSpan` never discards its address information, even as
operations may alter or erase its head-index or length values.

# Type Parameters

- `O`: The ordering within the register type. The bit-ordering used within a
  region colors all pointers to the region, and orderings can never mix.
- `T`: The memory type of the referent region. `BitSpan&lt;O, T&gt;` is a specialized
  `*[T]` slice pointer, and operates on memory in terms of the `T` type for
  access instructions and pointer calculation.

# Safety

`BitSpan` values may only be constructed from pointers provided by the
surrounding program.

# Undefined Behavior

Values of this type are binary-incompatible with slice pointers. Transmutation
of these values into any other type will result in an incorrect program, and
permit the program to begin illegal or undefined behaviors. This type may never
be manipulated in any way by user code outside of the APIs it offers to this
[`bitvec`]; it certainly may not be seen or observed by other crates.

[`NonNull::&lt;T&gt;::dangling()`]: core::ptr::NonNull::dangling
[`bitvec`]: crate
[`dangling()`]: core::ptr::NonNull::dangling
**/
</span><span class="attribute">#[repr(C)]
</span><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">struct </span>BitSpan&lt;M = Const, O = Lsb0, T = usize&gt;
<span class="kw">where
	</span>M: Mutability,
	O: BitOrder,
	T: BitStore,
{
	<span class="doccomment">/// Memory address and high bits of the head index.
	///
	/// This stores the address of the zeroth element of the slice, as well as
	/// the high bits of the head bit cursor. It is typed as a [`NonNull&lt;()&gt;`]
	/// in order to provide null-value optimizations to `Option&lt;BitSpan&lt;O, T&gt;&gt;`,
	/// and because the presence of head-bit cursor information in the lowest
	/// bits means that the bit pattern will not uphold alignment properties
	/// required by `NonNull&lt;T&gt;`.
	///
	/// This field cannot be treated as the address of the zeroth byte of the
	/// slice domain, because the owning handle’s [`BitOrder`] implementation
	/// governs the bit pattern of the head cursor.
	///
	/// [`BitOrder`]: crate::order::BitOrder
	/// [`NonNull&lt;()&gt;`]: core::ptr::NonNull
	</span>ptr: NonNull&lt;()&gt;,
	<span class="doccomment">/// Length counter and low bits of the head index.
	///
	/// This stores the slice length counter (measured in bits) in all but its
	/// lowest three bits, and the lowest three bits of the index counter in its
	/// lowest three bits.
	</span>len: usize,
	<span class="doccomment">/// Bit-region pointers must be colored by the bit-ordering they use.
	</span>_or: PhantomData&lt;O&gt;,
	<span class="doccomment">/// This is semantically a pointer to a `T` element.
	</span>_ty: PhantomData&lt;Address&lt;M, T&gt;&gt;,
}

<span class="kw">impl</span>&lt;M, O, T&gt; BitSpan&lt;M, O, T&gt;
<span class="kw">where
	</span>M: Mutability,
	O: BitOrder,
	T: BitStore,
{
	<span class="doccomment">/// The canonical form of a pointer to an empty region.
	</span><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">const </span>EMPTY: <span class="self">Self </span>= <span class="self">Self </span>{
		<span class="comment">/* Note: this must always construct the `T` dangling pointer, and then
		convert it into a pointer to `u8`. Creating `NonNull::dangling()`
		directly will always instantiate the `NonNull::&lt;u8&gt;::dangling()`
		pointer, which is VERY incorrect for any other `T` typarams.
		*/
		</span>ptr: NonNull::&lt;T&gt;::dangling().cast::&lt;()&gt;(),
		len: <span class="number">0</span>,
		_or: PhantomData,
		_ty: PhantomData,
	};
	<span class="doccomment">/// The number of low bits of `self.len` required to hold the low bits of
	/// the head [`BitIdx`] cursor.
	///
	/// This is always `3`, until Rust tries to target an architecture that does
	/// not have 8-bit bytes.
	///
	/// [`BitIdx`]: crate::index::BitIdx
	</span><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">const </span>LEN_HEAD_BITS: usize = <span class="number">3</span>;
	<span class="doccomment">/// Marks the bits of `self.len` that hold part of the `head` logical field.
	</span><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">const </span>LEN_HEAD_MASK: usize = <span class="number">0b111</span>;
	<span class="doccomment">/// Marks the bits of `self.ptr` that hold the `addr` logical field.
	</span><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">const </span>PTR_ADDR_MASK: usize = !<span class="number">0 </span>&lt;&lt; <span class="self">Self</span>::PTR_HEAD_BITS;
	<span class="doccomment">/// The number of low bits of `self.ptr` required to hold the high bits of
	/// the head [`BitIdx`] cursor.
	///
	/// [`BitIdx`]: crate::index::BitIdx
	</span><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">const </span>PTR_HEAD_BITS: usize =
		T::Mem::INDX <span class="kw">as </span>usize - <span class="self">Self</span>::LEN_HEAD_BITS;
	<span class="doccomment">/// Marks the bits of `self.ptr` that hold part of the `head` logical field.
	</span><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">const </span>PTR_HEAD_MASK: usize = !<span class="self">Self</span>::PTR_ADDR_MASK;
	<span class="doccomment">/// The inclusive-maximum number of bits that a `BitSpan` can cover.
	</span><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">const </span>REGION_MAX_BITS: usize = !<span class="number">0 </span>&gt;&gt; <span class="self">Self</span>::LEN_HEAD_BITS;
	<span class="doccomment">/// The inclusive-maximum number of elements that the region described by a
	/// `BitSpan` can cover in memory.
	///
	/// This is the number of elements required to store [`REGION_MAX_BITS`],
	/// plus one because a region could start in the middle of its base element
	/// and thus push the final bits into a new element.
	///
	/// Since the region is ⅛th the bit span of a `usize` counter already, this
	/// number is guaranteed to be well below the limits of arithmetic or Rust’s
	/// own constraints on memory region handles.
	///
	/// [`REGION_MAX_BITS`]: Self::REGION_MAX_BITS
	</span><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">const </span>REGION_MAX_ELTS: usize =
		<span class="kw">crate</span>::mem::elts::&lt;T::Mem&gt;(<span class="self">Self</span>::REGION_MAX_BITS) + <span class="number">1</span>;

	<span class="comment">//  Constructors

	</span><span class="doccomment">/// Constructs an empty `BitSpan` at a bare pointer.
	///
	/// This is used when the region has no contents, but the pointer
	/// information must be retained.
	///
	/// # Parameters
	///
	/// - `addr`: Some address of a `T` element or region. It must be valid in
	///   the caller’s memory space.
	///
	/// # Returns
	///
	/// A zero-length `BitSpan` pointing to `addr`.
	///
	/// # Panics
	///
	/// This function panics if `addr` is null or misaligned. All pointers
	/// received from the allocation system are required to satisfy this
	/// constraint, so a failure is an exceptional program fault rather than an
	/// expected logical mistake.
	</span><span class="attribute">#[inline(always)]
	#[cfg(feature = <span class="string">&quot;alloc&quot;</span>)]
	#[cfg(not(tarpaulin_include))]
	</span><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn </span>uninhabited(addr: Address&lt;M, T&gt;) -&gt; <span class="self">Self </span>{
		<span class="self">Self </span>{
			ptr: addr.into_inner().cast::&lt;()&gt;(),
			len: <span class="number">0</span>,
			_or: PhantomData,
			_ty: PhantomData,
		}
	}

	<span class="attribute">#[inline]
	</span><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn </span>new(
		addr: Address&lt;M, T&gt;,
		head: BitIdx&lt;T::Mem&gt;,
		bits: usize,
	) -&gt; <span class="prelude-ty">Result</span>&lt;<span class="self">Self</span>, BitSpanError&lt;T&gt;&gt; {
		<span class="kw">if </span>bits &gt; <span class="self">Self</span>::REGION_MAX_BITS {
			<span class="kw">return </span><span class="prelude-val">Err</span>(BitSpanError::TooLong(bits));
		};
		<span class="kw">let </span>base = BitPtr::&lt;M, O, T&gt;::new(addr, head);
		<span class="kw">let </span>last = base.wrapping_add(bits);
		<span class="kw">if </span>last &lt; base {
			<span class="kw">return </span><span class="prelude-val">Err</span>(BitSpanError::TooHigh(addr.to_const()));
		};

		<span class="prelude-val">Ok</span>(<span class="kw">unsafe </span>{ <span class="self">Self</span>::new_unchecked(addr, head, bits) })
	}

	<span class="doccomment">/// Creates a new `BitSpan` from its components, without any validity
	/// checks.
	///
	/// # Safety
	///
	/// ***ABSOLUTELY NONE.*** This function *only* packs its arguments into the
	/// bit pattern of the `BitSpan` type. It should only be used in
	/// contexts where a previously extant `BitSpan` was constructed with
	/// ancestry known to have survived [`::new`], and any manipulations of its
	/// raw components are known to be valid for reconstruction.
	///
	/// # Parameters
	///
	/// See [`::new`].
	///
	/// # Returns
	///
	/// See [`::new`].
	///
	/// [`::new`]: Self::new
	</span><span class="attribute">#[inline]
	</span><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">unsafe fn </span>new_unchecked(
		addr: Address&lt;M, T&gt;,
		head: BitIdx&lt;T::Mem&gt;,
		bits: usize,
	) -&gt; <span class="self">Self </span>{
		<span class="kw">let </span>head = head.into_inner() <span class="kw">as </span>usize;
		<span class="kw">let </span>ptr_data = addr.to_const() <span class="kw">as </span>usize &amp; <span class="self">Self</span>::PTR_ADDR_MASK;
		<span class="kw">let </span>ptr_head = head &gt;&gt; <span class="self">Self</span>::LEN_HEAD_BITS;

		<span class="kw">let </span>len_head = head &amp; <span class="self">Self</span>::LEN_HEAD_MASK;
		<span class="kw">let </span>len_bits = bits &lt;&lt; <span class="self">Self</span>::LEN_HEAD_BITS;

		<span class="self">Self </span>{
			ptr: NonNull::new_unchecked((ptr_data | ptr_head) <span class="kw">as </span><span class="kw-2">*mut </span>()),
			len: len_bits | len_head,
			_or: PhantomData,
			_ty: PhantomData,
		}
	}

	<span class="comment">//  Converters

	</span><span class="doccomment">/// Converts an opaque `*BitSlice` wide pointer back into a `BitSpan`.
	///
	/// See [`::from_bitslice_ptr()`].
	///
	/// [`::from_bitslice_ptr()`]: Self::from_bitslice_ptr
	</span><span class="comment">//  Mutable pointers can become mutable or immutable span descriptors.
	</span><span class="attribute">#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	</span><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn </span>from_bitslice_ptr_mut(raw: <span class="kw-2">*mut </span>BitSlice&lt;O, T&gt;) -&gt; <span class="self">Self </span>{
		<span class="kw">let </span>BitSpan { ptr, len, _or, .. } =
			BitSpan::from_bitslice_ptr(raw <span class="kw">as </span><span class="kw-2">*const </span>BitSlice&lt;O, T&gt;);
		<span class="self">Self </span>{
			ptr,
			len,
			_or,
			_ty: PhantomData,
		}
	}

	<span class="doccomment">/// Casts the `BitSpan` to an opaque `*BitSlice` pointer.
	///
	/// This is the inverse of [`::from_bitslice_ptr()`].
	///
	/// # Parameters
	///
	/// - `self`
	///
	/// # Returns
	///
	/// `self`, opacified as a `*BitSlice` raw pointer rather than a `BitSpan`
	/// structure.
	///
	/// [`::from_bitslice_ptr()`]: Self::from_bitslice_ptr
	</span><span class="comment">//  Mutable or immutable span descriptors can become immutable pointers.
	</span><span class="attribute">#[inline]
	</span><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn </span>to_bitslice_ptr(<span class="self">self</span>) -&gt; <span class="kw-2">*const </span>BitSlice&lt;O, T&gt; {
		ptr::slice_from_raw_parts(
			<span class="self">self</span>.ptr.as_ptr() <span class="kw">as </span><span class="kw-2">*const </span>u8 <span class="kw">as </span><span class="kw-2">*const </span>(),
			<span class="self">self</span>.len,
		) <span class="kw">as </span><span class="kw-2">*const </span>BitSlice&lt;O, T&gt;
	}

	<span class="doccomment">/// Casts the `BitSpan` to a `&amp;BitSlice` reference.
	///
	/// This requires that the pointer be to a validly-allocated region that
	/// is not destroyed for the duration of the provided lifetime.
	/// Additionally, the bits described by `self` must not be writable by any
	/// other handle.
	///
	/// # Lifetimes
	///
	/// - `&#39;a`: A caller-provided lifetime that must not be greater than the
	///   duration of the referent buffer.
	///
	/// # Parameters
	///
	/// - `self`
	///
	/// # Returns
	///
	/// `self`, opacified as a bit-slice region reference rather than a
	/// `BitSpan` structure.
	</span><span class="comment">//  Mutable or immutable span descriptors can become immutable references.
	</span><span class="attribute">#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	</span><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn </span>to_bitslice_ref&lt;<span class="lifetime">&#39;a</span>&gt;(<span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span>BitSlice&lt;O, T&gt; {
		<span class="kw">unsafe </span>{ <span class="kw-2">&amp;*</span><span class="self">self</span>.to_bitslice_ptr() }
	}

	<span class="doccomment">/// Casts the span to another element type.
	///
	/// This does not alter the encoded value of the pointer! It only
	/// reinterprets the element type, and the encoded value may shift
	/// significantly in the result type. Use with caution.
	</span><span class="attribute">#[cfg_attr(not(tarpaulin_include), inline(always))]
	</span><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn </span>cast&lt;U&gt;(<span class="self">self</span>) -&gt; BitSpan&lt;M, O, U&gt;
	<span class="kw">where </span>U: BitStore {
		<span class="kw">let </span><span class="self">Self </span>{ ptr, len, .. } = <span class="self">self</span>;
		BitSpan {
			ptr,
			len,
			..BitSpan::EMPTY
		}
	}

	<span class="doccomment">/// Split the region descriptor into three descriptors, with the interior
	/// set to a different register type.
	///
	/// By placing the logic in `BitSpan` rather than in `BitSlice`, `BitSlice`
	/// can safely call into it for both shared and exclusive references,
	/// without running into any reference capability issues in the compiler.
	///
	/// # Type Parameters
	///
	/// - `U`: A second [`BitStore`] implementation. This **must** be of the
	///   same type family as `T`; this restriction cannot be enforced in the
	///   type system, but **must** hold at the call site.
	///
	/// # Safety
	///
	/// This can only be called within `BitSlice::align_to{,_mut}`.
	///
	/// # Algorithm
	///
	/// This uses the slice [`Domain`] to split the underlying slice into
	/// regions that cannot (edge) and can (center) be reäligned. The center
	/// slice is then reäligned to `U`, and the edge slices produced from *that*
	/// are merged with the edge slices produced by the domain check.
	///
	/// This results in edge pointers returned from this function that correctly
	/// handle partially-used edge elements as well as misaligned slice
	/// locations.
	///
	/// [`BitStore`]: crate::store::BitStore
	/// [`Domain`]: crate::domain::Domain
	/// [`slice::align_to`]: https://doc.rust-lang.org/stable/std/primitive.slice.html#method.align_to
	</span><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">unsafe fn </span>align_to&lt;U&gt;(<span class="self">self</span>) -&gt; (<span class="self">Self</span>, BitSpan&lt;M, O, U&gt;, <span class="self">Self</span>)
	<span class="kw">where </span>U: BitStore {
		<span class="kw">match </span><span class="self">self</span>.to_bitslice_ref().domain() {
			Domain::Enclave { .. } =&gt; (<span class="self">self</span>, BitSpan::EMPTY, BitSpan::EMPTY),
			Domain::Region { head, body, tail } =&gt; {
				<span class="comment">//  Reälign the fully-spanning center slice, creating edge
				//  slices of the original type to merge with `head` and `tail`.
				</span><span class="kw">let </span>(l, c, r) = body.align_to::&lt;U::Mem&gt;();

				<span class="kw">let </span>t_bits = T::Mem::BITS <span class="kw">as </span>usize;
				<span class="kw">let </span>u_bits = U::Mem::BITS <span class="kw">as </span>usize;

				<span class="kw">let </span>l_bits = l.len() * t_bits;
				<span class="kw">let </span>c_bits = c.len() * u_bits;
				<span class="kw">let </span>r_bits = r.len() * t_bits;

				<span class="kw">let </span>l_addr = l.as_ptr() <span class="kw">as </span><span class="kw-2">*const </span>T <span class="kw">as </span><span class="kw-2">*mut </span>T;
				<span class="kw">let </span>c_addr = c.as_ptr() <span class="kw">as </span><span class="kw-2">*const </span>U <span class="kw">as </span><span class="kw-2">*mut </span>U;
				<span class="kw">let </span>r_addr = r.as_ptr() <span class="kw">as </span><span class="kw-2">*const </span>T <span class="kw">as </span><span class="kw-2">*mut </span>T;

				<span class="comment">/* Compute a pointer for the left-most return span.

				The left span must contain the domain’s head element, if
				produced, as well as the `l` slice produced above. The left span
				begins in:

				- if `head` exists, then `head.1`
				- else, if `l` is not empty, then `l`
				- else, it is the empty pointer
				*/
				</span><span class="kw">let </span>l_ptr = <span class="kw">match </span>head {
					<span class="comment">/* If the head exists, then the left span begins in it, and
					runs for the remaining bits in it, and all the bits of `l`.
					*/
					</span><span class="prelude-val">Some</span>((head, addr)) =&gt; BitSpan::new_unchecked(
						Address::new(NonNull::from(addr)),
						head,
						t_bits - head.into_inner() <span class="kw">as </span>usize + l_bits,
					),
					<span class="comment">//  If the head does not exist, then the left span only
					//  covers `l`. If `l` is empty, then so is the span.
					</span><span class="prelude-val">None </span>=&gt; {
						<span class="kw">if </span>l_bits == <span class="number">0 </span>{
							BitSpan::EMPTY
						}
						<span class="kw">else </span>{
							BitSpan::new_unchecked(
								Address::new(NonNull::new(l_addr).unwrap()),
								BitIdx::ZERO,
								l_bits,
							)
						}
					},
				};

				<span class="kw">let </span>c_ptr = <span class="kw">if </span>c_bits == <span class="number">0 </span>{
					BitSpan::EMPTY
				}
				<span class="kw">else </span>{
					BitSpan::new_unchecked(
						Address::new(NonNull::new(c_addr).unwrap()),
						BitIdx::ZERO,
						c_bits,
					)
				};

				<span class="comment">/* Compute a pointer for the right-most return span.

				The right span must contain the `r` slice produced above, as
				well as the domain’s tail element, if produced. The right span
				begins in:

				- if `r` is not empty, then `r`
				- else, if `tail` exists, then `tail.0`
				- else, it is the empty pointer
				*/
				</span><span class="kw">let </span>r_ptr = <span class="kw">match </span>tail {
					<span class="comment">//  If the tail exists, then the right span extends into it.
					</span><span class="prelude-val">Some</span>((addr, tail)) =&gt; BitSpan::new_unchecked(
						<span class="comment">//  If the `r` slice exists, then the right span
						//  *begins* in it.
						</span><span class="kw">if </span>r.is_empty() {
							Address::new(NonNull::from(addr))
						}
						<span class="kw">else </span>{
							Address::new(NonNull::new(r_addr).unwrap())
						},
						BitIdx::ZERO,
						tail.into_inner() <span class="kw">as </span>usize + r_bits,
					),
					<span class="comment">//  If the tail does not exist, then the right span is only
					//  `r`.
					</span><span class="prelude-val">None </span>=&gt; {
						<span class="comment">//  If `r` exists, then the right span covers it.
						</span><span class="kw">if </span>!r.is_empty() {
							BitSpan::new_unchecked(
								Address::new(NonNull::new(r_addr).unwrap()),
								BitIdx::ZERO,
								r_bits,
							)
						}
						<span class="comment">//  Otherwise, the right span is empty.
						</span><span class="kw">else </span>{
							BitSpan::EMPTY
						}
					},
				};

				(l_ptr, c_ptr, r_ptr)
			},
		}
	}

	<span class="comment">//  Encoded fields

	</span><span class="doccomment">/// Gets the base element address of the referent region.
	///
	/// # Parameters
	///
	/// - `&amp;self`
	///
	/// # Returns
	///
	/// The address of the starting element of the memory region. This address
	/// is weakly typed so that it can be cast by call sites to the most useful
	/// access type.
	</span><span class="attribute">#[inline]
	</span><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn </span>address(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; Address&lt;M, T&gt; {
		<span class="kw">unsafe </span>{
			Address::new(NonNull::new_unchecked(
				(<span class="self">self</span>.ptr.as_ptr() <span class="kw">as </span>usize &amp; <span class="self">Self</span>::PTR_ADDR_MASK) <span class="kw">as </span><span class="kw-2">*mut </span>T,
			))
		}
	}

	<span class="doccomment">/// Overwrites the data pointer with a new address. This method does not
	/// perform safety checks on the new pointer.
	///
	/// # Parameters
	///
	/// - `&amp;mut self`
	/// - `ptr`: The new address of the `BitSpan`’s domain.
	///
	/// # Safety
	///
	/// None. The invariants of [`::new`] must be checked at the caller.
	///
	/// [`::new`]: Self::new
	</span><span class="attribute">#[inline]
	#[cfg(any(feature = <span class="string">&quot;alloc&quot;</span>, test))]
	</span><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">unsafe fn </span>set_address&lt;A&gt;(<span class="kw-2">&amp;mut </span><span class="self">self</span>, addr: A)
	<span class="kw">where
		</span>A: TryInto&lt;Address&lt;M, T&gt;&gt;,
		A::Error: Debug,
	{
		<span class="kw">let </span>addr = addr.try_into().unwrap();
		<span class="kw">let </span><span class="kw-2">mut </span>addr_value = addr.to_const() <span class="kw">as </span>usize;
		addr_value &amp;= <span class="self">Self</span>::PTR_ADDR_MASK;
		addr_value |= <span class="self">self</span>.ptr.as_ptr() <span class="kw">as </span>usize &amp; <span class="self">Self</span>::PTR_HEAD_MASK;
		<span class="self">self</span>.ptr = NonNull::new_unchecked(addr_value <span class="kw">as </span><span class="kw-2">*mut </span>());
	}

	<span class="doccomment">/// Gets the starting bit index of the referent region.
	///
	/// # Parameters
	///
	/// - `&amp;self`
	///
	/// # Returns
	///
	/// A [`BitIdx`] of the first live bit in the element at the
	/// [`self.address()`] address.
	///
	/// [`BitIdx`]: crate::index::BitIdx
	/// [`self.address()`]: Self::pointer
	</span><span class="attribute">#[inline]
	</span><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn </span>head(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; BitIdx&lt;T::Mem&gt; {
		<span class="comment">//  Get the high part of the head counter out of the pointer.
		</span><span class="kw">let </span>ptr = <span class="self">self</span>.ptr.as_ptr() <span class="kw">as </span>usize;
		<span class="kw">let </span>ptr_head = (ptr &amp; <span class="self">Self</span>::PTR_HEAD_MASK) &lt;&lt; <span class="self">Self</span>::LEN_HEAD_BITS;
		<span class="comment">//  Get the low part of the head counter out of the length.
		</span><span class="kw">let </span>len_head = <span class="self">self</span>.len &amp; <span class="self">Self</span>::LEN_HEAD_MASK;
		<span class="comment">//  Combine and mark as an index.
		</span><span class="kw">unsafe </span>{ BitIdx::new_unchecked((ptr_head | len_head) <span class="kw">as </span>u8) }
	}

	<span class="doccomment">/// Write a new `head` value into the pointer, with no other effects.
	///
	/// # Parameters
	///
	/// - `&amp;mut self`
	/// - `head`: A new starting index.
	///
	/// # Effects
	///
	/// `head` is written into the `.head` logical field, without affecting
	/// `.addr` or `.bits`.
	</span><span class="attribute">#[inline]
	#[cfg(any(feature = <span class="string">&quot;alloc&quot;</span>, test))]
	</span><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">unsafe fn </span>set_head(<span class="kw-2">&amp;mut </span><span class="self">self</span>, head: BitIdx&lt;T::Mem&gt;) {
		<span class="kw">let </span>head = head.into_inner() <span class="kw">as </span>usize;
		<span class="kw">let </span><span class="kw-2">mut </span>ptr = <span class="self">self</span>.ptr.as_ptr() <span class="kw">as </span>usize;

		ptr &amp;= <span class="self">Self</span>::PTR_ADDR_MASK;
		ptr |= head &gt;&gt; <span class="self">Self</span>::LEN_HEAD_BITS;
		<span class="self">self</span>.ptr = NonNull::new_unchecked(ptr <span class="kw">as </span><span class="kw-2">*mut </span>());

		<span class="self">self</span>.len &amp;= !<span class="self">Self</span>::LEN_HEAD_MASK;
		<span class="self">self</span>.len |= head &amp; <span class="self">Self</span>::LEN_HEAD_MASK;
	}

	<span class="doccomment">/// Gets the number of live bits in the referent region.
	///
	/// # Parameters
	///
	/// - `&amp;self`
	///
	/// # Returns
	///
	/// A count of how many live bits the region pointer describes.
	</span><span class="attribute">#[cfg_attr(not(tarpaulin_include), inline(always))]
	</span><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn </span>len(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; usize {
		<span class="self">self</span>.len &gt;&gt; <span class="self">Self</span>::LEN_HEAD_BITS
	}

	<span class="doccomment">/// Sets the `.bits` logical member to a new value.
	///
	/// # Parameters
	///
	/// - `&amp;mut self`
	/// - `len`: A new bit length. This must not be greater than
	///   [`REGION_MAX_BITS`].
	///
	/// # Effects
	///
	/// The `new_len` value is written directly into the `.bits` logical field.
	///
	/// [`REGION_MAX_BITS`]: Self::REGION_MAX_BITS
	</span><span class="attribute">#[cfg_attr(not(tarpaulin_include), inline(always))]
	</span><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">unsafe fn </span>set_len(<span class="kw-2">&amp;mut </span><span class="self">self</span>, new_len: usize) {
		<span class="macro">debug_assert!</span>(
			new_len &lt;= <span class="self">Self</span>::REGION_MAX_BITS,
			<span class="string">&quot;Length {} out of range&quot;</span>,
			new_len,
		);
		<span class="self">self</span>.len &amp;= <span class="self">Self</span>::LEN_HEAD_MASK;
		<span class="self">self</span>.len |= new_len &lt;&lt; <span class="self">Self</span>::LEN_HEAD_BITS;
	}

	<span class="doccomment">/// Gets a pointer to the starting bit of the span.
	</span><span class="attribute">#[inline]
	</span><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn </span>as_bitptr(<span class="self">self</span>) -&gt; BitPtr&lt;M, O, T&gt; {
		BitPtr::new(<span class="self">self</span>.address(), <span class="self">self</span>.head())
	}

	<span class="attribute">#[inline]
	</span><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn </span>as_bitptr_range(<span class="self">self</span>) -&gt; BitPtrRange&lt;M, O, T&gt; {
		<span class="kw">unsafe </span>{ <span class="self">self</span>.as_bitptr().range(<span class="self">self</span>.len()) }
	}

	<span class="doccomment">/// Gets the three logical components of the pointer.
	///
	/// # Parameters
	///
	/// - `&amp;self`
	///
	/// # Returns
	///
	/// - `.0`: The base address of the referent memory region.
	/// - `.1`: The index of the first live bit in the first element of the
	///   region.
	/// - `.2`: The number of live bits in the region.
	</span><span class="attribute">#[inline]
	</span><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn </span>raw_parts(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; (Address&lt;M, T&gt;, BitIdx&lt;T::Mem&gt;, usize) {
		(<span class="self">self</span>.address(), <span class="self">self</span>.head(), <span class="self">self</span>.len())
	}

	<span class="comment">//  Computed information

	</span><span class="doccomment">/// Computes the number of elements, starting at [`self.address()`], that
	/// the region touches.
	///
	/// # Parameters
	///
	/// - `&amp;self`
	///
	/// # Returns
	///
	/// The count of all elements, starting at [`self.address()`], that contain
	/// live bits included in the referent region.
	///
	/// [`self.address()`]: Self::pointer
	</span><span class="attribute">#[inline]
	</span><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn </span>elements(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; usize {
		<span class="comment">//  Find the distance of the last bit from the base address.
		</span><span class="kw">let </span>total = <span class="self">self</span>.len() + <span class="self">self</span>.head().into_inner() <span class="kw">as </span>usize;
		<span class="comment">//  The element count is always the bit count divided by the bit width,
		</span><span class="kw">let </span>base = total &gt;&gt; T::Mem::INDX;
		<span class="comment">//  plus whether any fractional element exists after the division.
		</span><span class="kw">let </span>tail = total <span class="kw">as </span>u8 &amp; T::Mem::MASK;
		base + (tail != <span class="number">0</span>) <span class="kw">as </span>usize
	}

	<span class="doccomment">/// Computes the tail index for the first dead bit after the live bits.
	///
	/// # Parameters
	///
	/// - `&amp;self`
	///
	/// # Returns
	///
	/// A `BitEnd` that is the index of the first dead bit after the last live
	/// bit in the last element. This will almost always be in the range `1 ..=
	/// T::Mem::BITS`.
	///
	/// It will be zero only when `self` is empty.
	</span><span class="attribute">#[inline]
	</span><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn </span>tail(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; BitEnd&lt;T::Mem&gt; {
		<span class="kw">let </span>(head, len) = (<span class="self">self</span>.head(), <span class="self">self</span>.len());

		<span class="kw">if </span>head.into_inner() == <span class="number">0 </span>&amp;&amp; len == <span class="number">0 </span>{
			<span class="kw">return </span>BitEnd::ZERO;
		}

		<span class="comment">//  Compute the in-element tail index as the head plus the length,
		//  modulated by the element width.
		</span><span class="kw">let </span>tail = (head.into_inner() <span class="kw">as </span>usize + len) &amp; T::Mem::MASK <span class="kw">as </span>usize;
		<span class="comment">/* If the tail is zero, wrap it to `T::Mem::BITS` as the maximal. This
		upshifts `1` (tail is zero) or `0` (tail is not), then sets the upshift
		on the rest of the tail, producing something in the range
		`1 ..= T::Mem::BITS`.
		*/
		</span><span class="kw">unsafe </span>{
			BitEnd::new_unchecked(
				(((tail == <span class="number">0</span>) <span class="kw">as </span>u8) &lt;&lt; T::Mem::INDX) | tail <span class="kw">as </span>u8,
			)
		}
	}

	<span class="comment">//  Manipulators

	</span><span class="doccomment">/// Increments the `.head` logical field, rolling over into `.addr`.
	///
	/// # Parameters
	///
	/// - `&amp;mut self`
	///
	/// # Effects
	///
	/// Increments `.head` by one. If the increment resulted in a rollover to
	/// `0`, then the `.addr` field is increased to the next [`T::Mem`]
	/// stepping.
	///
	/// [`T::Mem`]: crate::store::BitStore::Mem
	</span><span class="attribute">#[inline]
	</span><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">unsafe fn </span>incr_head(<span class="kw-2">&amp;mut </span><span class="self">self</span>) {
		<span class="comment">//  Increment the cursor, permitting rollover to `T::Mem::BITS`.
		</span><span class="kw">let </span>head = <span class="self">self</span>.head().into_inner() <span class="kw">as </span>usize + <span class="number">1</span>;

		<span class="comment">//  Write the low bits into the `.len` field, then discard them.
		</span><span class="self">self</span>.len &amp;= !<span class="self">Self</span>::LEN_HEAD_MASK;
		<span class="self">self</span>.len |= head &amp; <span class="self">Self</span>::LEN_HEAD_MASK;
		<span class="kw">let </span>head = head &gt;&gt; <span class="self">Self</span>::LEN_HEAD_BITS;

		<span class="comment">//  Erase the high bits of `.head` from `.ptr`,
		</span><span class="kw">let </span><span class="kw-2">mut </span>ptr = <span class="self">self</span>.ptr.as_ptr() <span class="kw">as </span>usize;
		ptr &amp;= <span class="self">Self</span>::PTR_ADDR_MASK;
		<span class="comment">/* Then numerically add the high bits of `.head` into the low bits of
		`.ptr`. If the head increment rolled over into a new element, this will
		have the effect of raising the `.addr` logical field to the next element
		address, in one instruction.
		*/
		</span>ptr += head;
		<span class="self">self</span>.ptr = NonNull::new_unchecked(ptr <span class="kw">as </span><span class="kw-2">*mut </span>());
	}

	<span class="comment">//  Comparators

	</span><span class="doccomment">/// Renders the pointer structure into a formatter for use during
	/// higher-level type [`Debug`] implementations.
	///
	/// # Parameters
	///
	/// - `&amp;self`
	/// - `fmt`: The formatter into which the pointer is rendered.
	/// - `name`: The suffix of the structure rendering its pointer. The `Bit`
	///   prefix is applied to the object type name in this format.
	/// - `fields`: Any additional fields in the object’s debug info to be
	///   rendered.
	///
	/// # Returns
	///
	/// The result of formatting the pointer into the receiver.
	///
	/// # Behavior
	///
	/// This function writes `Bit{name}&lt;{ord}, {type}&gt; {{ {fields } }}` into the
	/// `fmt` formatter, where `{fields}` includes the address, head index, and
	/// bit length of the pointer, as well as any additional fields provided by
	/// the caller.
	///
	/// Higher types in the crate should use this function to drive their
	/// [`Debug`] implementations, and then use [`BitSlice`]’s list formatters
	/// to display their buffer contents.
	///
	/// [`BitSlice`]: crate::slice::BitSlice
	/// [`Debug`]: core::fmt::Debug
	</span><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn </span>render&lt;<span class="lifetime">&#39;a</span>&gt;(
		<span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span><span class="self">self</span>,
		fmt: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span><span class="kw-2">mut </span>Formatter,
		name: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span>str,
		fields: <span class="kw">impl </span>IntoIterator&lt;Item = <span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span>(<span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span>str, <span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span><span class="kw">dyn </span>Debug)&gt;,
	) -&gt; fmt::Result {
		<span class="macro">write!</span>(
			fmt,
			<span class="string">&quot;Bit{}&lt;{}, {}&gt;&quot;</span>,
			name,
			any::type_name::&lt;O&gt;(),
			any::type_name::&lt;T::Mem&gt;()
		)<span class="question-mark">?</span>;
		<span class="kw">let </span><span class="kw-2">mut </span>builder = fmt.debug_struct(<span class="string">&quot;&quot;</span>);
		builder
			.field(<span class="string">&quot;addr&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.address().fmt_pointer())
			.field(<span class="string">&quot;head&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.head().fmt_binary())
			.field(<span class="string">&quot;bits&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.len());
		<span class="kw">for </span>(name, value) <span class="kw">in </span>fields {
			builder.field(name, value);
		}
		builder.finish()
	}
}

<span class="kw">impl</span>&lt;O, T&gt; BitSpan&lt;Const, O, T&gt;
<span class="kw">where
	</span>O: BitOrder,
	T: BitStore,
{
	<span class="doccomment">/// Converts an opaque `*BitSlice` wide pointer back into a `BitSpan`.
	///
	/// This should compile down to a noöp, but the implementation should
	/// nevertheless be an explicit deconstruction and reconstruction rather
	/// than a bare [`mem::transmute`], to guard against unforseen compiler
	/// reördering.
	///
	/// # Parameters
	///
	/// - `raw`: An opaque bit-region pointer
	///
	/// # Returns
	///
	/// `raw`, interpreted as a `BitSpan` so that it can be used as more than an
	/// opaque handle.
	///
	/// [`mem::transmute`]: core::mem::transmute
	</span><span class="comment">//  Immutable pointers can only become immutable span descriptors.
	</span><span class="attribute">#[inline]
	</span><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn </span>from_bitslice_ptr(raw: <span class="kw-2">*const </span>BitSlice&lt;O, T&gt;) -&gt; <span class="self">Self </span>{
		<span class="kw">let </span>slice_nn = <span class="kw">match </span>NonNull::new(raw <span class="kw">as </span><span class="kw-2">*const </span>[()] <span class="kw">as </span><span class="kw-2">*mut </span>[()]) {
			<span class="prelude-val">Some</span>(nn) =&gt; nn,
			<span class="prelude-val">None </span>=&gt; <span class="kw">return </span><span class="self">Self</span>::EMPTY,
		};
		<span class="kw">let </span>ptr = slice_nn.cast::&lt;()&gt;();
		<span class="kw">let </span>len = <span class="kw">unsafe </span>{ slice_nn.as_ref() }.len();
		<span class="self">Self </span>{
			ptr,
			len,
			_or: PhantomData,
			_ty: PhantomData,
		}
	}
}

<span class="kw">impl</span>&lt;O, T&gt; BitSpan&lt;Mut, O, T&gt;
<span class="kw">where
	</span>O: BitOrder,
	T: BitStore,
{
	<span class="doccomment">/// Casts the `BitSpan` to an opaque `*BitSlice` pointer.
	///
	/// See [`.to_bitslice_ptr()`].
	///
	/// [`.to_bitslice_ptr()`]: Self::to_bitslice_ptr
	</span><span class="comment">//  Only mutable span descriptors can become mutable pointers.
	</span><span class="attribute">#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	</span><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn </span>to_bitslice_ptr_mut(<span class="self">self</span>) -&gt; <span class="kw-2">*mut </span>BitSlice&lt;O, T&gt; {
		<span class="self">self</span>.to_bitslice_ptr() <span class="kw">as </span><span class="kw-2">*mut </span>BitSlice&lt;O, T&gt;
	}

	<span class="doccomment">/// Casts the `BitSpan` to a `&amp;mut BitSlice` reference.
	///
	/// This requires that the pointer be to a validly-allocated region that is
	/// not destroyed for the duration of the provided lifetime. Additionally,
	/// the bits described by `self` must not be viewable by any other handle.
	///
	/// # Lifetimes
	///
	/// - `&#39;a`: A caller-provided lifetime that must not be greater than the
	///   duration of the referent buffer.
	///
	/// # Parameters
	///
	/// - `self`
	///
	/// # Returns
	///
	/// `self`, opacified as an exclusive bit-slice region reference rather than
	/// a `BitSpan` structure.
	</span><span class="comment">//  Only mutable span descriptors can become mutable references.
	</span><span class="attribute">#[inline(always)]
	#[cfg(not(tarpaulin_include))]
	</span><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn </span>to_bitslice_mut&lt;<span class="lifetime">&#39;a</span>&gt;(<span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span><span class="kw-2">mut </span>BitSlice&lt;O, T&gt; {
		<span class="kw">unsafe </span>{ <span class="kw-2">&amp;mut *</span><span class="self">self</span>.to_bitslice_ptr_mut() }
	}
}

<span class="attribute">#[cfg(not(tarpaulin_include))]
</span><span class="kw">impl</span>&lt;M, O, T&gt; Clone <span class="kw">for </span>BitSpan&lt;M, O, T&gt;
<span class="kw">where
	</span>M: Mutability,
	O: BitOrder,
	T: BitStore,
{
	<span class="attribute">#[inline(always)]
	</span><span class="kw">fn </span>clone(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="self">Self </span>{
		<span class="kw-2">*</span><span class="self">self
	</span>}
}

<span class="kw">impl</span>&lt;M, O, T&gt; Eq <span class="kw">for </span>BitSpan&lt;M, O, T&gt;
<span class="kw">where
	</span>M: Mutability,
	O: BitOrder,
	T: BitStore,
{
}

<span class="kw">impl</span>&lt;M1, M2, O, T1, T2&gt; PartialEq&lt;BitSpan&lt;M2, O, T2&gt;&gt; <span class="kw">for </span>BitSpan&lt;M1, O, T1&gt;
<span class="kw">where
	</span>M1: Mutability,
	M2: Mutability,
	O: BitOrder,
	T1: BitStore,
	T2: BitStore,
{
	<span class="attribute">#[inline]
	</span><span class="kw">fn </span>eq(<span class="kw-2">&amp;</span><span class="self">self</span>, other: <span class="kw-2">&amp;</span>BitSpan&lt;M2, O, T2&gt;) -&gt; bool {
		<span class="kw">let </span>(addr_a, head_a, bits_a) = <span class="self">self</span>.raw_parts();
		<span class="kw">let </span>(addr_b, head_b, bits_b) = other.raw_parts();
		<span class="comment">//  Since ::BITS is an associated const, the compiler will automatically
		//  replace the entire function with `false` when the types don’t match.
		</span>T1::Mem::BITS == T2::Mem::BITS
			&amp;&amp; addr_a.to_const() <span class="kw">as </span>usize == addr_b.to_const() <span class="kw">as </span>usize
			&amp;&amp; head_a.into_inner() == head_b.into_inner()
			&amp;&amp; bits_a == bits_b
	}
}

<span class="attribute">#[cfg(not(tarpaulin_include))]
</span><span class="kw">impl</span>&lt;M, O, T&gt; Default <span class="kw">for </span>BitSpan&lt;M, O, T&gt;
<span class="kw">where
	</span>M: Mutability,
	O: BitOrder,
	T: BitStore,
{
	<span class="attribute">#[inline(always)]
	</span><span class="kw">fn </span>default() -&gt; <span class="self">Self </span>{
		<span class="self">Self</span>::EMPTY
	}
}

<span class="attribute">#[cfg(not(tarpaulin_include))]
</span><span class="kw">impl</span>&lt;M, O, T&gt; Debug <span class="kw">for </span>BitSpan&lt;M, O, T&gt;
<span class="kw">where
	</span>M: Mutability,
	O: BitOrder,
	T: BitStore,
{
	<span class="attribute">#[inline(always)]
	</span><span class="kw">fn </span>fmt(<span class="kw-2">&amp;</span><span class="self">self</span>, fmt: <span class="kw-2">&amp;mut </span>Formatter) -&gt; fmt::Result {
		Pointer::fmt(<span class="self">self</span>, fmt)
	}
}

<span class="attribute">#[cfg(not(tarpaulin_include))]
</span><span class="kw">impl</span>&lt;M, O, T&gt; Pointer <span class="kw">for </span>BitSpan&lt;M, O, T&gt;
<span class="kw">where
	</span>M: Mutability,
	O: BitOrder,
	T: BitStore,
{
	<span class="attribute">#[inline(always)]
	</span><span class="kw">fn </span>fmt(<span class="kw-2">&amp;</span><span class="self">self</span>, fmt: <span class="kw-2">&amp;mut </span>Formatter) -&gt; fmt::Result {
		<span class="self">self</span>.render(fmt, <span class="string">&quot;Ptr&quot;</span>, <span class="prelude-val">None</span>)
	}
}

<span class="kw">impl</span>&lt;M, O, T&gt; Copy <span class="kw">for </span>BitSpan&lt;M, O, T&gt;
<span class="kw">where
	</span>M: Mutability,
	O: BitOrder,
	T: BitStore,
{
}

<span class="doccomment">/// An error produced when creating `BitSpan` encoded references.
</span><span class="attribute">#[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
</span><span class="kw">pub enum </span>BitSpanError&lt;T&gt;
<span class="kw">where </span>T: BitStore
{
	<span class="doccomment">/// The base `BitPtr` is invalid.
	</span>InvalidBitptr(BitPtrError&lt;T&gt;),
	<span class="doccomment">/// `BitSpan` domains have a length ceiling.
	</span>TooLong(usize),
	<span class="doccomment">/// `BitSpan` domains have an address ceiling.
	</span>TooHigh(<span class="kw-2">*const </span>T),
}

<span class="attribute">#[cfg(not(tarpaulin_include))]
</span><span class="kw">impl</span>&lt;T&gt; From&lt;BitPtrError&lt;T&gt;&gt; <span class="kw">for </span>BitSpanError&lt;T&gt;
<span class="kw">where </span>T: BitStore
{
	<span class="attribute">#[inline(always)]
	</span><span class="kw">fn </span>from(err: BitPtrError&lt;T&gt;) -&gt; <span class="self">Self </span>{
		<span class="self">Self</span>::InvalidBitptr(err)
	}
}

<span class="attribute">#[cfg(not(tarpaulin_include))]
</span><span class="kw">impl</span>&lt;T&gt; From&lt;Infallible&gt; <span class="kw">for </span>BitSpanError&lt;T&gt;
<span class="kw">where </span>T: BitStore
{
	<span class="attribute">#[inline(always)]
	</span><span class="kw">fn </span>from(<span class="kw">_</span>: Infallible) -&gt; <span class="self">Self </span>{
		<span class="macro">unreachable!</span>(<span class="string">&quot;Infallible errors can never be produced&quot;</span>);
	}
}

<span class="attribute">#[cfg(not(tarpaulin_include))]
</span><span class="kw">impl</span>&lt;T&gt; Debug <span class="kw">for </span>BitSpanError&lt;T&gt;
<span class="kw">where </span>T: BitStore
{
	<span class="attribute">#[inline]
	</span><span class="kw">fn </span>fmt(<span class="kw-2">&amp;</span><span class="self">self</span>, fmt: <span class="kw-2">&amp;mut </span>Formatter) -&gt; fmt::Result {
		<span class="kw">let </span>tname = any::type_name::&lt;T&gt;();
		<span class="macro">write!</span>(fmt, <span class="string">&quot;BitSpanError&lt;{}&gt;::&quot;</span>, tname,)<span class="question-mark">?</span>;
		<span class="kw">match </span><span class="self">self </span>{
			<span class="self">Self</span>::InvalidBitptr(err) =&gt; {
				fmt.debug_tuple(<span class="string">&quot;InvalidBitptr&quot;</span>).field(<span class="kw-2">&amp;</span>err).finish()
			},
			<span class="self">Self</span>::TooLong(len) =&gt; {
				fmt.debug_tuple(<span class="string">&quot;TooLong&quot;</span>).field(<span class="kw-2">&amp;</span>len).finish()
			},
			<span class="self">Self</span>::TooHigh(addr) =&gt; {
				fmt.debug_tuple(<span class="string">&quot;TooHigh&quot;</span>).field(<span class="kw-2">&amp;</span>addr).finish()
			},
		}
	}
}

<span class="attribute">#[cfg(not(tarpaulin_include))]
</span><span class="kw">impl</span>&lt;T&gt; Display <span class="kw">for </span>BitSpanError&lt;T&gt;
<span class="kw">where </span>T: BitStore
{
	<span class="attribute">#[inline]
	</span><span class="kw">fn </span>fmt(<span class="kw-2">&amp;</span><span class="self">self</span>, fmt: <span class="kw-2">&amp;mut </span>Formatter) -&gt; fmt::Result {
		<span class="kw">match </span><span class="self">self </span>{
			<span class="self">Self</span>::InvalidBitptr(err) =&gt; Display::fmt(err, fmt),
			<span class="self">Self</span>::TooLong(len) =&gt; <span class="macro">write!</span>(
				fmt,
				<span class="string">&quot;Length {} is too long to encode in a bit slice, which can \
				 only accept {} bits&quot;</span>,
				len,
				BitSpan::&lt;Const, Lsb0, usize&gt;::REGION_MAX_BITS
			),
			<span class="self">Self</span>::TooHigh(addr) =&gt; {
				<span class="macro">write!</span>(fmt, <span class="string">&quot;Address {:p} would wrap the address space&quot;</span>, addr)
			},
		}
	}
}

<span class="kw">unsafe impl</span>&lt;T&gt; Send <span class="kw">for </span>BitSpanError&lt;T&gt; <span class="kw">where </span>T: BitStore
{
}

<span class="kw">unsafe impl</span>&lt;T&gt; Sync <span class="kw">for </span>BitSpanError&lt;T&gt; <span class="kw">where </span>T: BitStore
{
}

<span class="attribute">#[cfg(feature = <span class="string">&quot;std&quot;</span>)]
</span><span class="kw">impl</span>&lt;T&gt; std::error::Error <span class="kw">for </span>BitSpanError&lt;T&gt; <span class="kw">where </span>T: BitStore
{
}

<span class="attribute">#[cfg(test)]
</span><span class="kw">mod </span>tests {
	<span class="kw">use </span>core::{
		convert::TryFrom,
		mem,
		ptr,
	};

	<span class="kw">use </span>tap::Pipe;

	<span class="kw">use super</span>::<span class="kw-2">*</span>;
	<span class="kw">use crate</span>::{
		prelude::<span class="kw-2">*</span>,
		ptr::{
			check_alignment,
			MisalignError,
			NullPtrError,
		},
	};

	<span class="attribute">#[test]
	</span><span class="kw">fn </span>ctor() {
		<span class="macro">assert!</span>(<span class="macro">matches!</span>(
			Address::&lt;Const, u8&gt;::try_from(ptr::null()),
			<span class="prelude-val">Err</span>(NullPtrError),
		));
		<span class="macro">assert!</span>(<span class="macro">matches!</span>(
			Address::&lt;Const, u16&gt;::try_from(<span class="number">3 </span><span class="kw">as </span><span class="kw-2">*const </span>u16).unwrap().pipe(check_alignment),
			<span class="prelude-val">Err</span>(MisalignError { ptr }) <span class="kw">if </span>ptr <span class="kw">as </span>usize == <span class="number">3</span>,
		));

		<span class="comment">//  Double check the null pointers, but they are in practice impossible
		//  to construct.
		</span><span class="macro">assert_eq!</span>(
			BitSpan::&lt;Const, LocalBits, u8&gt;::from_bitslice_ptr(
				ptr::slice_from_raw_parts(ptr::null::&lt;()&gt;(), <span class="number">1</span>)
					<span class="kw">as </span><span class="kw-2">*mut </span>BitSlice&lt;LocalBits, u8&gt;
			),
			BitSpan::&lt;Const, LocalBits, u8&gt;::EMPTY,
		);

		<span class="kw">let </span>data = <span class="number">0u16</span>;
		<span class="kw">let </span><span class="kw-2">mut </span>addr = Address::from(<span class="kw-2">&amp;</span>data);
		<span class="kw">let </span>head = BitIdx::new(<span class="number">5</span>).unwrap();
		<span class="macro">assert!</span>(BitSpan::&lt;<span class="kw">_</span>, Lsb0, <span class="kw">_</span>&gt;::new(addr, head, !<span class="number">3</span>).is_err());
		addr = Address::try_from(!<span class="number">1 </span><span class="kw">as </span><span class="kw-2">*const </span>u16).unwrap();
		<span class="macro">assert!</span>(BitSpan::&lt;<span class="kw">_</span>, Lsb0, <span class="kw">_</span>&gt;::new(addr, head, <span class="number">50</span>).is_err());
	}

	<span class="attribute">#[test]
	</span><span class="kw">fn </span>recast() {
		<span class="kw">let </span>data = <span class="number">0u32</span>;
		<span class="kw">let </span>bitspan = <span class="kw">unsafe </span>{ BitPtr::from_ref(<span class="kw-2">&amp;</span>data).span_unchecked(<span class="number">32</span>) };
		<span class="kw">let </span>raw_ptr = bitspan.to_bitslice_ptr();
		<span class="macro">assert_eq!</span>(
			bitspan,
			BitSpan::&lt;Const, Lsb0, u32&gt;::from_bitslice_ptr(raw_ptr)
		);
	}

	<span class="attribute">#[test]
	</span><span class="kw">fn </span>realign() {
		<span class="kw">let </span>data = [<span class="number">0u8</span>; <span class="number">10</span>];
		<span class="kw">let </span>bits = data.view_bits::&lt;LocalBits&gt;();

		<span class="kw">let </span>(l, c, r) = <span class="kw">unsafe </span>{ bits.as_bitspan().align_to::&lt;u16&gt;() };
		<span class="macro">assert_eq!</span>(l.len() + c.len() + r.len(), <span class="number">80</span>);

		<span class="kw">let </span>(l, c, r) = <span class="kw">unsafe </span>{ bits[<span class="number">4 </span>..].as_bitspan().align_to::&lt;u16&gt;() };
		<span class="macro">assert_eq!</span>(l.len() + c.len() + r.len(), <span class="number">76</span>);

		<span class="kw">let </span>(l, c, r) = <span class="kw">unsafe </span>{ bits[.. <span class="number">76</span>].as_bitspan().align_to::&lt;u16&gt;() };
		<span class="macro">assert_eq!</span>(l.len() + c.len() + r.len(), <span class="number">76</span>);

		<span class="kw">let </span>(l, c, r) = <span class="kw">unsafe </span>{ bits[<span class="number">8 </span>..].as_bitspan().align_to::&lt;u16&gt;() };
		<span class="macro">assert_eq!</span>(l.len() + c.len() + r.len(), <span class="number">72</span>);

		<span class="kw">let </span>(l, c, r) = <span class="kw">unsafe </span>{ bits[.. <span class="number">72</span>].as_bitspan().align_to::&lt;u16&gt;() };
		<span class="macro">assert_eq!</span>(l.len() + c.len() + r.len(), <span class="number">72</span>);

		<span class="kw">let </span>(l, c, r) = <span class="kw">unsafe </span>{ bits[<span class="number">4 </span>.. <span class="number">76</span>].as_bitspan().align_to::&lt;u16&gt;() };
		<span class="macro">assert_eq!</span>(l.len() + c.len() + r.len(), <span class="number">72</span>);
	}

	<span class="attribute">#[test]
	</span><span class="kw">fn </span>modify() {
		<span class="kw">let </span>(a, b) = (<span class="number">0u16</span>, <span class="number">1u16</span>);

		<span class="kw">let </span><span class="kw-2">mut </span>bitspan = a.view_bits::&lt;LocalBits&gt;().as_bitspan();
		<span class="kw">let </span><span class="kw-2">mut </span>expected = (<span class="kw-2">&amp;</span>a <span class="kw">as </span><span class="kw-2">*const </span><span class="kw">_ as </span>usize, <span class="number">16usize </span>&lt;&lt; <span class="number">3</span>);

		<span class="macro">assert_eq!</span>(bitspan.address().to_const(), <span class="kw-2">&amp;</span>a <span class="kw">as </span><span class="kw-2">*const </span><span class="kw">_</span>);
		<span class="macro">assert_eq!</span>(bitspan.ptr.as_ptr() <span class="kw">as </span>usize, expected.<span class="number">0</span>);
		<span class="macro">assert_eq!</span>(bitspan.len, expected.<span class="number">1</span>);

		expected.<span class="number">0 </span>= <span class="kw-2">&amp;</span>b <span class="kw">as </span><span class="kw-2">*const </span><span class="kw">_ as </span>usize;
		<span class="kw">unsafe </span>{
			bitspan.set_address(<span class="kw-2">&amp;</span>b <span class="kw">as </span><span class="kw-2">*const </span><span class="kw">_</span>);
		}
		<span class="macro">assert_eq!</span>(bitspan.address().to_const(), <span class="kw-2">&amp;</span>b <span class="kw">as </span><span class="kw-2">*const </span><span class="kw">_</span>);
		<span class="macro">assert_eq!</span>(bitspan.ptr.as_ptr() <span class="kw">as </span>usize, expected.<span class="number">0</span>);
		<span class="macro">assert_eq!</span>(bitspan.len, expected.<span class="number">1</span>);

		<span class="kw">let </span>orig_head = bitspan.head();
		<span class="kw">unsafe </span>{
			bitspan.set_head(orig_head.next().<span class="number">0</span>);
		}
		<span class="macro">assert_eq!</span>(bitspan.head(), orig_head.next().<span class="number">0</span>);
	}

	<span class="attribute">#[test]
	</span><span class="kw">fn </span>mem_size() {
		<span class="macro">assert_eq!</span>(
			mem::size_of::&lt;BitSpan&lt;Const, LocalBits, usize&gt;&gt;(),
			mem::size_of::&lt;<span class="kw-2">*const </span>[usize]&gt;()
		);
		<span class="macro">assert_eq!</span>(
			mem::size_of::&lt;<span class="prelude-ty">Option</span>&lt;BitSpan&lt;Const, LocalBits, usize&gt;&gt;&gt;(),
			mem::size_of::&lt;<span class="kw-2">*const </span>[usize]&gt;()
		);
	}
}
</code></pre></div>
</section></div></main><div id="rustdoc-vars" data-root-path="../../../" data-current-crate="bitvec" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.65.0 (897e37553 2022-11-02)" ></div></body></html>